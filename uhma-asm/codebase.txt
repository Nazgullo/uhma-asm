; boot.asm — System startup: surface, handlers, channels, REPL
;
; @entry _start -> ELF entry point, never returns
; @calls surface.asm:surface_init
; @calls signal.asm:install_fault_handlers
; @calls dispatch.asm:dispatch_init
; @calls vsa.asm:vsa_init_random
; @calls verify.asm:verify_init
; @calls maturity.asm:maturity_init
; @calls channels.asm:channels_init
; @calls repl.asm:repl_run
;
; STARTUP SEQUENCE:
;   1. surface_init()           - mmap 8GB sparse persistent file
;   2. install_fault_handlers() - SIGSEGV/SIGFPE/SIGBUS recovery
;   3. dispatch_init()          - init dispatch tree with echo behavior
;   4. vsa_init_random()        - seed random vectors for VSA arena
;   5. verify_init()            - assembly brittleness protection
;   6. maturity_init()          - developmental gating (Stage 0)
;   7. channels_init()          - 6-channel TCP listeners (9999-9994)
;   8. repl_run()               - main loop (stdin + TCP channels)
;
; NOTE: Stack aligned to 16 at entry. repl_run never returns.
;
%include "syscalls.inc"
%include "constants.inc"

section .text

global _start

extern surface_init
extern install_fault_handlers
extern repl_run
extern dispatch_init
extern vsa_init_random
extern verify_init
extern verify_vsa_math
extern maturity_init
extern channels_init

;; ============================================================
;; _start — Entry point
;; 1. mmap the 8GB RWX surface
;; 2. Initialize state block
;; 3. Install signal handlers
;; 4. Initialize dispatch tree with echo behavior
;; 5. Initialize VSA arena (random base vectors)
;; 6. Enter REPL
;; ============================================================
_start:
    ; Align stack
    and rsp, ~15

    ; 1. Initialize the surface (mmap + state block setup)
    call surface_init
    ; rax = surface base (should be SURFACE_BASE)

    ; 2. Install fault handlers (SIGSEGV, SIGFPE, SIGBUS)
    call install_fault_handlers

    ; 3. Initialize the dispatch tree with a minimal echo region
    call dispatch_init

    ; 4. Initialize VSA arena with random vectors for initial tokens
    call vsa_init_random

    ; 5. Initialize verification system (assembly brittleness protection)
    call verify_init

    ; 5b. Verify VSA binding mathematics at startup
    call verify_vsa_math

    ; 6. Initialize maturity/developmental gating
    call maturity_init

    ; 7. Initialize metabolic energy pool
    mov rbx, SURFACE_BASE
    mov rax, ENERGY_INITIAL
    mov [rbx + STATE_OFFSET + ST_ENERGY], rax
    ; Initialize tempo to 1.0 (normal rhythm)
    mov rax, 0x3FF0000000000000    ; 1.0 f64
    mov [rbx + STATE_OFFSET + ST_TEMPO_MULT], rax

    ; 8. Initialize multi-channel I/O (6 TCP channels)
    call channels_init

    ; 9. Enter the interactive REPL (never returns)
    call repl_run

    ; Should not reach here
    mov edi, 0
    mov rax, SYS_EXIT
    syscall
; channels.asm — 6-channel paired TCP I/O for UHMA
;
; @entry channels_init() -> eax=1 success, 0 failure
; @entry channels_poll() -> eax=input channel (0,2,4), -1 stdin, -2 timeout
; @entry channels_read(edi=channel, rsi=buf, edx=len) -> eax=bytes read
; @entry channels_write(edi=channel, rsi=buf, edx=len) -> eax=bytes written
; @entry channels_respond(edi=input_ch, rsi=buf, edx=len) -> writes to input_ch+1
; @entry channels_accept() -> accepts pending connection on channel r12d
; @entry get_channel_fd(edi=channel) -> eax=socket fd or -1
; @entry channels_shutdown() -> closes all sockets
; @calls format.asm:print_cstr, print_u64
; @calls signal.asm:set_sigpipe_mode (enables TCP mode on init)
; @calledby boot.asm:_start, repl.asm:repl_run
;
; CHANNEL PAIRS (synchronous request/response):
;   FEED:  CH0:9999 (in) → CH1:9998 (out) - eat, dream, observe
;   QUERY: CH2:9997 (in) → CH3:9996 (out) - status, why, misses
;   DEBUG: CH4:9995 (in) → CH5:9994 (out) - trace, receipts
;
; PROTOCOL:
;   Client connects to input port, sends command, reads from output port
;   UHMA polls input channels, executes command, writes to paired output
;   Output channel = input channel + 1 (handled by channels_respond)
;
; GOTCHAS:
;   - channels_init() sets SIGPIPE to ignore mode (survives client disconnect)
;   - stdin is channel -1 for backwards compat (headless: stdin_active=0)
;   - get_channel_fd() returns socket fd, not channel number
;   - Poll skips dead stdin (fd=-1) and output channels (odd numbers)

%include "syscalls.inc"
%include "constants.inc"

section .data
    NUM_CHANNELS    equ 6
    BASE_PORT       equ 9999

    ; Channel indices
    CH_FEED_IN      equ 0             ; 9999 - feed input
    CH_FEED_OUT     equ 1             ; 9998 - feed output
    CH_QUERY_IN     equ 2             ; 9997 - query input
    CH_QUERY_OUT    equ 3             ; 9996 - query output
    CH_DEBUG_IN     equ 4             ; 9995 - debug input
    CH_DEBUG_OUT    equ 5             ; 9994 - debug output

    ch_init_msg:    db "[CHANNELS] 6-channel I/O ready", 10
                    db "  FEED:  9999->9998", 10
                    db "  QUERY: 9997->9996", 10
                    db "  DEBUG: 9995->9994", 10, 0
    ch_accept_msg:  db "[CH", 0
    ch_accept_end:  db "] connected", 10, 0
    ch_close_msg:   db "[CH", 0
    ch_close_end:   db "] disconnected", 10, 0

section .bss
    ; Listening sockets (one per channel)
    listen_fds:     resd 6

    ; Client sockets (-1 if no client)
    client_fds:     resd 6

    ; Poll structures: stdin + 6 listeners + 6 clients = 13
    ; struct pollfd { int fd; short events; short revents; } = 8 bytes
    poll_fds:       resb 8 * 13

    ; sockaddr_in for bind/accept
    sock_addr:      resb 16
    addr_len:       resd 1

    channels_ready: resd 1

section .text

extern print_cstr
extern print_u64
extern stdin_active               ; from repl.asm - 0 if stdin EOF
extern set_sigpipe_mode           ; from signal.asm - 0=exit, 1=ignore

global channels_init
global channels_poll
global channels_read
global channels_write
global channels_respond
global channels_shutdown
global channels_accept
global get_channel_fd

;; ============================================================
;; channels_init — Create 6 listening sockets
;; Returns: eax=1 success, 0 failure
;; ============================================================
channels_init:
    push rbx
    push r12
    push r13
    push r14
    sub rsp, 8                        ; align (4 pushes = even, +8)

    ; Init client fds to -1
    mov eax, -1
    mov [rel client_fds], eax
    mov [rel client_fds + 4], eax
    mov [rel client_fds + 8], eax
    mov [rel client_fds + 12], eax
    mov [rel client_fds + 16], eax
    mov [rel client_fds + 20], eax

    xor r12d, r12d                    ; channel index

.init_loop:
    cmp r12d, NUM_CHANNELS
    jge .init_done

    ; socket(AF_INET, SOCK_STREAM, 0)
    mov eax, SYS_SOCKET
    mov edi, AF_INET
    mov esi, SOCK_STREAM
    xor edx, edx
    syscall
    test eax, eax
    js .init_fail
    mov ebx, eax                      ; save fd

    lea rcx, [rel listen_fds]
    mov [rcx + r12 * 4], eax

    ; setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &1, 4)
    mov eax, SYS_SETSOCKOPT
    mov edi, ebx
    mov esi, SOL_SOCKET
    mov edx, SO_REUSEADDR
    lea r10, [rel addr_len]
    mov dword [r10], 1
    mov r8d, 4
    syscall

    ; Setup sockaddr_in
    lea rdi, [rel sock_addr]
    mov word [rdi], AF_INET           ; sin_family
    ; Port = BASE_PORT - channel
    mov eax, BASE_PORT
    sub eax, r12d
    xchg al, ah                       ; htons
    mov [rdi + 2], ax
    mov dword [rdi + 4], 0            ; INADDR_ANY

    ; bind
    mov eax, SYS_BIND
    mov edi, ebx
    lea rsi, [rel sock_addr]
    mov edx, 16
    syscall
    test eax, eax
    js .init_fail

    ; listen
    mov eax, SYS_LISTEN
    mov edi, ebx
    mov esi, 5
    syscall
    test eax, eax
    js .init_fail

    inc r12d
    jmp .init_loop

.init_done:
    mov dword [rel channels_ready], 1
    ; Enable SIGPIPE ignore mode for TCP operation
    mov edi, 1
    call set_sigpipe_mode
    lea rdi, [rel ch_init_msg]
    call print_cstr
    mov eax, 1
    jmp .init_ret

.init_fail:
    ; Close opened sockets
    xor r13d, r13d
.close_loop:
    cmp r13d, r12d
    jge .init_ret_fail
    lea rcx, [rel listen_fds]
    mov edi, [rcx + r13 * 4]
    mov eax, SYS_CLOSE
    syscall
    inc r13d
    jmp .close_loop

.init_ret_fail:
    xor eax, eax

.init_ret:
    add rsp, 8
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; channels_poll — Wait for data on input channels or stdin
;; Only polls INPUT channels (0,2,4) + stdin
;; Returns: eax = input channel (0,2,4), -1 stdin, -2 timeout
;; ============================================================
channels_poll:
    push rbx
    push r12
    push r13
    sub rsp, 8

    lea rbx, [rel poll_fds]

    ; Entry 0: stdin (use -1 if stdin is dead to skip it)
    mov eax, [rel stdin_active]
    test eax, eax
    jz .stdin_dead
    mov dword [rbx], 0                ; fd = stdin
    jmp .stdin_set
.stdin_dead:
    mov dword [rbx], -1               ; -1 = poll ignores this entry
.stdin_set:
    mov word [rbx + 4], POLLIN
    mov word [rbx + 6], 0

    ; Entries 1-6: listening sockets
    xor r12d, r12d
.add_listeners:
    cmp r12d, NUM_CHANNELS
    jge .add_clients

    lea rcx, [rel listen_fds]
    mov eax, [rcx + r12 * 4]
    lea rcx, [rbx + 8 + r12 * 8]
    mov [rcx], eax
    mov word [rcx + 4], POLLIN
    mov word [rcx + 6], 0

    inc r12d
    jmp .add_listeners

.add_clients:
    ; Entries 7-12: client sockets
    xor r12d, r12d
.add_client:
    cmp r12d, NUM_CHANNELS
    jge .do_poll

    lea rcx, [rel client_fds]
    mov eax, [rcx + r12 * 4]
    lea rcx, [rbx + 56 + r12 * 8]     ; offset 7*8 = 56
    mov [rcx], eax
    mov word [rcx + 4], POLLIN
    mov word [rcx + 6], 0

    inc r12d
    jmp .add_client

.do_poll:
    mov eax, SYS_POLL
    lea rdi, [rel poll_fds]
    mov esi, 13
    mov edx, 100                      ; 100ms timeout
    syscall
    test eax, eax
    jle .poll_timeout

    ; Check stdin
    lea rbx, [rel poll_fds]
    movzx eax, word [rbx + 6]
    test ax, POLLIN
    jnz .poll_stdin

    ; Check listeners for new connections
    xor r12d, r12d
.check_listeners:
    cmp r12d, NUM_CHANNELS
    jge .check_clients

    lea rcx, [rbx + 8 + r12 * 8]
    movzx eax, word [rcx + 6]
    test ax, POLLIN
    jnz .do_accept

    inc r12d
    jmp .check_listeners

.check_clients:
    ; Only check INPUT channels (0, 2, 4) for data
    xor r12d, r12d
.check_input_client:
    cmp r12d, NUM_CHANNELS
    jge .poll_timeout

    ; Skip output channels (1, 3, 5)
    test r12d, 1
    jnz .next_input

    lea rcx, [rbx + 56 + r12 * 8]
    movzx eax, word [rcx + 6]
    test ax, POLLIN
    jnz .got_input

.next_input:
    inc r12d
    jmp .check_input_client

.got_input:
    mov eax, r12d                     ; return input channel
    jmp .poll_ret

.poll_stdin:
    mov eax, -1
    jmp .poll_ret

.do_accept:
    mov r13d, r12d
    call channels_accept
    jmp .do_poll                      ; re-poll (stay in same stack frame)

.poll_timeout:
    mov eax, -2

.poll_ret:
    add rsp, 8
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; channels_accept — Accept connection on channel r12d
;; ============================================================
channels_accept:
    push rbx
    sub rsp, 16

    lea rcx, [rel listen_fds]
    mov edi, [rcx + r12 * 4]

    mov dword [rel addr_len], 16
    mov eax, SYS_ACCEPT
    lea rsi, [rel sock_addr]
    lea rdx, [rel addr_len]
    syscall
    test eax, eax
    js .accept_done

    ; Close old client if exists
    lea rcx, [rel client_fds]
    mov ebx, [rcx + r12 * 4]
    cmp ebx, -1
    je .store_new
    push rax
    mov edi, ebx
    mov eax, SYS_CLOSE
    syscall
    pop rax

.store_new:
    lea rcx, [rel client_fds]
    mov [rcx + r12 * 4], eax

    ; Print [CHn] connected
    lea rdi, [rel ch_accept_msg]
    call print_cstr
    mov edi, r12d
    call print_u64
    lea rdi, [rel ch_accept_end]
    call print_cstr

.accept_done:
    add rsp, 16
    pop rbx
    ret

;; ============================================================
;; channels_read — Read from channel's client socket
;; edi=channel, rsi=buf, edx=len
;; Returns: eax=bytes, 0 on disconnect
;; ============================================================
channels_read:
    push rbx
    push r12
    sub rsp, 8

    mov r12d, edi
    mov rbx, rsi

    cmp r12d, NUM_CHANNELS
    jge .read_err

    lea rcx, [rel client_fds]
    mov edi, [rcx + r12 * 4]
    cmp edi, -1
    je .read_err

    mov eax, SYS_READ
    mov rsi, rbx
    syscall

    test eax, eax
    jle .read_disconnect
    jmp .read_ret

.read_disconnect:
    lea rcx, [rel client_fds]
    mov edi, [rcx + r12 * 4]
    push rax
    mov eax, SYS_CLOSE
    syscall
    pop rax

    lea rcx, [rel client_fds]
    mov dword [rcx + r12 * 4], -1

    lea rdi, [rel ch_close_msg]
    call print_cstr
    mov edi, r12d
    call print_u64
    lea rdi, [rel ch_close_end]
    call print_cstr

    xor eax, eax
    jmp .read_ret

.read_err:
    xor eax, eax

.read_ret:
    add rsp, 8
    pop r12
    pop rbx
    ret

;; ============================================================
;; channels_write — Write to channel's client socket
;; edi=channel, rsi=buf, edx=len
;; Returns: eax=bytes written
;; ============================================================
channels_write:
    push rbx
    push r12
    sub rsp, 8

    mov r12d, edi

    cmp r12d, NUM_CHANNELS
    jge .write_err

    lea rcx, [rel client_fds]
    mov edi, [rcx + r12 * 4]
    cmp edi, -1
    je .write_err

    mov eax, SYS_WRITE
    syscall
    jmp .write_ret

.write_err:
    xor eax, eax

.write_ret:
    add rsp, 8
    pop r12
    pop rbx
    ret

;; ============================================================
;; get_channel_fd — Get socket fd for channel
;; edi=channel number (0-5)
;; Returns: eax=socket fd, or -1 if invalid/not connected
;; ============================================================
get_channel_fd:
    cmp edi, NUM_CHANNELS
    jge .invalid
    lea rax, [rel client_fds]
    mov eax, [rax + rdi * 4]
    ret
.invalid:
    mov eax, -1
    ret

;; ============================================================
;; channels_respond — Write response to paired output channel
;; edi=input_channel (0,2,4), rsi=buf, edx=len
;; Automatically routes to edi+1 (output channel)
;; Returns: eax=bytes written
;; ============================================================
channels_respond:
    ; Output channel = input channel + 1
    inc edi
    jmp channels_write

;; ============================================================
;; channels_shutdown — Close all sockets
;; ============================================================
channels_shutdown:
    push rbx
    push r12
    sub rsp, 8

    ; Close clients
    xor r12d, r12d
.shut_clients:
    cmp r12d, NUM_CHANNELS
    jge .shut_listeners

    lea rcx, [rel client_fds]
    mov edi, [rcx + r12 * 4]
    cmp edi, -1
    je .shut_next_client

    mov eax, SYS_CLOSE
    syscall

.shut_next_client:
    inc r12d
    jmp .shut_clients

.shut_listeners:
    xor r12d, r12d
.shut_listen_loop:
    cmp r12d, NUM_CHANNELS
    jge .shut_done

    lea rcx, [rel listen_fds]
    mov edi, [rcx + r12 * 4]
    mov eax, SYS_CLOSE
    syscall

    inc r12d
    jmp .shut_listen_loop

.shut_done:
    mov dword [rel channels_ready], 0

    add rsp, 8
    pop r12
    pop rbx
    ret
; decode.asm — x86 instruction decoder for self-reading and verification
;
; ENTRY POINTS:
;   decode_instruction_length(ptr)        → eax=length in bytes
;   decode_instruction_full(ptr, out_buf) → fills DecodedInstr struct
;   decode_region_instructions(hdr, out)  → decode all instrs in region
;   count_region_instructions(hdr)        → eax=instruction count
;   classify_opcode(opcode)               → eax=OpClass enum
;
; DATA FLOW:
;   Raw bytes → REX detection → opcode dispatch → ModR/M → SIB → displ → imm
;   Output: length, opcode class, registers used, memory access info
;
; OPCODE CLASSES (used by verify.asm):
;   OP_CMP, OP_JCC, OP_MOV, OP_CALL, OP_RET, OP_SYSCALL, OP_PUSH, OP_POP, etc.
;
; CALLED BY:
;   verify.asm:  verify_modification() for abstract interpretation
;   introspect.asm: introspect_region() for semantic analysis
;   factor.asm: suffix length detection
;
%include "syscalls.inc"
%include "constants.inc"

section .data
    ; Register mapping for push/pop (0x50-0x5F -> REG_*)
    push_reg_map: db REG_RAX, REG_RCX, REG_RDX, REG_RBX, REG_RSP, REG_RBP, REG_RSI, REG_RDI
    pop_reg_map:  db REG_RAX, REG_RCX, REG_RDX, REG_RBX, REG_RSP, REG_RBP, REG_RSI, REG_RDI

section .text

;; ============================================================
;; decode_instruction_length(ptr) → eax (length in bytes)
;; rdi=pointer to instruction
;; Returns the length of the x86_64 instruction at ptr
;; Handles common instructions used in dispatch patterns
;; ============================================================
global decode_instruction_length
decode_instruction_length:
    movzx eax, byte [rdi]     ; first byte (opcode or prefix)

    ; Check for REX prefix (0x40-0x4F)
    cmp al, 0x40
    jl .no_rex
    cmp al, 0x4F
    jg .no_rex
    ; REX prefix: read next byte as actual opcode
    inc rdi
    movzx eax, byte [rdi]
    ; Add 1 for REX prefix to final length
    push 1                    ; prefix_len on stack
    jmp .decode_opcode

.no_rex:
    push 0                    ; no prefix

.decode_opcode:
    ; --- Single byte instructions ---
    cmp al, 0x90              ; NOP
    je .len1
    cmp al, 0xC3              ; RET
    je .len1
    cmp al, 0xCC              ; INT3
    je .len1
    cmp al, 0xF4              ; HLT
    je .len1
    cmp al, 0xCB              ; RETF
    je .len1

    ; --- Two byte instructions ---
    cmp al, 0x31              ; XOR r/m32, r32 (XOR eax, eax = 31 C0)
    je .len2_modrm
    cmp al, 0x29              ; SUB r/m, r
    je .len2_modrm
    cmp al, 0x01              ; ADD r/m, r
    je .len2_modrm
    cmp al, 0x09              ; OR r/m, r
    je .len2_modrm
    cmp al, 0x21              ; AND r/m, r
    je .len2_modrm
    cmp al, 0x39              ; CMP r/m, r
    je .len2_modrm
    cmp al, 0x89              ; MOV r/m, r
    je .len2_modrm
    cmp al, 0x8B              ; MOV r, r/m
    je .len2_modrm

    ; --- Relative jump short (2 bytes) ---
    cmp al, 0x70
    jl .not_jcc_short
    cmp al, 0x7F
    jg .not_jcc_short
    jmp .len2               ; Jcc rel8
.not_jcc_short:
    cmp al, 0xEB              ; JMP rel8
    je .len2

    ; --- 5-byte instructions ---
    cmp al, 0x3D              ; CMP eax, imm32
    je .len5
    cmp al, 0x05              ; ADD eax, imm32
    je .len5
    cmp al, 0x2D              ; SUB eax, imm32
    je .len5
    cmp al, 0x25              ; AND eax, imm32
    je .len5
    cmp al, 0x0D              ; OR eax, imm32
    je .len5
    cmp al, 0x35              ; XOR eax, imm32
    je .len5
    cmp al, 0xB8              ; MOV eax, imm32
    je .len5
    cmp al, 0xB9              ; MOV ecx, imm32
    je .len5
    cmp al, 0xBA              ; MOV edx, imm32
    je .len5
    cmp al, 0xBB              ; MOV ebx, imm32
    je .len5

    ; --- 5-byte: JMP/CALL rel32 ---
    cmp al, 0xE8              ; CALL rel32
    je .len5
    cmp al, 0xE9              ; JMP rel32
    je .len5

    ; --- PUSH/POP (1 byte) ---
    cmp al, 0x50
    jl .not_push
    cmp al, 0x5F
    jle .len1
.not_push:

    ; --- INC/DEC r32 (1 byte, legacy encoding) ---
    cmp al, 0x40
    jl .not_incdec
    cmp al, 0x4F
    jle .len1                ; (but these are REX in 64-bit... already handled)
.not_incdec:

    ; --- MOV r8, imm8 (2 bytes) ---
    cmp al, 0xB0
    jl .not_mov8
    cmp al, 0xB7
    jle .len2
.not_mov8:

    ; --- Two-byte opcode escape (0x0F) ---
    cmp al, 0x0F
    jne .not_twobyte
    movzx ecx, byte [rdi + 1]
    ; 0F 80-8F: Jcc rel32 (6 bytes total)
    cmp cl, 0x80
    jl .twobyte_other
    cmp cl, 0x8F
    jle .len6
.twobyte_other:
    ; Most 0F xx instructions are 3 bytes (0F xx modrm)
    jmp .len3
.not_twobyte:

    ; --- FF group (INC/DEC/CALL/JMP r/m) ---
    cmp al, 0xFF
    jne .not_ff
    ; Need to check ModR/M for addressing mode
    movzx ecx, byte [rdi + 1]
    ; Simple case: ModR/M with register operand (mod=11)
    mov edx, ecx
    shr edx, 6
    cmp dl, 3                 ; mod=11 → register direct
    je .len2_modrm
    ; Memory operand — complex, assume 6 bytes (common case with disp32)
    pop rcx                   ; prefix len
    lea eax, [ecx + 6]
    ret
.not_ff:

    ; --- 0x83: arithmetic r/m, imm8 ---
    cmp al, 0x83
    je .len3                  ; opcode + modrm + imm8

    ; --- 0x81: arithmetic r/m, imm32 ---
    cmp al, 0x81
    je .len6                  ; opcode + modrm + imm32

    ; --- Default: assume 3 bytes (safe-ish) ---
    jmp .len3

.len1:
    pop rcx
    lea eax, [ecx + 1]
    ret
.len2:
.len2_modrm:
    pop rcx
    lea eax, [ecx + 2]
    ret
.len3:
    pop rcx
    lea eax, [ecx + 3]
    ret
.len5:
    pop rcx
    lea eax, [ecx + 5]
    ret
.len6:
    pop rcx
    lea eax, [ecx + 6]
    ret

;; ============================================================
;; decode_region_instructions(header_ptr, callback)
;; rdi=region header, rsi=callback(instr_ptr, instr_len)
;; Walks instructions in a region, calling callback for each
;; ============================================================
global decode_region_instructions
decode_region_instructions:
    push rbx
    push r12
    push r13
    push r14

    mov r12, rdi              ; header ptr
    mov r13, rsi              ; callback

    ; Get code start and length
    movzx r14d, word [r12 + RHDR_CODE_LEN]
    lea rbx, [r12 + RHDR_SIZE]  ; code start

    xor ecx, ecx             ; offset from code start
.walk:
    cmp ecx, r14d
    jge .walk_done
    push rcx

    ; Decode instruction at current position
    lea rdi, [rbx + rcx]
    call decode_instruction_length
    ; eax = instruction length

    ; Call callback(instr_ptr, instr_len)
    pop rcx
    push rcx
    push rax
    lea rdi, [rbx + rcx]      ; instruction ptr
    mov esi, eax              ; length
    call r13

    pop rax
    pop rcx
    add ecx, eax              ; advance by instruction length
    jmp .walk

.walk_done:
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; count_region_instructions(header_ptr) → eax
;; rdi=region header
;; Returns number of instructions in the region
;; ============================================================
global count_region_instructions
count_region_instructions:
    push rbx
    push r12

    movzx r12d, word [rdi + RHDR_CODE_LEN]
    lea rbx, [rdi + RHDR_SIZE]

    xor ecx, ecx             ; offset
    xor edx, edx             ; count
.count:
    cmp ecx, r12d
    jge .count_done
    push rcx
    push rdx
    lea rdi, [rbx + rcx]
    call decode_instruction_length
    pop rdx
    pop rcx
    add ecx, eax
    inc edx
    jmp .count

.count_done:
    mov eax, edx
    pop r12
    pop rbx
    ret

;; ============================================================
;; decode_instruction_full(instr_ptr, out_decoded)
;; rdi = pointer to instruction bytes
;; rsi = pointer to DecodedInstruction structure (DI_SIZE bytes)
;; Returns: eax = instruction length (also stored in DI_LENGTH)
;;
;; Fills the DecodedInstruction structure with:
;;   - Length, opcode class, registers, immediate, etc.
;; Used by the Logic Probe for abstract interpretation.
;; ============================================================
global decode_instruction_full
decode_instruction_full:
    push rbx
    push r12
    push r13
    push r14
    push r15

    mov r12, rdi              ; instruction pointer
    mov r13, rsi              ; output structure

    ; Zero the output structure
    xor eax, eax
    mov ecx, DI_SIZE / 8
    mov rdi, r13
.zero_loop:
    mov qword [rdi], rax
    add rdi, 8
    dec ecx
    jnz .zero_loop

    ; Default values
    mov byte [r13 + DI_DST_REG], 0xFF   ; no destination
    mov byte [r13 + DI_SRC_REG], 0xFF   ; no source
    mov byte [r13 + DI_OP_CLASS], OP_UNKNOWN

    ; Read first byte
    movzx eax, byte [r12]
    mov r14d, eax             ; save opcode
    xor r15d, r15d            ; prefix length

    ; Check for REX prefix (0x40-0x4F)
    cmp al, 0x40
    jl .no_rex
    cmp al, 0x4F
    jg .no_rex
    ; REX prefix present
    or byte [r13 + DI_FLAGS], DIF_IS_REX
    mov r15d, 1               ; prefix = 1 byte
    movzx eax, byte [r12 + 1]
    mov r14d, eax             ; actual opcode
    ; Check REX.W for 64-bit
    movzx ecx, byte [r12]
    test cl, 0x08
    jz .no_rex
    or byte [r13 + DI_FLAGS], DIF_IS_64BIT
.no_rex:

    ; === Classify the opcode ===
    mov eax, r14d

    ; --- NOP (0x90) ---
    cmp al, 0x90
    jne .not_nop
    mov byte [r13 + DI_OP_CLASS], OP_NOP
    mov byte [r13 + DI_LENGTH], 1
    jmp .add_prefix

.not_nop:
    ; --- RET (0xC3) ---
    cmp al, 0xC3
    jne .not_ret
    mov byte [r13 + DI_OP_CLASS], OP_FLOW_RET
    mov byte [r13 + DI_LENGTH], 1
    jmp .add_prefix

.not_ret:
    ; --- INT3 (0xCC) ---
    cmp al, 0xCC
    jne .not_int3
    mov byte [r13 + DI_OP_CLASS], OP_INTERRUPT
    mov byte [r13 + DI_LENGTH], 1
    jmp .add_prefix

.not_int3:
    ; --- HLT (0xF4) ---
    cmp al, 0xF4
    jne .not_hlt
    mov byte [r13 + DI_OP_CLASS], OP_PRIVILEGED
    mov byte [r13 + DI_LENGTH], 1
    jmp .add_prefix

.not_hlt:
    ; --- SYSCALL (0x0F 0x05) ---
    cmp al, 0x0F
    jne .not_syscall
    cmp byte [r12 + r15 + 1], 0x05
    jne .not_syscall
    mov byte [r13 + DI_OP_CLASS], OP_SYSCALL
    mov byte [r13 + DI_LENGTH], 2
    jmp .add_prefix

.not_syscall:
    ; --- PUSH reg (0x50-0x57) ---
    cmp al, 0x50
    jl .not_push_reg
    cmp al, 0x57
    jg .not_push_reg
    mov byte [r13 + DI_OP_CLASS], OP_STACK_PUSH
    mov byte [r13 + DI_LENGTH], 1
    ; Extract register (al - 0x50)
    sub al, 0x50
    mov [r13 + DI_SRC_REG], al
    jmp .add_prefix

.not_push_reg:
    ; --- POP reg (0x58-0x5F) ---
    cmp al, 0x58
    jl .not_pop_reg
    cmp al, 0x5F
    jg .not_pop_reg
    mov byte [r13 + DI_OP_CLASS], OP_STACK_POP
    mov byte [r13 + DI_LENGTH], 1
    ; Extract register (al - 0x58)
    sub al, 0x58
    mov [r13 + DI_DST_REG], al
    jmp .add_prefix

.not_pop_reg:
    ; --- JMP rel8 (0xEB) ---
    cmp al, 0xEB
    jne .not_jmp_rel8
    mov byte [r13 + DI_OP_CLASS], OP_FLOW_JUMP
    mov byte [r13 + DI_LENGTH], 2
    or byte [r13 + DI_FLAGS], DIF_HAS_IMM
    ; Compute target: current + 2 + rel8
    movsx ecx, byte [r12 + r15 + 1]
    add ecx, 2
    add ecx, r15d
    mov [r13 + DI_TARGET], ecx
    movsxd rax, ecx
    mov [r13 + DI_IMM64], rax
    jmp .add_prefix

.not_jmp_rel8:
    ; --- Jcc rel8 (0x70-0x7F) ---
    cmp al, 0x70
    jl .not_jcc_rel8
    cmp al, 0x7F
    jg .not_jcc_rel8
    mov byte [r13 + DI_OP_CLASS], OP_FLOW_JCC
    mov byte [r13 + DI_LENGTH], 2
    or byte [r13 + DI_FLAGS], DIF_HAS_IMM
    movsx ecx, byte [r12 + r15 + 1]
    add ecx, 2
    add ecx, r15d
    mov [r13 + DI_TARGET], ecx
    jmp .add_prefix

.not_jcc_rel8:
    ; --- JMP rel32 (0xE9) ---
    cmp al, 0xE9
    jne .not_jmp_rel32
    mov byte [r13 + DI_OP_CLASS], OP_FLOW_JUMP
    mov byte [r13 + DI_LENGTH], 5
    or byte [r13 + DI_FLAGS], DIF_HAS_IMM
    mov ecx, [r12 + r15 + 1]
    add ecx, 5
    add ecx, r15d
    mov [r13 + DI_TARGET], ecx
    mov [r13 + DI_IMM64], rcx
    jmp .add_prefix

.not_jmp_rel32:
    ; --- CALL rel32 (0xE8) ---
    cmp al, 0xE8
    jne .not_call_rel32
    mov byte [r13 + DI_OP_CLASS], OP_FLOW_CALL
    mov byte [r13 + DI_LENGTH], 5
    or byte [r13 + DI_FLAGS], DIF_HAS_IMM
    mov ecx, [r12 + r15 + 1]
    add ecx, 5
    add ecx, r15d
    mov [r13 + DI_TARGET], ecx
    mov [r13 + DI_IMM64], rcx
    jmp .add_prefix

.not_call_rel32:
    ; --- MOV reg, imm32 (0xB8-0xBF) ---
    cmp al, 0xB8
    jl .not_mov_imm32
    cmp al, 0xBF
    jg .not_mov_imm32
    mov byte [r13 + DI_OP_CLASS], OP_WRITE_REG
    mov byte [r13 + DI_LENGTH], 5
    or byte [r13 + DI_FLAGS], DIF_HAS_IMM
    sub al, 0xB8
    mov [r13 + DI_DST_REG], al
    mov ecx, [r12 + r15 + 1]
    mov [r13 + DI_IMM64], rcx
    jmp .add_prefix

.not_mov_imm32:
    ; --- CMP EAX, imm32 (0x3D) ---
    cmp al, 0x3D
    jne .not_cmp_eax
    mov byte [r13 + DI_OP_CLASS], OP_ARITH
    mov byte [r13 + DI_LENGTH], 5
    or byte [r13 + DI_FLAGS], DIF_HAS_IMM | DIF_WRITES_FLAGS
    mov byte [r13 + DI_DST_REG], REG_RAX
    mov ecx, [r12 + r15 + 1]
    mov [r13 + DI_IMM64], rcx
    jmp .add_prefix

.not_cmp_eax:
    ; --- XOR r/m, r (0x31) or r, r/m (0x33) ---
    cmp al, 0x31
    je .arith_modrm
    cmp al, 0x33
    je .arith_modrm
    ; --- ADD, SUB, AND, OR, CMP r/m, r ---
    cmp al, 0x01
    je .arith_modrm
    cmp al, 0x29
    je .arith_modrm
    cmp al, 0x21
    je .arith_modrm
    cmp al, 0x09
    je .arith_modrm
    cmp al, 0x39
    je .arith_modrm
    jmp .not_arith_modrm

.arith_modrm:
    mov byte [r13 + DI_OP_CLASS], OP_ARITH
    mov byte [r13 + DI_LENGTH], 2
    or byte [r13 + DI_FLAGS], DIF_HAS_MODRM | DIF_WRITES_FLAGS
    ; Extract ModR/M
    movzx ecx, byte [r12 + r15 + 1]
    mov [r13 + DI_MODRM], cl
    ; Extract registers from ModR/M
    mov eax, ecx
    shr eax, 3
    and eax, 7
    mov [r13 + DI_SRC_REG], al    ; reg field
    mov eax, ecx
    and eax, 7
    mov [r13 + DI_DST_REG], al    ; r/m field (if mod=11)
    jmp .add_prefix

.not_arith_modrm:
    ; --- MOV r/m, r (0x89) or r, r/m (0x8B) ---
    cmp al, 0x89
    je .mov_modrm
    cmp al, 0x8B
    je .mov_modrm
    jmp .not_mov_modrm

.mov_modrm:
    mov byte [r13 + DI_LENGTH], 2
    or byte [r13 + DI_FLAGS], DIF_HAS_MODRM
    movzx ecx, byte [r12 + r15 + 1]
    mov [r13 + DI_MODRM], cl
    ; Determine if write to reg or mem
    mov edx, ecx
    shr edx, 6
    cmp dl, 3               ; mod=11 means register
    je .mov_reg_reg
    ; Memory operand
    cmp r14d, 0x89
    je .mov_to_mem
    mov byte [r13 + DI_OP_CLASS], OP_READ_MEM
    jmp .mov_extract_regs
.mov_to_mem:
    mov byte [r13 + DI_OP_CLASS], OP_WRITE_MEM
    jmp .mov_extract_regs
.mov_reg_reg:
    mov byte [r13 + DI_OP_CLASS], OP_WRITE_REG
.mov_extract_regs:
    mov eax, ecx
    shr eax, 3
    and eax, 7
    mov [r13 + DI_SRC_REG], al
    mov eax, ecx
    and eax, 7
    mov [r13 + DI_DST_REG], al
    jmp .add_prefix

.not_mov_modrm:
    ; --- SUB RSP, imm8 (0x48 0x83 0xEC imm8) ---
    cmp al, 0x83
    jne .not_sub_rsp
    ; Check if r15 > 0 (REX present) and next is EC (sub rsp)
    cmp r15d, 1
    jl .not_sub_rsp
    movzx ecx, byte [r12 + r15 + 1]
    cmp cl, 0xEC
    jne .check_add_rsp
    mov byte [r13 + DI_OP_CLASS], OP_STACK_ADJ
    mov byte [r13 + DI_LENGTH], 3
    or byte [r13 + DI_FLAGS], DIF_HAS_IMM
    movzx eax, byte [r12 + r15 + 2]
    neg eax                   ; negative for sub
    movsxd rax, eax
    mov [r13 + DI_IMM64], rax
    jmp .add_prefix

.check_add_rsp:
    ; --- ADD RSP, imm8 (0x48 0x83 0xC4 imm8) ---
    cmp cl, 0xC4
    jne .not_sub_rsp
    mov byte [r13 + DI_OP_CLASS], OP_STACK_ADJ
    mov byte [r13 + DI_LENGTH], 3
    or byte [r13 + DI_FLAGS], DIF_HAS_IMM
    movzx eax, byte [r12 + r15 + 2]
    movsxd rax, eax
    mov [r13 + DI_IMM64], rax   ; positive for add
    jmp .add_prefix

.not_sub_rsp:
    ; --- 0x0F xx: Two-byte opcodes ---
    cmp r14d, 0x0F
    jne .not_twobyte
    movzx ecx, byte [r12 + r15 + 1]
    ; 0F 80-8F: Jcc rel32
    cmp cl, 0x80
    jl .twobyte_other
    cmp cl, 0x8F
    jg .twobyte_other
    mov byte [r13 + DI_OP_CLASS], OP_FLOW_JCC
    mov byte [r13 + DI_LENGTH], 6
    or byte [r13 + DI_FLAGS], DIF_HAS_IMM
    mov edx, [r12 + r15 + 2]
    add edx, 6
    add edx, r15d
    mov [r13 + DI_TARGET], edx
    jmp .add_prefix

.twobyte_other:
    mov byte [r13 + DI_LENGTH], 3
    jmp .add_prefix

.not_twobyte:
    ; Default: unknown, assume 1 byte (conservative)
    mov byte [r13 + DI_OP_CLASS], OP_UNKNOWN
    mov byte [r13 + DI_LENGTH], 1

.add_prefix:
    ; Add prefix length to total length
    movzx eax, byte [r13 + DI_LENGTH]
    add eax, r15d
    mov [r13 + DI_LENGTH], al

    ; Return total length
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; classify_opcode(opcode_byte) → eax (OP_* class)
;; Quick opcode classification without full decode.
;; rdi = opcode byte
;; ============================================================
global classify_opcode
classify_opcode:
    movzx eax, dil

    ; NOP
    cmp al, 0x90
    jne .not_nop
    mov eax, OP_NOP
    ret
.not_nop:
    ; RET
    cmp al, 0xC3
    jne .not_ret
    mov eax, OP_FLOW_RET
    ret
.not_ret:
    ; PUSH 0x50-0x57
    cmp al, 0x50
    jl .not_push
    cmp al, 0x57
    jle .is_push
    jmp .not_push
.is_push:
    mov eax, OP_STACK_PUSH
    ret
.not_push:
    ; POP 0x58-0x5F
    cmp al, 0x58
    jl .not_pop
    cmp al, 0x5F
    jle .is_pop
    jmp .not_pop
.is_pop:
    mov eax, OP_STACK_POP
    ret
.not_pop:
    ; CALL 0xE8
    cmp al, 0xE8
    jne .not_call
    mov eax, OP_FLOW_CALL
    ret
.not_call:
    ; JMP 0xE9, 0xEB
    cmp al, 0xE9
    je .is_jmp
    cmp al, 0xEB
    je .is_jmp
    jmp .not_jmp
.is_jmp:
    mov eax, OP_FLOW_JUMP
    ret
.not_jmp:
    ; Jcc 0x70-0x7F
    cmp al, 0x70
    jl .not_jcc
    cmp al, 0x7F
    jle .is_jcc
    jmp .not_jcc
.is_jcc:
    mov eax, OP_FLOW_JCC
    ret
.not_jcc:
    ; INT3 0xCC
    cmp al, 0xCC
    jne .not_int
    mov eax, OP_INTERRUPT
    ret
.not_int:
    ; Default
    mov eax, OP_UNKNOWN
    ret
; dispatch.asm — Token processing, prediction, self-model queries
;
; @entry process_input(buf, len)           → tokenize and process text
; @entry process_token(token_id)           → predict/learn cycle
; @entry dispatch_predict(ctx_hash)        → eax=token, xmm0=confidence
;
; FLOW: token → ctx=hash(prev) → predict → HIT/MISS → learn on miss
;
; SELF-MODEL INTEGRATION:
;   - dispatch_predict queries ST_SELF_MODEL_VEC for confidence boost
;   - On MISS with ST_IS_SELF_REF: corrects self-model
;   - SURPRISE_SELF vs SURPRISE_OUTCOME → different pressure paths
;
; GOTCHAS (CRITICAL):
;   !! ctx = hash(prev_token) ONLY - no somatic XOR
;   !! rcx is caller-saved - use r10-r15 in loops
;   !! Token abstraction must match io.asm:digest_file
;   !! struct_ctx uses f64 (holo_*), not f32 (vsa_*)
;
; @calledby repl.asm, io.asm, dreams.asm
;
%include "syscalls.inc"
%include "constants.inc"

section .data
    token_msg:      db "  token=0x", 0
    predict_msg:    db "  predict=0x", 0
    hit_msg:        db " [HIT]", 10, 0
    miss_msg:       db " [MISS]", 10, 0
    no_predict_msg: db " [NEW]", 10, 0
    process_hdr:    db "Processing: ", 0
    dbg_credit_msg: db "[CREDIT]", 10, 0
    dbg_nocredit_msg: db "[NO_CREDIT]", 10, 0
    dbg_search_msg: db "[SEARCH] ctx=0x", 0
    dbg_tok_msg:    db " tok=0x", 0
    dbg_region_msg: db "[REGION] ", 0

    ; f64 constants for graph dynamics
    align 8
    prime_decay:    dq 0.9
    activ_decay:    dq 0.85
    one_point_o:    dq 1.0
    zero_point_o:   dq 0.0
    half_point_o:   dq 0.5
    activ_thresh:   dq 0.1

    ; Holographic threshold (f64) - confidence required to use holographic prediction
    ; VSA element-wise binding produces ~0.7-0.8 confidence for exact matches
    ; Lowered to 0.3 to test resonance accumulation
    align 8
    holo_thresh:    dq 0.3

    ; Resonant dispatch threshold (f64) - similarity required for fuzzy match
    ; 0.7 = strong similarity required (can adjust based on noise tolerance)
    align 8
    resonant_thresh: dq 0.7

section .bss
    word_buf:       resb MAX_WORD_LEN

section .text

extern print_cstr
extern print_str
extern print_hex32
extern print_hex64
extern print_u64
extern print_newline
extern learn_pattern
extern fire_hook
extern vsa_get_token_vec
extern vsa_superpose
extern holo_superpose_f64
extern holo_normalize_f64
extern holo_gen_vec
extern holo_bind_f64
extern holo_cosim_f64
extern holo_unbind_f64
extern vsa_bind
extern vsa_unbind
extern vsa_gen_role_pos
extern vsa_normalize
extern vsa_dot
extern vsa_cosim
extern region_alloc
extern find_existing_pattern
extern learn_connections
extern observe_cycle
extern tick_regulators
extern accrue_pressure
extern holo_predict
extern holo_query_valence
extern holo_decay_all
extern update_organic_pressure
extern maturity_update
extern update_anticipatory
extern decay_anticipatory
extern update_oscillation
extern update_presence_dispatch
extern introspect_scan_regions
extern journey_step
extern confidence_update
extern confidence_query
extern confidence_get_feeling
extern confidence_decay_all
extern resonant_match
extern resonant_get_threshold
extern resonant_extract_token
extern emit_receipt_simple
extern emit_receipt_full
extern receipt_resonate

;; ============================================================
;; dispatch_init
;; Create the initial (empty) dispatch region
;; ============================================================
global dispatch_init
dispatch_init:
    push rbx

    ; Allocate a dispatch region with just a "return 0" stub
    ; Code: xor eax, eax; ret = 31 C0 C3 (3 bytes)
    mov rdi, 3                ; code size
    mov rsi, RTYPE_DISPATCH   ; type
    xor edx, edx             ; birth step = 0
    call region_alloc
    ; rax = header ptr, code at rax+16

    ; Write: xor eax, eax; ret
    mov byte [rax + RHDR_SIZE + 0], 0x31  ; xor
    mov byte [rax + RHDR_SIZE + 1], 0xC0  ; eax, eax
    mov byte [rax + RHDR_SIZE + 2], 0xC3  ; ret

    ; Store as the dispatch entry point
    mov rbx, SURFACE_BASE
    lea rcx, [rbx + STATE_OFFSET + ST_DISPATCH_PTR]
    ; The dispatch_ptr is the allocator; we need a separate dispatch_entry
    ; Store the entry point in a known location (beginning of dispatch region)
    ; Actually the first region IS the dispatch entry
    ; We'll call it by looking up region 0

    pop rbx
    ret

;; ============================================================
;; process_input(text_ptr, text_len)
;; rdi=text, rsi=len
;; Tokenizes text into words, processes each token through dispatch
;; ============================================================
global process_input
process_input:
    push rbx
    push r12
    push r13
    push r14
    push r15

    mov r12, rdi              ; text ptr
    mov r13, rsi              ; text len
    xor r14d, r14d            ; current position
    mov r15, SURFACE_BASE

    ; Reset context hash for this line — makes context line-local
    ; so patterns are recognized by local structure, not absolute position
    mov qword [r15 + STATE_OFFSET + ST_CTX_HASH], 0
    mov qword [r15 + STATE_OFFSET + ST_LAST_CTX], 0

    ; Print header
    push r12
    push r13
    lea rdi, [rel process_hdr]
    call print_cstr
    mov rdi, r12
    mov rsi, r13
    call print_str
    call print_newline
    pop r13
    pop r12

    ; Fire pre-step hook
    mov edi, HOOK_PRE_STEP
    xor esi, esi
    call fire_hook

.next_word:
    ; Skip whitespace
    cmp r14, r13
    jge .done
    movzx eax, byte [r12 + r14]
    cmp al, ' '
    je .skip_ws
    cmp al, 9                 ; tab
    je .skip_ws
    cmp al, 10                ; newline
    je .skip_ws
    cmp al, 13                ; CR
    je .skip_ws
    jmp .word_start

.skip_ws:
    inc r14
    jmp .next_word

.word_start:
    ; Collect word into word_buf
    lea rbx, [rel word_buf]
    xor ecx, ecx             ; word length

.collect:
    cmp r14, r13
    jge .word_done
    movzx eax, byte [r12 + r14]
    cmp al, ' '
    je .word_done
    cmp al, 9
    je .word_done
    cmp al, 10
    je .word_done
    cmp al, 13
    je .word_done
    cmp ecx, MAX_WORD_LEN - 1
    jge .word_done

    ; Store (uppercase)
    cmp al, 'a'
    jl .no_upper
    cmp al, 'z'
    jg .no_upper
    sub al, 32
.no_upper:
    mov [rbx + rcx], al
    inc ecx
    inc r14
    jmp .collect

.word_done:
    test ecx, ecx
    jz .next_word             ; empty word, skip

    ; --- Categorical abstraction ---
    ; Check if word contains hex literal (0X...) → abstract to class token
    ; This is chunking: "0x0000000100010110" and "0xDEADBEEF" are both "HEX"
    push rcx                  ; save word_len
    cmp ecx, 3
    jl .not_hex
    xor edx, edx
.hex_scan:
    cmp edx, ecx
    jge .not_hex
    cmp byte [rbx + rdx], '0'
    jne .hex_scan_next
    cmp edx, ecx
    jge .not_hex
    lea eax, [edx + 1]
    cmp eax, ecx
    jge .hex_scan_next
    cmp byte [rbx + rax], 'X'
    je .is_hex
.hex_scan_next:
    inc edx
    jmp .hex_scan
.is_hex:
    pop rcx
    mov eax, 0x48455821       ; TOKEN_HEX class ("HEX!" as u32)
    jmp .token_ready

.not_hex:
    ; Check if word is all digits → abstract to class token
    ; (zero-length already rejected at .word_done, so ecx >= 1 here)
    pop rcx
    xor edx, edx
.num_scan:
    cmp edx, ecx
    jge .is_num
    movzx eax, byte [rbx + rdx]
    cmp al, '0'
    jl .no_abstract
    cmp al, '9'
    jg .no_abstract
    inc edx
    jmp .num_scan
.is_num:
    mov eax, 0x4e554d21       ; TOKEN_NUM class ("NUM!" as u32)
    jmp .token_ready

.no_abstract:
    ; Normal tokenization — hash the word
    mov rdi, rbx              ; word_buf
    mov esi, ecx              ; word_len
    call tokenize_word        ; → eax = token_id

.token_ready:
    ; Process this token through the dispatch system
    mov edi, eax
    call process_token

    jmp .next_word

.done:
    ; Holographic decay (interference traces)
    call holo_decay_all

    ; Topological metacognition: decay confidence vector toward neutral
    ; Prevents runaway confidence/anxiety over time
    call confidence_decay_all

    ; Decay dynamics once per line (not per token)
    call decay_all_regions

    ; --- Temporal rhythm: update felt tempo from presence ---
    ; tempo = 1.0 + arousal*0.5 - fatigue*0.25, clamped to [0.5, 2.0]
    lea rdi, [r15 + STATE_OFFSET + ST_PRESENCE]
    movss xmm0, [rdi + PRES_AROUSAL * 4]
    cvtss2sd xmm0, xmm0
    mov rax, TEMPO_AROUSAL_SCALE
    movq xmm1, rax
    mulsd xmm0, xmm1             ; arousal * 0.5
    movss xmm2, [rdi + PRES_FATIGUE * 4]
    cvtss2sd xmm2, xmm2
    mov rax, TEMPO_FATIGUE_SCALE
    movq xmm3, rax
    mulsd xmm2, xmm3             ; fatigue * 0.25
    mov rax, 0x3FF0000000000000   ; 1.0
    movq xmm1, rax
    addsd xmm0, xmm1             ; 1.0 + arousal*0.5
    subsd xmm0, xmm2             ; - fatigue*0.25
    ; Clamp [0.5, 2.0]
    mov rax, TEMPO_MIN
    movq xmm1, rax
    maxsd xmm0, xmm1
    mov rax, TEMPO_MAX
    movq xmm1, rax
    minsd xmm0, xmm1
    movsd [r15 + STATE_OFFSET + ST_TEMPO_MULT], xmm0

    ; --- Organic per-line updates ---
    ; Decay anticipatory signals (distant things fade if not reinforced)
    call decay_anticipatory

    ; Track oscillation (flat = dead, oscillating = alive)
    call update_oscillation

    ; Let presence field influence dispatch mode (felt experience → behavior)
    call update_presence_dispatch

    ; Fire post-step hook
    mov edi, HOOK_POST_STEP
    xor esi, esi
    call fire_hook

    ; Increment global step
    lea rax, [r15 + STATE_OFFSET + ST_GLOBAL_STEP]
    inc qword [rax]

    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; tokenize_word(buf, len) → eax (token_id)
;; rdi=buf, esi=len
;; FNV-1a hash, uppercase already applied
;; ============================================================
global tokenize_word
tokenize_word:
    mov ecx, FNV32_INIT
    xor edx, edx             ; index

.hash_loop:
    cmp edx, esi
    jge .hash_done
    movzx eax, byte [rdi + rdx]
    xor ecx, eax
    imul ecx, FNV32_PRIME
    inc edx
    jmp .hash_loop

.hash_done:
    mov eax, ecx              ; return hash as token ID
    ret

;; ============================================================
;; process_token(token_id)
;; edi=token_id
;; Updates context, runs dispatch, handles hit/miss, triggers learning
;; ============================================================
global process_token
process_token:
    push rbx
    push r12
    push r13
    push r14

    mov r12d, edi             ; save token_id
    mov rbx, SURFACE_BASE

    ; Store current token for journey tracing
    mov [rbx + STATE_OFFSET + ST_CURRENT_TOKEN], r12d

    ; Check if we should start tracing this token (0xFFFFFFFF = trace next)
    cmp dword [rbx + STATE_OFFSET + ST_JOURNEY_TOKEN], 0xFFFFFFFF
    jne .no_start_journey
    ; Start tracing this token
    mov [rbx + STATE_OFFSET + ST_JOURNEY_TOKEN], r12d
    mov dword [rbx + STATE_OFFSET + ST_JOURNEY_POS], 0
.no_start_journey:

    ; JOURNEY: record this token passing through process_token
    mov edi, TRACE_PROCESS_TOKEN
    call journey_step

    ; --- Novelty tracking: bloom filter for unique token detection ---
    ; Hash token to 3 bloom positions, check if ALL set (seen before)
    mov eax, r12d
    mov edx, eax
    shr edx, 5                ; edx = token >> 5 = word index
    and edx, 63              ; edx mod 64 = word in 256-byte bloom
    mov ecx, eax
    and ecx, 31              ; bit position within word
    lea rsi, [rbx + STATE_OFFSET + ST_TOKEN_BLOOM]
    bt dword [rsi + rdx*4], ecx
    jc .token_seen
    ; NEW token — set bloom bit and increment novelty
    bts dword [rsi + rdx*4], ecx
    inc dword [rbx + STATE_OFFSET + ST_UNIQUE_TOKENS]
    inc dword [rbx + STATE_OFFSET + ST_NOVELTY_RECENT]
.token_seen:

    ; --- Context hash = predecessor only ---
    ; Pattern identity is independent of mood. A bike is a bike whether happy or angry.
    ; Mood affects BEHAVIOR (what to do with patterns), not IDENTITY (what patterns are).
    lea rsi, [rbx + STATE_OFFSET + ST_TOKEN_BUF]
    mov ecx, [rbx + STATE_OFFSET + ST_TOKEN_POS]
    mov r9, 0x9E3779B97F4A7C15  ; golden ratio prime

    ; Get previous token (position - 1)
    dec ecx
    and ecx, (ST_TOKEN_BUF_CAP - 1)
    mov r10d, [rsi + rcx * 4]  ; previous token

    ; Context = prev_token * prime (pure sequential context)
    mov rax, r10
    imul rax, r9
    mov r13, rax
    mov [rbx + STATE_OFFSET + ST_CTX_HASH], r13

    ; --- Update token ring buffer ---
    lea rax, [rbx + STATE_OFFSET + ST_TOKEN_POS]
    mov ecx, [rax]
    lea rdx, [rbx + STATE_OFFSET + ST_TOKEN_BUF]
    mov [rdx + rcx * 4], r12d
    inc ecx
    and ecx, (ST_TOKEN_BUF_CAP - 1)
    mov [rax], ecx

    ; Increment token count
    inc dword [rbx + STATE_OFFSET + ST_TOKEN_COUNT]

    ; --- Working memory: semantic slots (noun/verb/modifier) ---
    ; Classify token by low 2 bits: 0=noun, 1=verb, 2=modifier, 3=other
    ; This creates implicit binding structure from token statistics
    mov eax, r12d
    and eax, 0x3
    cmp eax, 0
    jne .slot_check_verb
    ; Noun slot
    mov [rbx + STATE_OFFSET + ST_CTX_SLOT_NOUN], r12d
    mov byte [rbx + STATE_OFFSET + ST_SLOT_RECENCY], 0      ; noun recency = 0
    jmp .slot_done
.slot_check_verb:
    cmp eax, 1
    jne .slot_check_mod
    ; Verb slot
    mov [rbx + STATE_OFFSET + ST_CTX_SLOT_VERB], r12d
    mov byte [rbx + STATE_OFFSET + ST_SLOT_RECENCY + 1], 0  ; verb recency = 0
    jmp .slot_done
.slot_check_mod:
    cmp eax, 2
    jne .slot_done
    ; Modifier slot
    mov [rbx + STATE_OFFSET + ST_CTX_SLOT_MOD], r12d
    mov byte [rbx + STATE_OFFSET + ST_SLOT_RECENCY + 2], 0  ; mod recency = 0
.slot_done:
    ; Age all recencies (saturate at 255)
    lea rax, [rbx + STATE_OFFSET + ST_SLOT_RECENCY]
    movzx ecx, byte [rax]
    cmp ecx, 255
    jge .slot_age1_done
    inc byte [rax]
.slot_age1_done:
    movzx ecx, byte [rax + 1]
    cmp ecx, 255
    jge .slot_age2_done
    inc byte [rax + 1]
.slot_age2_done:
    movzx ecx, byte [rax + 2]
    cmp ecx, 255
    jge .slot_age3_done
    inc byte [rax + 2]
.slot_age3_done:

    ; --- Phase 2: Compute structural context (dual-track) ---
    ; struct_ctx = Σ bind(ROLE_POS_i, token_vec[history[i]])
    ; This runs in parallel with the flat context hash
    push r12
    push r13
    call compute_struct_ctx
    pop r13
    pop r12

    ; --- Check last prediction ---
    lea rax, [rbx + STATE_OFFSET + ST_LAST_PREDICT]
    mov r14d, [rax]           ; last predicted token

    test r14d, r14d
    jz .no_prediction         ; no prediction was made

    ; Compare prediction with actual
    cmp r14d, r12d
    je .hit
    jmp .miss

.hit:
    ; Clear surprise type (no surprise on hit)
    lea rax, [rbx + STATE_OFFSET + ST_SURPRISE_TYPE]
    mov dword [rax], SURPRISE_NONE

    ; --- Metabolic income: hits generate energy (correct predictions are valuable) ---
    mov rax, ENERGY_HIT_INCOME
    movq xmm5, rax
    movsd xmm6, [rbx + STATE_OFFSET + ST_ENERGY]
    addsd xmm6, xmm5
    mov rax, ENERGY_MAX
    movq xmm5, rax
    minsd xmm6, xmm5            ; cap at max
    movsd [rbx + STATE_OFFSET + ST_ENERGY], xmm6
    ; Track income
    mov rax, ENERGY_HIT_INCOME
    movq xmm5, rax
    addsd xmm5, [rbx + STATE_OFFSET + ST_ENERGY_INCOME]
    movsd [rbx + STATE_OFFSET + ST_ENERGY_INCOME], xmm5

    ; --- Self-knowledge: track context-type accuracy ---
    ; Extract ctx_type from hash (top 4 bits → 16 types)
    mov rax, [rbx + STATE_OFFSET + ST_CTX_HASH]
    shr rax, 60               ; top 4 bits → 0-15
    and eax, 0xF              ; mask to 4 bits
    ; Increment both hits and total for this context type
    lea rcx, [rbx + STATE_OFFSET + ST_CTX_TYPE_HITS]
    inc dword [rcx + rax * 4]       ; hits[ctx_type]++
    lea rcx, [rbx + STATE_OFFSET + ST_CTX_TYPE_TOTAL]
    inc dword [rcx + rax * 4]       ; total[ctx_type]++

    ; --- Topological metacognition: update confidence vector on HIT ---
    ; The system becomes more confident about this context type
    mov edi, r13d             ; ctx_hash (lower 32 bits from r13)
    mov esi, 1                ; is_hit = true
    call confidence_update

    ; Increment hit counter on the predicting region
    lea rax, [rbx + STATE_OFFSET + ST_PREDICT_REGION]
    mov rcx, [rax]
    test rcx, rcx
    jz .holo_hit              ; holo prediction — still count as hit
    inc dword [rcx + RHDR_HITS]

    ; === EMIT RECEIPT: EVENT_HIT (full context) ===
    push rcx                  ; save region ptr
    mov edi, EVENT_HIT                ; event_type
    mov esi, r13d                     ; ctx_hash
    mov edx, r12d                     ; actual_token (same as predicted for HIT)
    mov ecx, r12d                     ; predicted_token (same as actual)
    ; Hash the region pointer
    mov rax, [rsp]                    ; get region ptr from stack
    shr rax, 4
    mov r8d, eax                      ; region_hash
    mov r9d, [rbx + STATE_OFFSET + ST_RUNNER_UP_TOKEN] ; aux = runner-up
    movss xmm0, [rbx + STATE_OFFSET + ST_EXPECT_CONF]
    movss xmm1, [rbx + STATE_OFFSET + ST_PRESENCE + PRES_VALENCE * 4]
    cvtss2sd xmm1, xmm1
    call emit_receipt_full
    pop rcx

    ; STDP connection learning — strengthen temporal links
    push rcx
    mov rdi, rcx              ; firing region ptr
    call learn_connections
    pop rcx

    ; OCTOPUS: Hits slightly reduce dream pressure (performing well)
    mov edi, RPRES_DREAM
    mov rax, 0xBF847AE147AE147B  ; -0.01 f64 (small decay on success)
    movq xmm0, rax
    call accrue_pressure

    ; Schema coverage: did a generalized pattern match this context?
    ; (flag set during dispatch_predict scan)
    cmp dword [rbx + STATE_OFFSET + ST_EXPECT_IS_SCHEMA], 0
    je .no_schema_check
    ; Schema was available for this context — count as schema hit
    lea rax, [rbx + STATE_OFFSET + ST_SCHEMA_HITS]
    inc dword [rax]
.no_schema_check:
    ; Always count total for schema coverage
    lea rax, [rbx + STATE_OFFSET + ST_SCHEMA_TOTAL]
    inc dword [rax]

    ; Also update region table entry
    push rcx
    mov rdi, rcx
    call update_region_table_hits
    pop rcx

    ; Self-prediction tracking via successor table
    lea rax, [rbx + STATE_OFFSET + ST_SELF_PRED_REGION]
    mov rdx, [rax]
    test rdx, rdx
    jz .skip_self_pred_hit
    cmp rdx, rcx
    jne .self_pred_miss_h
    ; Correct self-prediction
    lea rax, [rbx + STATE_OFFSET + ST_SELF_PRED_HITS]
    inc dword [rax]
    jmp .skip_self_pred_hit
.self_pred_miss_h:
    lea rax, [rbx + STATE_OFFSET + ST_SELF_PRED_MISSES]
    inc dword [rax]
.skip_self_pred_hit:
    ; Find current region's index in the table
    push rcx                   ; save region ptr
    mov rdi, rcx
    call find_region_index     ; → eax = index (or -1)
    pop rcx
    cmp eax, -1
    je .skip_successor
    ; Bounds check: successor table is 256 entries
    cmp eax, 256
    jge .skip_successor

    ; Update successor_tbl[last_fired_idx] = current_idx
    movzx edx, word [rbx + STATE_OFFSET + ST_LAST_FIRED_IDX]
    cmp edx, 256
    jge .succ_update_idx      ; skip write if last_fired out of bounds
    lea rsi, [rbx + STATE_OFFSET + ST_SUCCESSOR_TBL]
    mov [rsi + rdx * 2], ax   ; current idx is successor of last fired

    ; Predict: successor_tbl[current_idx] = next region idx
    movzx edx, word [rsi + rax * 2]
    test dx, dx
    jz .successor_fallback
    cmp edx, REGION_TABLE_MAX
    jge .successor_fallback   ; invalid successor index
    ; Convert successor idx to region ptr
    push rax
    imul rdi, rdx, RTE_SIZE
    lea rsi, [rbx + REGION_TABLE_OFFSET]
    add rdi, rsi
    mov rdx, [rdi + RTE_ADDR]
    mov [rbx + STATE_OFFSET + ST_SELF_PRED_REGION], rdx
    pop rax
    jmp .successor_done
.successor_fallback:
    ; No successor known — predict same region
    mov [rbx + STATE_OFFSET + ST_SELF_PRED_REGION], rcx
.successor_done:
.succ_update_idx:
    ; Update last_fired_idx (bounded to u8 range for table safety)
    and eax, 0xFF
    mov [rbx + STATE_OFFSET + ST_LAST_FIRED_IDX], ax
.skip_successor:

    ; Fire hit hook
    mov edi, HOOK_ON_HIT
    mov esi, r12d
    call fire_hook

.holo_hit:
    ; Print hit feedback (graph or holographic)
    lea rdi, [rel token_msg]
    call print_cstr
    mov edi, r12d
    call print_hex32
    lea rdi, [rel hit_msg]
    call print_cstr
    jmp .after_counter

.miss:
    ; Classify surprise type based on predicting region's confidence
    lea rax, [rbx + STATE_OFFSET + ST_PREDICT_REGION]
    mov rcx, [rax]
    test rcx, rcx
    jz .surprise_outcome       ; no region = expected miss

    ; Compute predicting region's accuracy
    mov eax, [rcx + RHDR_HITS]
    mov edx, [rcx + RHDR_MISSES]
    add edx, eax
    test edx, edx
    jz .surprise_outcome
    cvtsi2ss xmm0, eax
    cvtsi2ss xmm1, edx
    divss xmm0, xmm1          ; accuracy of predicting region
    ; If accuracy > 0.7 → self-model violated (high confidence was wrong)
    mov eax, 0x3F333333        ; 0.7f
    movd xmm1, eax
    comiss xmm0, xmm1
    jbe .surprise_outcome
    ; SURPRISE_SELF: high-confidence region missed — self-model violated
    lea rax, [rbx + STATE_OFFSET + ST_SURPRISE_TYPE]
    mov dword [rax], SURPRISE_SELF

    ; === SELF/OTHER BOUNDARY: This is ME being wrong, not the world being unknown ===
    ; Flag the predicting region for introspective repair
    lea rax, [rbx + STATE_OFFSET + ST_PREDICT_REGION]
    mov rcx, [rax]
    test rcx, rcx
    jz .self_surprise_pressure
    or word [rcx + RHDR_FLAGS], RFLAG_NEEDS_REPAIR  ; mark for self-repair

.self_surprise_pressure:
    ; Boost introspect pressure (self-model needs examination)
    movsd xmm0, [rbx + STATE_OFFSET + ST_INTROSPECT_PRESSURE]
    mov rax, 0x3FD0000000000000    ; 0.25 boost per self-surprise
    movq xmm1, rax
    addsd xmm0, xmm1
    movsd [rbx + STATE_OFFSET + ST_INTROSPECT_PRESSURE], xmm0

    ; === EMIT EVENT_SELF RECEIPT: self-model violation ===
    ; Increment self-surprise counter
    lea rax, [rbx + STATE_OFFSET + ST_SELF_SURPRISE_COUNT]
    inc dword [rax]

    ; Emit receipt for self-model violation
    ; edi=event, esi=ctx, edx=actual, ecx=pred, r8d=region, r9d=aux, xmm0=conf, xmm1=val
    mov edi, EVENT_SELF           ; event type: self-model violation
    mov esi, [rbx + STATE_OFFSET + ST_CTX_HASH]  ; context hash
    mov edx, r12d                 ; actual token
    mov ecx, [rbx + STATE_OFFSET + ST_EXPECT_TOKEN] ; predicted token
    ; Hash the predicting region
    mov rax, [rbx + STATE_OFFSET + ST_PREDICT_REGION]
    shr rax, 4
    mov r8d, eax                  ; region_hash
    ; aux = region accuracy * 1000 (for causal tracking)
    ; Reload predicting region to get accuracy
    mov rax, [rbx + STATE_OFFSET + ST_PREDICT_REGION]
    test rax, rax
    jz .self_emit_no_region
    mov r10d, [rax + RHDR_HITS]
    mov r11d, [rax + RHDR_MISSES]
    add r11d, r10d                ; total = hits + misses
    test r11d, r11d
    jz .self_emit_no_region
    imul r10d, 1000               ; hits * 1000
    xor edx, edx
    mov eax, r10d
    div r11d                      ; accuracy = (hits*1000) / total
    mov r9d, eax
    jmp .self_emit_do
.self_emit_no_region:
    xor r9d, r9d                  ; aux = 0 if no region
.self_emit_do:
    ; Restore edx (actual token) since we clobbered it
    mov edx, r12d
    ; Load confidence and valence
    movss xmm0, [rbx + STATE_OFFSET + ST_EXPECT_CONF]
    movss xmm1, [rbx + STATE_OFFSET + ST_PRESENCE + PRES_VALENCE * 4]
    cvtss2sd xmm1, xmm1
    call emit_receipt_full

    jmp .do_miss_counter

.surprise_outcome:
    ; SURPRISE_OUTCOME: low-confidence miss (expected uncertainty) — the WORLD is unknown
    lea rax, [rbx + STATE_OFFSET + ST_SURPRISE_TYPE]
    mov dword [rax], SURPRISE_OUTCOME
    ; Standard dream pressure handles this (consolidation learns about world)

.do_miss_counter:
    ; --- Self-knowledge: track context-type (miss → total only) ---
    mov rax, [rbx + STATE_OFFSET + ST_CTX_HASH]
    shr rax, 60               ; top 4 bits → 0-15
    and eax, 0xF
    lea rcx, [rbx + STATE_OFFSET + ST_CTX_TYPE_TOTAL]
    inc dword [rcx + rax * 4]       ; total[ctx_type]++ (no hit increment)

    ; --- Topological metacognition: update confidence vector on MISS ---
    ; The system becomes more anxious about this context type
    mov edi, r13d             ; ctx_hash (lower 32 bits from r13)
    xor esi, esi              ; is_hit = false (miss)
    call confidence_update

    ; Increment miss counter on the predicting region
    lea rax, [rbx + STATE_OFFSET + ST_PREDICT_REGION]
    mov rcx, [rax]
    test rcx, rcx
    jz .record_miss
    inc dword [rcx + RHDR_MISSES]

    ; Self-prediction: this region was predicted but missed
    lea rax, [rbx + STATE_OFFSET + ST_SELF_PRED_REGION]
    mov rdx, [rax]
    test rdx, rdx
    jz .skip_self_pred_miss
    ; Any miss means self-prediction was wrong about outcome
    lea rax, [rbx + STATE_OFFSET + ST_SELF_PRED_MISSES]
    inc dword [rax]
.skip_self_pred_miss:
    ; Clear self-prediction (context shifted)
    lea rax, [rbx + STATE_OFFSET + ST_SELF_PRED_REGION]
    mov qword [rax], 0

    push rcx
    mov rdi, rcx
    call update_region_table_misses
    pop rcx

.record_miss:
    ; Record in miss buffer for dream replay
    lea rax, [rbx + STATE_OFFSET + ST_MISS_POS]
    mov ecx, [rax]
    lea rdx, [rbx + STATE_OFFSET + ST_MISS_BUF]
    imul edi, ecx, ST_MISS_ENTRY_SIZE
    add rdi, rdx
    ; Store: ctx_hash (the context BEFORE this token)
    lea rax, [rbx + STATE_OFFSET + ST_LAST_CTX]
    mov rsi, [rax]
    mov [rdi], rsi            ; context hash
    mov [rdi + 8], r12d       ; actual token

    ; --- Hypothesis confidence: how sure were we when wrong? ---
    ; Store prediction confidence at same index as miss buffer entry
    ; This turns misses into testable hypotheses
    lea rdi, [rbx + STATE_OFFSET + ST_HYPOTHESIS_CONF]
    movss xmm0, [rbx + STATE_OFFSET + ST_EXPECT_CONF]
    movss [rdi + rcx * 4], xmm0      ; hypothesis_conf[miss_pos] = expect_conf
    inc dword [rbx + STATE_OFFSET + ST_HYPOTHESIS_COUNT]

    ; Advance miss pos
    lea rax, [rbx + STATE_OFFSET + ST_MISS_POS]
    mov ecx, [rax]
    inc ecx
    cmp ecx, ST_MISS_BUF_CAP
    jl .no_miss_wrap
    xor ecx, ecx
.no_miss_wrap:
    mov [rax], ecx

    ; --- Counterfactual check: would runner-up have been right? ---
    mov eax, [rbx + STATE_OFFSET + ST_RUNNER_UP_TOKEN]
    test eax, eax
    jz .counterfact_done               ; no runner-up
    inc dword [rbx + STATE_OFFSET + ST_COUNTERFACT_TOTAL]
    cmp eax, r12d                      ; runner-up == actual token?
    jne .counterfact_done
    ; Runner-up would have been correct (counterfactual win)
    inc dword [rbx + STATE_OFFSET + ST_COUNTERFACT_WINS]
.counterfact_done:

    ; === EMIT RECEIPT: EVENT_MISS (full context for debugging) ===
    mov edi, EVENT_MISS               ; event_type
    mov esi, r13d                     ; ctx_hash
    mov edx, r12d                     ; actual_token
    mov ecx, [rbx + STATE_OFFSET + ST_EXPECT_TOKEN]   ; predicted_token (THE KEY!)
    ; Hash the region pointer for region dimension
    mov rax, [rbx + STATE_OFFSET + ST_PREDICT_REGION]
    shr rax, 4                        ; simple hash: shift off alignment bits
    mov r8d, eax                      ; region_hash
    mov r9d, [rbx + STATE_OFFSET + ST_RUNNER_UP_TOKEN] ; aux = runner-up token
    movss xmm0, [rbx + STATE_OFFSET + ST_EXPECT_CONF] ; confidence (was wrong)
    ; Get valence from presence
    movss xmm1, [rbx + STATE_OFFSET + ST_PRESENCE + PRES_VALENCE * 4]
    cvtss2sd xmm1, xmm1
    call emit_receipt_full

    ; === SELF-REFERENCE CHECK: emit EVENT_SELF if digesting own code ===
    ; When UHMA fails to predict its own structure, that's a self-model violation
    cmp dword [rbx + STATE_OFFSET + ST_IS_SELF_REF], 0
    je .skip_self_ref_receipt
    ; Digesting own code and missed - emit EVENT_SELF
    inc dword [rbx + STATE_OFFSET + ST_SELF_SURPRISE_COUNT]
    mov edi, EVENT_SELF
    mov esi, r13d                     ; ctx_hash
    mov edx, r12d                     ; actual_token
    mov ecx, [rbx + STATE_OFFSET + ST_EXPECT_TOKEN]
    mov rax, [rbx + STATE_OFFSET + ST_PREDICT_REGION]
    shr rax, 4
    mov r8d, eax                      ; region_hash
    xor r9d, r9d                      ; aux = 0 (self-reference miss)
    movss xmm0, [rbx + STATE_OFFSET + ST_EXPECT_CONF]
    movss xmm1, [rbx + STATE_OFFSET + ST_PRESENCE + PRES_VALENCE * 4]
    cvtss2sd xmm1, xmm1
    call emit_receipt_full
.skip_self_ref_receipt:

    ; --- Superpose structural context into schema trace ---
    ; This accumulates structural patterns from misses for schema learning
    ; Schema trace = Σ struct_ctx on each miss
    lea rdi, [rbx + STATE_OFFSET + ST_SCHEMA_TRACE_VEC]  ; dst = schema trace
    lea rsi, [rbx + STATE_OFFSET + ST_STRUCT_CTX_VEC]    ; src = current struct_ctx
    call holo_superpose_f64

    ; === SELF-MODEL CORRECTION: update self-knowledge on self-miss ===
    ; When we fail to predict our own behavior, strengthen the correct pattern in self-model
    cmp dword [rbx + STATE_OFFSET + ST_IS_SELF_REF], 0
    je .skip_self_model_correct

    ; Generate vector for actual token and superpose into self-model
    sub rsp, (HOLO_VEC_BYTES + 8)             ; temp vector + 8 alignment
    mov edi, r12d             ; actual token as seed
    mov rsi, rsp
    call holo_gen_vec

    ; Superpose correction into self-model
    lea rdi, [rbx + STATE_OFFSET + ST_SELF_MODEL_VEC]
    mov rsi, rsp
    call holo_superpose_f64

    ; Normalize to prevent magnitude explosion
    lea rdi, [rbx + STATE_OFFSET + ST_SELF_MODEL_VEC]
    call holo_normalize_f64

    add rsp, (HOLO_VEC_BYTES + 8)

.skip_self_model_correct:

    ; Fire miss hook
    mov edi, HOOK_ON_MISS
    mov esi, r12d
    call fire_hook

    ; Print miss feedback
    lea rdi, [rel token_msg]
    call print_cstr
    mov edi, r12d
    call print_hex32
    lea rdi, [rel miss_msg]
    call print_cstr

    ; --- Learn from the miss ---
    ; Current context (hash of prev token) → should predict this token
    mov rdi, r13              ; current context = hash(prev_token)
    mov esi, r12d             ; token to predict
    ; SOMATIC GROUNDING: negative energy_delta for miss (mistakes are costly)
    mov rax, 0xC024000000000000  ; -10.0 f64 (negative valence for errors)
    movq xmm0, rax
    call learn_pattern

    ; OCTOPUS: Misses accrue dream pressure (urge to consolidate)
    mov edi, RPRES_DREAM
    mov rax, 0x3FB999999999999A  ; 0.1 f64 pressure per miss
    movq xmm0, rax
    call accrue_pressure

    ; --- Inhibitory competition: wrong predictor should be suppressed ---
    ; If a confident region predicted wrong, the correct region should inhibit it.
    ; This creates lateral inhibition between competing predictions.
    lea rax, [rbx + STATE_OFFSET + ST_PREDICT_REGION]
    mov rcx, [rax]
    test rcx, rcx
    jz .after_counter          ; no predicting region to inhibit
    ; Find the region that correctly predicts this token in this context
    mov rdi, r13              ; current context
    mov esi, r12d
    push rcx                   ; save wrong-predictor
    call find_existing_pattern ; → rax = correct region (or 0)
    pop rcx                    ; rcx = wrong predictor
    test rax, rax
    jz .after_counter          ; no correct pattern found yet
    cmp rax, rcx
    je .after_counter          ; same region (shouldn't happen, but guard)
    ; Wire inhibition: correct → inhibits wrong (lateral suppression)
    cmp qword [rax + RHDR_INHIBIT_A], 0
    jne .try_inhib_b
    mov [rax + RHDR_INHIBIT_A], rcx
    mov rdx, INITIAL_WEIGHT
    movq xmm0, rdx
    movsd [rax + RHDR_W_INHIBIT_A], xmm0
    inc dword [rbx + STATE_OFFSET + ST_INHIBIT_LEARNED]
    jmp .after_counter
.try_inhib_b:
    cmp qword [rax + RHDR_INHIBIT_B], 0
    jne .after_counter         ; both slots full
    mov [rax + RHDR_INHIBIT_B], rcx
    mov rdx, INITIAL_WEIGHT
    movq xmm0, rdx
    movsd [rax + RHDR_W_INHIBIT_B], xmm0
    inc dword [rbx + STATE_OFFSET + ST_INHIBIT_LEARNED]
    jmp .after_counter

.no_prediction:
    ; No prediction existed — this is a new context
    ; === EMIT RECEIPT: EVENT_NEW ===
    mov edi, EVENT_NEW        ; event_type
    mov esi, r13d             ; ctx_hash (lower 32 bits of context)
    mov edx, r12d             ; token_id
    xorps xmm0, xmm0          ; confidence = 0 (no prediction)
    call emit_receipt_simple

    lea rdi, [rel token_msg]
    call print_cstr
    mov edi, r12d
    call print_hex32
    lea rdi, [rel no_predict_msg]
    call print_cstr

    ; Learn: current context (hash of prev token) → this token
    mov rdi, r13              ; current context = hash(prev_token)
    test rdi, rdi
    jz .after_counter         ; no context yet
    mov esi, r12d
    ; SOMATIC GROUNDING: neutral energy_delta for new context (just learning)
    xorpd xmm0, xmm0          ; 0.0 f64 (neutral valence for new info)
    call learn_pattern

    ; OCTOPUS: New contexts accrue observe pressure (need to monitor growth)
    mov edi, RPRES_OBSERVE
    mov rax, 0x3FA999999999999A  ; 0.05 f64 pressure per new token
    movq xmm0, rax
    call accrue_pressure

.after_counter:
    ; --- Organic dynamics: let internal pressure drive actions ---
    call update_organic_pressure

    ; --- Make next prediction ---
    ; Dispatch: predict what comes AFTER current token
    ; Context for prediction = hash(current_token) so we can find patterns that predict successors
    mov rax, r12              ; current token
    mov rcx, 0x9E3779B97F4A7C15  ; golden ratio prime (64-bit - can't use imul imm64)
    imul rax, rcx             ; hash(current_token)
    mov rdi, rax              ; context = hash(current_token)
    push rax                  ; save for ST_LAST_CTX
    call dispatch_predict     ; → eax = predicted token (0 if none)

    ; Store prediction for next step
    lea rcx, [rbx + STATE_OFFSET + ST_LAST_PREDICT]
    mov [rcx], eax
    ; Store prediction context (hash of current token, for matching on next step)
    pop rax
    lea rcx, [rbx + STATE_OFFSET + ST_LAST_CTX]
    mov [rcx], rax

    ; SOMATIC GROUNDING: Query and store valence for this context
    ; This gives us the "felt sense" of past experiences with this context
    push rax                  ; save ctx for valence query
    mov edi, eax              ; ctx_hash (lower 32)
    call holo_query_valence   ; → xmm0 = valence f64
    movsd [rbx + STATE_OFFSET + ST_LAST_VALENCE], xmm0
    pop rax

    ; OCTOPUS NERVOUS SYSTEM: Let distributed ganglia react
    ; This replaces centralized REPL control with local pressure-based triggering
    call tick_regulators

    ; DEVELOPMENTAL TRACKING: Update mastery metrics
    ; edi = 1 if last prediction was hit, 0 if miss (check ST_LAST_PREDICT vs actual)
    ; For simplicity, use self-prediction stats as proxy
    mov eax, [rbx + STATE_OFFSET + ST_SELF_PRED_HITS]
    mov edx, eax
    mov ecx, [rbx + STATE_OFFSET + ST_SELF_PRED_MISSES]
    add ecx, eax                ; total = hits + misses
    ; edi = 1 if we just had a hit (check if hits increased)
    ; Simplified: pass 1 if hits > misses trend
    cmp eax, [rbx + STATE_OFFSET + ST_SELF_PRED_MISSES]
    setg dil
    movzx edi, dil
    mov esi, edx                ; total hits
    ; edx already has total from earlier calculation
    push r12
    call maturity_update
    pop r12

    ; Fire input hook
    mov edi, HOOK_ON_INPUT
    mov esi, r12d
    call fire_hook

    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; dispatch_predict(ctx_hash) → eax (predicted token, 0=none)
;; rdi=context hash (u64, we use lower 32 bits for comparison)
;; Graph-based dispatch: entry table → traverse links → fallback
;; Spreads activation, decays dynamics, records fires.
;; ============================================================
global dispatch_predict
dispatch_predict:
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub rsp, 80               ; locals:
                              ; [rsp+0]  = best_token (u32)
                              ; [rsp+8]  = best_weight (f64)
                              ; [rsp+16] = best_region_ptr (u64)
                              ; [rsp+24] = depth (u32)
                              ; [rsp+28] = visited (u32)
                              ; [rsp+32] = entry_slot (u32)
                              ; [rsp+36] = ctx_hash_copy (u32)
                              ; --- Counterfactual: runner-up tracking ---
                              ; [rsp+40] = runner_up_token (u32)
                              ; [rsp+48] = runner_up_weight (f64)
                              ; [rsp+56] = runner_up_region (u64)
                              ; [rsp+64] = runner_up_conf (f32)
                              ; [rsp+68] = ctx_type (u32) for self-knowledge

    mov r12d, edi             ; context hash (lower 32 bits)
    mov [rsp + 36], edi       ; save copy
    mov rbx, SURFACE_BASE

    ; JOURNEY: record dispatch_predict
    mov edi, TRACE_DISPATCH_PREDICT
    call journey_step

    ; --- Metabolic cost: prediction attempt costs energy ---
    mov rax, ENERGY_PREDICT_COST
    movq xmm0, rax
    movsd xmm1, [rbx + STATE_OFFSET + ST_ENERGY]
    subsd xmm1, xmm0
    xorpd xmm2, xmm2
    maxsd xmm1, xmm2            ; floor at 0
    movsd [rbx + STATE_OFFSET + ST_ENERGY], xmm1
    addsd xmm0, [rbx + STATE_OFFSET + ST_ENERGY_SPENT]
    movsd [rbx + STATE_OFFSET + ST_ENERGY_SPENT], xmm0

    ; Zero trace counters
    mov dword [rbx + STATE_OFFSET + ST_TRACE_CANDIDATES], 0
    mov dword [rbx + STATE_OFFSET + ST_TRACE_MATCHED], 0
    mov dword [rbx + STATE_OFFSET + ST_EXPECT_IS_SCHEMA], 0

    ; Initialize best-match tracking
    mov dword [rsp + 0], 0    ; best_token
    mov rax, 0xBFF0000000000000  ; -1.0 f64 (any valid weight beats this)
    mov [rsp + 8], rax        ; best_weight = -1.0
    mov qword [rsp + 16], 0   ; best_region_ptr
    mov dword [rsp + 24], 0   ; depth
    mov dword [rsp + 28], 0   ; visited
    ; Initialize runner-up (counterfactual)
    mov dword [rsp + 40], 0   ; runner_up_token
    mov [rsp + 48], rax       ; runner_up_weight = -1.0
    mov qword [rsp + 56], 0   ; runner_up_region
    mov dword [rsp + 64], 0   ; runner_up_conf
    ; Extract context type (top 4 bits → 16 types for self-knowledge)
    mov eax, r12d
    shr eax, 28               ; top 4 bits
    mov [rsp + 68], eax       ; ctx_type

    ; --- RESONANCE QUERY: Check past outcomes for this context ---
    ; Query receipt trace for past HIT events with similar context
    ; High similarity → boost confidence; low → be cautious
    mov edi, EVENT_HIT        ; query for past HITs
    mov esi, r12d             ; ctx_hash
    xor edx, edx              ; token=0 (context-only query)
    call receipt_resonate     ; → xmm0 = similarity to past HITs (f64)
    movsd [rsp + 72], xmm0    ; save hit_similarity

    ; Query for past MISS events
    mov edi, EVENT_MISS
    mov esi, r12d
    xor edx, edx
    call receipt_resonate     ; → xmm0 = similarity to past MISSes
    ; Compute confidence_modulator = hit_sim - miss_sim (range [-1, +1])
    movsd xmm1, [rsp + 72]    ; hit_similarity
    subsd xmm1, xmm0          ; hit_sim - miss_sim

    ; === SELF-MODEL RESONANCE: does this context resonate with self-knowledge? ===
    ; Query cosine similarity between ctx_vec and ST_SELF_MODEL_VEC
    ; High resonance = we're in familiar self-referential territory
    push rbx
    sub rsp, (HOLO_VEC_BYTES + 8)             ; temp ctx_vec + 8 alignment
    mov rsi, rsp
    mov edi, r12d             ; ctx_hash as seed
    movsd [rsp + HOLO_VEC_BYTES], xmm1  ; save confidence_modulator (use space above temp vec)
    call holo_gen_vec         ; generate ctx_vec

    lea rdi, [rbx + STATE_OFFSET + ST_SELF_MODEL_VEC]
    mov rsi, rsp              ; ctx_vec
    call holo_cosim_f64       ; xmm0 = cosine similarity with self-model

    ; Boost confidence if self-model resonates (we know ourselves here)
    ; self_boost = self_resonance * 0.5 (scale factor)
    mov rax, 0x3FE0000000000000  ; 0.5
    movq xmm2, rax
    mulsd xmm0, xmm2          ; self_boost = self_sim * 0.5

    movsd xmm1, [rsp + HOLO_VEC_BYTES]  ; restore confidence_modulator
    addsd xmm1, xmm0          ; confidence_modulator += self_boost

    add rsp, (HOLO_VEC_BYTES + 8)
    pop rbx

    movsd [rsp + 72], xmm1    ; save confidence_modulator

    ; === TRY SCHEMA-BASED PREDICTION FIRST (uses 8-position struct_ctx) ===
    ; Query cosine similarity between current struct_ctx and accumulated schema trace
    cmp dword [rbx + STATE_OFFSET + ST_STRUCT_CTX_VALID], 0
    je .no_schema_predict

    lea rdi, [rbx + STATE_OFFSET + ST_SCHEMA_TRACE_VEC]
    lea rsi, [rbx + STATE_OFFSET + ST_STRUCT_CTX_VEC]
    call holo_cosim_f64       ; xmm0 = schema similarity (f64)

    ; Check if similarity > threshold (0.3 = moderate match)
    mov rax, 0x3FD3333333333333  ; 0.3 f64
    movq xmm1, rax
    ucomisd xmm0, xmm1
    jbe .no_schema_predict

    ; Schema match! Extract filler at position 0 (predicted next token position)
    ; filler ≈ unbind(struct_ctx, ROLE_POS_0)
    push r12                  ; save ctx_hash
    sub rsp, HOLO_VEC_BYTES   ; temp buffer for filler vector
    xor edi, edi              ; role_idx = 0 (next token position)
    mov rsi, rsp              ; output buffer
    call schema_extract_var

    ; Find best matching token for this filler
    mov rdi, rsp              ; filler_ptr
    call schema_query_filler  ; eax = best matching token (0 if none)
    mov r15d, eax             ; save schema prediction

    add rsp, HOLO_VEC_BYTES
    pop r12

    test r15d, r15d
    jz .no_schema_predict

    ; Schema predicted a token! Mark it and compute confidence
    mov dword [rbx + STATE_OFFSET + ST_EXPECT_IS_SCHEMA], 1
    mov eax, r15d             ; predicted token
    ; Use schema similarity as base confidence
    lea rdi, [rbx + STATE_OFFSET + ST_SCHEMA_TRACE_VEC]
    lea rsi, [rbx + STATE_OFFSET + ST_STRUCT_CTX_VEC]
    call holo_cosim_f64       ; xmm0 = confidence
    jmp .holo_got_prediction

.no_schema_predict:
    ; --- FALLBACK TO FLAT HOLOGRAPHIC PREDICTION ---
    mov edi, r12d             ; ctx_hash
    call holo_predict
    ; eax = best_token, xmm0 = confidence (f64)

    ; Save predicted token BEFORE modulation (uses rax for constants!)
    mov r15d, eax             ; r15d = best_token (preserved)

.holo_got_prediction:
    ; --- APPLY RESONANCE MODULATION ---
    ; Adjust confidence based on past HIT/MISS patterns for this context
    ; modulated_conf = conf * (1 + 0.2 * confidence_modulator)
    ; This makes the system trust contexts with good history more
    movsd xmm2, [rsp + 72]    ; confidence_modulator (hit_sim - miss_sim)
    mov rax, 0x3FC999999999999A  ; 0.2 f64
    movq xmm3, rax
    mulsd xmm2, xmm3          ; 0.2 * modulator
    mov rax, 0x3FF0000000000000  ; 1.0 f64
    movq xmm3, rax
    addsd xmm2, xmm3          ; 1 + 0.2 * modulator
    mulsd xmm0, xmm2          ; conf * (1 + 0.2 * modulator)
    ; Clamp to [0, 1]
    xorpd xmm2, xmm2
    maxsd xmm0, xmm2          ; max(0, conf)
    movq xmm2, rax            ; 1.0
    minsd xmm0, xmm2          ; min(1, conf)

    ; Restore predicted token
    mov eax, r15d             ; eax = best_token

    ; Check if confidence > threshold (f64 comparison)
    ucomisd xmm0, [rel holo_thresh]
    jbe .holo_miss

    ; Holographic hit — record and return
    mov [rsp + 0], eax        ; best_token
    ; Update holo prediction stats (f64 accumulator)
    movsd xmm1, [rbx + STATE_OFFSET + ST_HOLO_PREDICT_SUM]
    addsd xmm1, xmm0
    movsd [rbx + STATE_OFFSET + ST_HOLO_PREDICT_SUM], xmm1
    inc dword [rbx + STATE_OFFSET + ST_HOLO_PREDICT_N]
    ; Store as expectation (convert f64 confidence to f32 for compat)
    mov [rbx + STATE_OFFSET + ST_EXPECT_TOKEN], eax
    cvtsd2ss xmm1, xmm0
    movss [rbx + STATE_OFFSET + ST_EXPECT_CONF], xmm1

    ; --- MEMBRANE CREDIT SHARING ---
    ; Holo predicted; check if a DISPATCH region agrees and credit it
    ; This allows NURSERY regions to accumulate hits for promotion
    push rax                    ; save predicted token
    ; DEBUG: print ctx and token being searched
    push rax
    lea rdi, [rel dbg_search_msg]
    call print_cstr
    mov edi, r12d
    call print_hex32
    lea rdi, [rel dbg_tok_msg]
    call print_cstr
    pop rax
    push rax
    mov edi, eax
    call print_hex32
    call print_newline
    pop rax
    ; END DEBUG
    mov edi, r12d               ; context hash
    mov esi, eax                ; predicted token
    call find_existing_pattern  ; → rax = matching region ptr or 0
    mov rcx, rax
    pop rax                     ; restore predicted token
    ; DEBUG: print if match found
    push rax
    push rcx
    test rcx, rcx
    jz .dbg_no_match
    lea rdi, [rel dbg_credit_msg]
    jmp .dbg_print
.dbg_no_match:
    lea rdi, [rel dbg_nocredit_msg]
.dbg_print:
    call print_cstr
    pop rcx
    pop rax
    ; END DEBUG
    test rcx, rcx
    jz .holo_no_dispatch
    ; Found matching DISPATCH region — credit it
    ; DEBUG: print region pointer
    push rax
    push rcx
    lea rdi, [rel dbg_region_msg]
    call print_cstr
    mov rdi, rcx
    call print_hex64
    call print_newline
    pop rcx
    pop rax
    ; END DEBUG
    inc dword [rcx + RHDR_HITS]
    ; Sync to region table entry
    push rax
    push rcx
    mov rdi, rcx
    call update_region_table_hits
    pop rcx
    pop rax
    mov qword [rbx + STATE_OFFSET + ST_PREDICT_REGION], rcx
    mov qword [rbx + STATE_OFFSET + ST_EXPECT_REGION], rcx
    jmp .predict_return
.holo_no_dispatch:
    mov qword [rbx + STATE_OFFSET + ST_EXPECT_REGION], 0
    mov qword [rbx + STATE_OFFSET + ST_PREDICT_REGION], 0
    jmp .predict_return

.holo_miss:
    ; Store sub-threshold holo token for coherence comparison with graph
    mov [rbx + STATE_OFFSET + ST_HOLO_LAST_TOKEN], eax

    ; Sub-threshold holographic signal → anticipatory buffer
    ; "Something forming in the distance" — not strong enough to predict,
    ; but present enough to notice. Accumulates until it materializes.
    test eax, eax
    jz .no_antic_signal         ; no token at all
    ; xmm0 still has confidence from holo_predict
    mov rax, ANTIC_SIGNAL_FLOOR
    movq xmm1, rax
    ucomisd xmm0, xmm1
    jbe .no_antic_signal        ; below noise floor
    ; Feed into anticipatory buffer
    mov edi, eax                ; token_id
    ; xmm0 = confidence (already set)
    call update_anticipatory
.no_antic_signal:

    ; --- Phase 3: Try Schema Dispatch ---
    ; Schemas use structural context with role bindings for prediction.
    ; This is faster than graph traversal and preserves positional info.
    push r12
    call schema_dispatch
    pop r12
    ; eax = predicted token, 0 if no match

    test eax, eax
    jz .no_schema_hit

    ; Schema hit! Return this prediction
    mov [rsp + 0], eax            ; best_token
    mov qword [rsp + 16], 0       ; no region for schema predictions
    mov dword [rbx + STATE_OFFSET + ST_EXPECT_IS_SCHEMA], 1
    jmp .predict_return

.no_schema_hit:

    ; --- Topological Metacognition: Feel the context before choosing strategy ---
    ; Query how we "feel" about this context type: anxious, neutral, or confident
    ; This creates per-topic dispatch mode selection (e.g., "I'm bad at math")

    ; First, get raw confidence score for observability
    mov edi, r12d             ; ctx_hash
    push r12                  ; save ctx_hash across call
    call confidence_query     ; → xmm0 = f64 confidence score
    movsd [rbx + STATE_OFFSET + ST_META_CONFIDENCE], xmm0
    pop r12

    ; Now get the feeling enum
    mov edi, r12d             ; ctx_hash
    call confidence_get_feeling
    ; eax = 0 (neutral), 1 (confident), 2 (anxious)

    ; Store for observability
    mov [rbx + STATE_OFFSET + ST_META_FEELING], eax

    cmp eax, FEELING_ANXIOUS
    je .feeling_anxious
    cmp eax, FEELING_CONFIDENT
    je .feeling_confident
    jmp .entry_point_select    ; neutral → use current dispatch mode

.feeling_anxious:
    ; "I'm anxious about this context" → be careful, deliberate
    ; Override dispatch mode to DELIBERATE for this prediction only
    mov dword [rbx + STATE_OFFSET + ST_DISPATCH_MODE], DMODE_DELIBERATE
    jmp .entry_point_select

.feeling_confident:
    ; "I'm confident about this context" → be quick, intuitive
    ; Override dispatch mode to FAST for this prediction only
    mov dword [rbx + STATE_OFFSET + ST_DISPATCH_MODE], DMODE_FAST

    ; --- ANTICIPATORY INTERFERENCE: Let the ghosts haunt the machine ---
    ; Scan anticipatory buffer for strong (but not yet fired) signals.
    ; Pre-bias RHDR_PRIME of regions that predict those tokens.
    ; This creates "priming": pathways lower their resistance before evidence arrives.
.anticipatory_prime:
    push r12                    ; save ctx_hash
    lea r14, [rbx + STATE_OFFSET + ST_ANTIC_BUF]
    xor ecx, ecx                ; antic buffer index

.antic_prime_loop:
    cmp ecx, ST_ANTIC_CAP
    jge .antic_prime_done

    push rcx
    imul edx, ecx, ST_ANTIC_ENTRY_SIZE
    lea rsi, [r14 + rdx]

    ; Check if this slot is active (token_id != 0)
    mov eax, [rsi + ABE_TOKEN_ID]
    test eax, eax
    jz .antic_prime_next

    ; Check if accumulated confidence is above priming threshold (0.3)
    movsd xmm0, [rsi + ABE_ACCUM_CONF]
    mov rax, 0x3FD3333333333333      ; 0.3 f64
    movq xmm1, rax
    ucomisd xmm0, xmm1
    jbe .antic_prime_next           ; not strong enough to prime

    ; This is a GHOST - strong anticipation for this token
    ; Find regions that predict this token and boost their activation
    mov r15d, eax                   ; anticipated token_id
    movsd xmm7, xmm0                ; save confidence

    ; Scan region table for regions predicting this token
    lea rdi, [rbx + REGION_TABLE_OFFSET]
    xor r8d, r8d                    ; region index

.antic_region_scan:
    cmp r8d, 32                     ; scan up to 32 regions (limit work)
    jge .antic_prime_next

    push r8
    imul eax, r8d, RTE_SIZE
    lea r9, [rdi + rax]

    ; Get region address
    mov r10, [r9 + RTE_ADDR]
    test r10, r10
    jz .antic_region_next

    ; Check if active dispatch region
    movzx eax, word [r9 + RTE_TYPE]
    cmp eax, RTYPE_DISPATCH
    jne .antic_check_resonant
    jmp .antic_check_prediction

.antic_check_resonant:
    cmp eax, RTYPE_RESONANT
    jne .antic_region_next

.antic_check_prediction:
    ; Decode what token this region predicts
    ; Dispatch: CMP EAX, ctx (3D xx xx xx xx) then MOV EAX, token (B8 xx xx xx xx) after JE
    ; Resonant: MOV EAX, ctx (B8 xx xx xx xx) then MOV EAX, token (B8 xx xx xx xx)
    lea rsi, [r10 + RHDR_SIZE]      ; code start
    movzx eax, byte [rsi]

    cmp al, 0x3D                    ; CMP EAX, imm32 (dispatch)
    jne .antic_try_resonant
    ; Skip past CMP (5) + JE (2) = 7, then MOV EAX at offset 7
    cmp byte [rsi + 7], 0xB8
    jne .antic_region_next
    mov eax, [rsi + 8]              ; predicted token
    jmp .antic_compare_token

.antic_try_resonant:
    cmp al, 0xB8                    ; MOV EAX, imm32 (resonant)
    jne .antic_region_next
    ; Second MOV EAX at offset 5
    cmp byte [rsi + 5], 0xB8
    jne .antic_region_next
    mov eax, [rsi + 6]              ; predicted token

.antic_compare_token:
    cmp eax, r15d                   ; does this region predict our ghost token?
    jne .antic_region_next

    ; MATCH: This region predicts the anticipated token
    ; Boost its PRIME by confidence * 0.5 (ghosts partially activate pathways)
    movsd xmm0, xmm7                ; anticipated confidence
    mov rax, 0x3FE0000000000000     ; 0.5 f64
    movq xmm1, rax
    mulsd xmm0, xmm1                ; prime_boost = conf * 0.5
    addsd xmm0, [r10 + RHDR_PRIME]
    movsd [r10 + RHDR_PRIME], xmm0  ; GHOSTLY PRIMING APPLIED

.antic_region_next:
    pop r8
    inc r8d
    jmp .antic_region_scan

.antic_prime_next:
    pop rcx
    inc ecx
    jmp .antic_prime_loop

.antic_prime_done:
    pop r12                         ; restore ctx_hash

.entry_point_select:
    ; --- Entry point selection ---
    ; entry_slot = (ctx_hash >> 4) & 0xF
    mov eax, r12d
    shr eax, 4
    and eax, 0xF
    mov [rsp + 32], eax       ; save slot
    mov r14d, eax             ; r14d = slot

    ; Lookup entry table
    lea rax, [rbx + STATE_OFFSET + ST_ENTRY_TABLE]
    mov r13, [rax + r14 * 8]  ; r13 = entry_ptr (region header ptr)

    ; If entry_ptr is 0, skip to linear fallback
    test r13, r13
    jz .graph_fallback

    ; --- Check dispatch mode for strategy selection ---
    mov eax, [rbx + STATE_OFFSET + ST_DISPATCH_MODE]
    cmp eax, DMODE_CAUSAL
    je .mode_causal
    cmp eax, DMODE_STRUCTURAL
    je .mode_structural
    jmp .graph_traverse           ; default: use standard graph traversal

.mode_causal:
    ; CAUSAL mode: consult causal log for recently-fired connections
    ; Look for chains that led to success
    lea rdi, [rbx + STATE_OFFSET + ST_CAUSAL_LOG]
    mov ecx, [rbx + STATE_OFFSET + ST_CAUSAL_LOG_POS]
    test ecx, ecx
    jz .graph_traverse            ; no causal log, fall back
    dec ecx
    imul edx, ecx, ST_CAUSAL_LOG_ENTRY
    ; Get most recent dst from causal log
    movzx eax, word [rdi + rdx + 2]
    ; Try to find a region with matching low-16 bits
    ; This biases toward recently-causally-connected regions
    ; Just boost prime on regions with matching low bits
    lea rsi, [rbx + REGION_TABLE_OFFSET]
    xor ecx, ecx
.causal_boost_loop:
    cmp ecx, 16                   ; check first 16 regions
    jge .graph_traverse
    push rcx
    imul rdi, rcx, RTE_SIZE
    add rdi, rsi
    mov r8, [rdi + RTE_ADDR]
    test r8, r8
    jz .causal_boost_next
    mov edx, r8d
    and edx, 0xFFFF
    cmp edx, eax
    jne .causal_boost_next
    ; Boost this region's prime (causal connection recently fired)
    mov rax, 0x3FB999999999999A   ; 0.1 f64
    movq xmm0, rax
    addsd xmm0, [r8 + RHDR_PRIME]
    movsd [r8 + RHDR_PRIME], xmm0
.causal_boost_next:
    pop rcx
    inc ecx
    jmp .causal_boost_loop

.mode_structural:
    ; STRUCTURAL mode: weight by working memory slot binding
    ; If token matches a bound slot, boost matching schema regions
    mov eax, [rbx + STATE_OFFSET + ST_CTX_SLOT_NOUN]
    xor eax, r12d                 ; XOR with current context hash
    and eax, 0xF0                 ; mask to top nibble pattern
    ; Just sets a structural bias flag — traversal will use this
    mov [rsp + 72], eax           ; store structural bias pattern
    jmp .graph_traverse

    ; --- Graph Traversal Loop ---
.graph_traverse:
    ; Check depth limit
    cmp dword [rsp + 24], MAX_TRAVERSE_DEPTH
    jge .graph_done

    ; Validate current region pointer (basic sanity)
    ; Must be within dispatch area
    mov rax, SURFACE_BASE + DISPATCH_OFFSET
    cmp r13, rax
    jb .graph_done
    lea rax, [rax + DISPATCH_MAX_SIZE]
    cmp r13, rax
    jae .graph_done

    ; Check flags — skip condemned
    movzx eax, word [r13 + RHDR_FLAGS]
    test eax, RFLAG_ACTIVE
    jz .graph_follow_next
    test eax, RFLAG_CONDEMNED
    jnz .graph_follow_next

    ; Trace: candidate considered
    inc dword [rbx + STATE_OFFSET + ST_TRACE_CANDIDATES]
    inc dword [rsp + 28]      ; visited++

    ; Detect region type by first opcode
    ; 0x3D = CMP EAX, imm32 (exact dispatch)
    ; 0xB8 = MOV EAX, imm32 (resonant dispatch)
    cmp byte [r13 + RHDR_SIZE], 0x3D
    je .graph_exact_dispatch
    cmp byte [r13 + RHDR_SIZE], 0xB8
    je .graph_resonant_dispatch
    jmp .graph_follow_next

.graph_exact_dispatch:
    ; Standard exact-match context check
    ; Compare BASE context only (bits 0-23), ignore mood (bits 24-31)
    ; Mood orients self-regulation, but skills work regardless of mood
    mov eax, [r13 + RHDR_SIZE + 1]   ; stored context (imm32)
    and eax, 0x00FFFFFF              ; strip mood from stored
    mov edi, r12d
    and edi, 0x00FFFFFF              ; strip mood from current

    ; Schema handling
    test eax, 0x0F
    jnz .graph_exact_cmp
    ; Schema pattern — mask to schema granularity
    and edi, 0x00FFFFF0
    and eax, 0x00FFFFF0
    cmp eax, edi
    jne .graph_no_match
    mov dword [rbx + STATE_OFFSET + ST_EXPECT_IS_SCHEMA], 1
    jmp .graph_ctx_matched
.graph_exact_cmp:
    cmp eax, edi
    jne .graph_no_match
    jmp .graph_ctx_matched

.graph_resonant_dispatch:
    ; --- RESONANT GRAPH: Fuzzy VSA matching ---
    ; Call resonant_match(region_ptr, ctx_hash) → xmm0 = similarity
    push r13                  ; save current region ptr
    mov rdi, r13
    mov esi, r12d
    call resonant_match
    pop r13                   ; restore region ptr

    ; Check if similarity exceeds threshold
    ucomisd xmm0, [rel resonant_thresh]
    jbe .graph_no_match       ; below threshold, try other paths

    ; Store similarity for weight calculation
    sub rsp, 8
    movsd [rsp], xmm0         ; save similarity on stack

    ; Fall through to matched path - we have a resonant match
    jmp .graph_ctx_matched_resonant

.graph_ctx_matched:
    ; --- EXACT MATCH: compute effective_weight ---
    inc dword [rbx + STATE_OFFSET + ST_TRACE_MATCHED]

    ; effective_weight = hits/(hits+misses) + activation + prime_level
    mov eax, [r13 + RHDR_HITS]
    mov edx, [r13 + RHDR_MISSES]
    add edx, eax
    test edx, edx
    jz .graph_ew_zero
    cvtsi2sd xmm0, eax
    cvtsi2sd xmm1, edx
    divsd xmm0, xmm1          ; accuracy ratio (f64)
    jmp .graph_ew_add
.graph_ew_zero:
    xorpd xmm0, xmm0
.graph_ew_add:
    addsd xmm0, [r13 + RHDR_ACTIVATION]
    addsd xmm0, [r13 + RHDR_PRIME]
    ; xmm0 = effective_weight
    jmp .graph_compare_best

.graph_ctx_matched_resonant:
    ; --- RESONANT MATCH: compute effective_weight with similarity weighting ---
    inc dword [rbx + STATE_OFFSET + ST_TRACE_MATCHED]

    ; Retrieve saved similarity from stack
    movsd xmm2, [rsp]         ; xmm2 = similarity
    add rsp, 8                ; restore stack

    ; effective_weight = (hits/(hits+misses) + activation + prime) * similarity
    mov eax, [r13 + RHDR_HITS]
    mov edx, [r13 + RHDR_MISSES]
    add edx, eax
    test edx, edx
    jz .graph_res_ew_zero
    cvtsi2sd xmm0, eax
    cvtsi2sd xmm1, edx
    divsd xmm0, xmm1          ; accuracy ratio
    jmp .graph_res_ew_add
.graph_res_ew_zero:
    xorpd xmm0, xmm0
.graph_res_ew_add:
    addsd xmm0, [r13 + RHDR_ACTIVATION]
    addsd xmm0, [r13 + RHDR_PRIME]
    mulsd xmm0, xmm2          ; weight by similarity
    ; xmm0 = effective_weight (similarity-weighted)

.graph_compare_best:
    ; Compare with best
    ucomisd xmm0, [rsp + 8]
    jbe .graph_check_runner_up

    ; New best match — demote old best to runner-up (counterfactual)
    mov eax, [rsp + 0]
    mov [rsp + 40], eax               ; runner_up_token = old best_token
    movsd xmm1, [rsp + 8]
    movsd [rsp + 48], xmm1            ; runner_up_weight = old best_weight
    mov rax, [rsp + 16]
    mov [rsp + 56], rax               ; runner_up_region = old best_region

    ; Store new best - token location differs for exact vs resonant
    ; Exact: [RHDR_SIZE+8] after JNE offset
    ; Resonant: [RHDR_SIZE+6] after first MOV EAX
    cmp byte [r13 + RHDR_SIZE], 0xB8
    je .graph_store_resonant_token
    mov eax, [r13 + RHDR_SIZE + 8]    ; exact: predicted token after JNE
    jmp .graph_store_best
.graph_store_resonant_token:
    mov eax, [r13 + RHDR_SIZE + 6]    ; resonant: token from second MOV
.graph_store_best:
    mov [rsp + 0], eax                ; best_token
    movsd [rsp + 8], xmm0             ; best_weight
    mov [rsp + 16], r13               ; best_region_ptr
    jmp .graph_not_best

.graph_check_runner_up:
    ; Not best, but better than runner-up?
    ucomisd xmm0, [rsp + 48]
    jbe .graph_not_best
    ; New runner-up (counterfactual alternative)
    cmp byte [r13 + RHDR_SIZE], 0xB8
    je .graph_runner_resonant
    mov eax, [r13 + RHDR_SIZE + 8]    ; exact token
    jmp .graph_store_runner
.graph_runner_resonant:
    mov eax, [r13 + RHDR_SIZE + 6]    ; resonant token
.graph_store_runner:
    mov [rsp + 40], eax               ; runner_up_token
    movsd [rsp + 48], xmm0            ; runner_up_weight
    mov [rsp + 56], r13               ; runner_up_region

.graph_not_best:
    ; --- Spread activation to excite targets ---
    mov rdi, r13
    call spread_activation

    ; Follow excite_a for depth search (refinement)
    mov r13, [r13 + RHDR_EXCITE_A]
    inc dword [rsp + 24]      ; depth++
    test r13, r13
    jnz .graph_traverse
    jmp .graph_done

.graph_no_match:
    ; No context match — fall through to follow next
.graph_follow_next:
    inc dword [rsp + 24]      ; depth++ (any link traversal counts)
    mov rax, [r13 + RHDR_NEXT_A]
    test rax, rax
    jnz .graph_follow_a
    ; Try next_b
    mov rax, [r13 + RHDR_NEXT_B]
    test rax, rax
    jnz .graph_follow_b
    ; Both dead — done with graph traversal
    jmp .graph_done
.graph_follow_a:
    mov r13, rax
    jmp .graph_traverse
.graph_follow_b:
    mov r13, rax
    jmp .graph_traverse

.graph_done:
    ; Check if graph traversal found anything
    cmp qword [rsp + 16], 0
    jne .dispatch_found

.graph_fallback:
    ; --- Fallback: scan primed regions (activation > threshold) ---
    lea r13, [rbx + REGION_TABLE_OFFSET]
    lea rax, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    mov ecx, [rax]            ; region count
    xor edx, edx              ; start from index 0

.fallback_scan:
    cmp edx, ecx
    jge .fallback_done
    push rcx
    push rdx

    imul rdi, rdx, RTE_SIZE
    add rdi, r13
    movzx eax, word [rdi + RTE_TYPE]

    ; Check for exact dispatch regions (RTYPE_DISPATCH)
    cmp eax, RTYPE_DISPATCH
    je .fallback_check_dispatch

    ; Check for resonant regions (RTYPE_RESONANT) - fuzzy matching
    cmp eax, RTYPE_RESONANT
    je .fallback_check_resonant

    jmp .fallback_skip

.fallback_check_dispatch:
    ; Standard exact-match dispatch region
    movzx eax, word [rdi + RTE_FLAGS]
    test eax, RFLAG_CONDEMNED
    jnz .fallback_skip

    mov rsi, [rdi + RTE_ADDR]

    ; Check context match FIRST (even if not primed, context match matters)
    cmp byte [rsi + RHDR_SIZE], 0x3D
    jne .fallback_skip

    ; Trace: candidate
    inc dword [rbx + STATE_OFFSET + ST_TRACE_CANDIDATES]
    mov eax, [rsi + RHDR_SIZE + 1]
    test eax, 0x0F
    jnz .fallback_exact
    mov edi, r12d
    and edi, 0xFFFFFFF0
    cmp eax, edi
    jne .fallback_skip
    mov dword [rbx + STATE_OFFSET + ST_EXPECT_IS_SCHEMA], 1
    jmp .fallback_matched
.fallback_exact:
    cmp eax, r12d
    jne .fallback_skip
.fallback_matched:
    inc dword [rbx + STATE_OFFSET + ST_TRACE_MATCHED]

    ; Compute effective_weight
    mov eax, [rsi + RHDR_HITS]
    mov edx, [rsi + RHDR_MISSES]
    add edx, eax
    test edx, edx
    jz .fb_ew_zero
    cvtsi2sd xmm0, eax
    cvtsi2sd xmm1, edx
    divsd xmm0, xmm1
    jmp .fb_ew_add
.fb_ew_zero:
    xorpd xmm0, xmm0
.fb_ew_add:
    addsd xmm0, [rsi + RHDR_ACTIVATION]
    addsd xmm0, [rsi + RHDR_PRIME]

    ; Compare with best
    ucomisd xmm0, [rsp + 16 + 8]   ; adjust for 2 pushes
    jbe .fallback_skip
    ; New best
    mov eax, [rsi + RHDR_SIZE + 8]
    mov [rsp + 16 + 0], eax
    movsd [rsp + 16 + 8], xmm0
    mov [rsp + 16 + 16], rsi
    jmp .fallback_skip

.fallback_check_resonant:
    ; --- RESONANT FALLBACK: Fuzzy matching via VSA similarity ---
    movzx eax, word [rdi + RTE_FLAGS]
    test eax, RFLAG_CONDEMNED
    jnz .fallback_skip

    mov rsi, [rdi + RTE_ADDR]
    inc dword [rbx + STATE_OFFSET + ST_TRACE_CANDIDATES]

    ; Save rsi across call
    push rsi

    ; Call resonant_match(region_ptr, ctx_hash) → xmm0 = similarity
    mov rdi, rsi
    mov esi, r12d
    call resonant_match

    ; Restore rsi
    pop rsi

    ; Check if similarity exceeds threshold
    ucomisd xmm0, [rel resonant_thresh]
    jbe .fallback_skip

    ; RESONANT MATCH
    inc dword [rbx + STATE_OFFSET + ST_TRACE_MATCHED]

    ; Save similarity in xmm2
    movsd xmm2, xmm0

    ; Compute effective_weight with similarity weighting
    mov eax, [rsi + RHDR_HITS]
    mov edx, [rsi + RHDR_MISSES]
    add edx, eax
    test edx, edx
    jz .fb_res_ew_zero
    cvtsi2sd xmm0, eax
    cvtsi2sd xmm1, edx
    divsd xmm0, xmm1
    jmp .fb_res_ew_add
.fb_res_ew_zero:
    xorpd xmm0, xmm0
.fb_res_ew_add:
    addsd xmm0, [rsi + RHDR_ACTIVATION]
    addsd xmm0, [rsi + RHDR_PRIME]
    mulsd xmm0, xmm2          ; weight by similarity

    ; Compare with best
    ucomisd xmm0, [rsp + 16 + 8]
    jbe .fallback_skip
    ; New best resonant match
    mov eax, [rsi + RHDR_SIZE + 6]    ; token from resonant region
    mov [rsp + 16 + 0], eax
    movsd [rsp + 16 + 8], xmm0
    mov [rsp + 16 + 16], rsi

.fallback_skip:
    pop rdx
    pop rcx
    inc edx
    jmp .fallback_scan

.fallback_done:
    ; Check if fallback found anything
    cmp qword [rsp + 16], 0
    jne .dispatch_found

    ; --- Last resort: full linear scan (no priming filter) ---
    lea r13, [rbx + REGION_TABLE_OFFSET]
    lea rax, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    mov ecx, [rax]
    xor edx, edx              ; start from index 0

.linear_scan:
    cmp edx, ecx
    jge .linear_done
    push rcx
    push rdx

    imul rdi, rdx, RTE_SIZE
    add rdi, r13
    movzx eax, word [rdi + RTE_TYPE]

    ; Check for exact dispatch regions (RTYPE_DISPATCH)
    cmp eax, RTYPE_DISPATCH
    je .linear_check_dispatch

    ; Check for resonant regions (RTYPE_RESONANT) - fuzzy matching
    cmp eax, RTYPE_RESONANT
    je .linear_check_resonant

    jmp .linear_skip

.linear_check_dispatch:
    ; Standard exact-match dispatch region
    movzx eax, word [rdi + RTE_FLAGS]
    test eax, RFLAG_CONDEMNED
    jnz .linear_skip

    mov rsi, [rdi + RTE_ADDR]
    inc dword [rbx + STATE_OFFSET + ST_TRACE_CANDIDATES]

    cmp byte [rsi + RHDR_SIZE], 0x3D
    jne .linear_skip
    mov eax, [rsi + RHDR_SIZE + 1]
    test eax, 0x0F
    jnz .linear_exact
    mov edi, r12d
    and edi, 0xFFFFFFF0
    cmp eax, edi
    jne .linear_skip
    mov dword [rbx + STATE_OFFSET + ST_EXPECT_IS_SCHEMA], 1
    jmp .linear_matched
.linear_exact:
    cmp eax, r12d
    jne .linear_skip
.linear_matched:
    inc dword [rbx + STATE_OFFSET + ST_TRACE_MATCHED]

    ; Compute effective_weight
    mov eax, [rsi + RHDR_HITS]
    mov edx, [rsi + RHDR_MISSES]
    add edx, eax
    test edx, edx
    jz .lin_ew_zero
    cvtsi2sd xmm0, eax
    cvtsi2sd xmm1, edx
    divsd xmm0, xmm1
    jmp .lin_ew_add
.lin_ew_zero:
    xorpd xmm0, xmm0
.lin_ew_add:
    addsd xmm0, [rsi + RHDR_ACTIVATION]
    addsd xmm0, [rsi + RHDR_PRIME]

    ucomisd xmm0, [rsp + 16 + 8]
    jbe .linear_skip
    mov eax, [rsi + RHDR_SIZE + 8]
    mov [rsp + 16 + 0], eax
    movsd [rsp + 16 + 8], xmm0
    mov [rsp + 16 + 16], rsi
    jmp .linear_skip

.linear_check_resonant:
    ; --- RESONANT DISPATCH: Fuzzy matching via VSA similarity ---
    ; RTYPE_RESONANT regions use vector similarity instead of exact CMP
    movzx eax, word [rdi + RTE_FLAGS]
    test eax, RFLAG_CONDEMNED
    jnz .linear_skip

    mov rsi, [rdi + RTE_ADDR]
    inc dword [rbx + STATE_OFFSET + ST_TRACE_CANDIDATES]

    ; Save rsi (region ptr) across call - use stack
    push rsi

    ; Call resonant_match(region_ptr, ctx_hash) → xmm0 = similarity
    mov rdi, rsi              ; region_ptr
    mov esi, r12d             ; ctx_hash
    call resonant_match
    ; xmm0 = similarity score [0.0, 1.0]

    ; Restore rsi
    pop rsi

    ; Check if similarity exceeds resonant threshold (0.7)
    ucomisd xmm0, [rel resonant_thresh]
    jbe .linear_skip          ; below threshold, no match

    ; RESONANT MATCH: similarity > threshold
    inc dword [rbx + STATE_OFFSET + ST_TRACE_MATCHED]

    ; Compute effective_weight = similarity * (accuracy + activation + prime)
    ; First, save similarity in xmm2
    movsd xmm2, xmm0

    ; Compute accuracy
    mov eax, [rsi + RHDR_HITS]
    mov edx, [rsi + RHDR_MISSES]
    add edx, eax
    test edx, edx
    jz .res_ew_zero
    cvtsi2sd xmm0, eax
    cvtsi2sd xmm1, edx
    divsd xmm0, xmm1          ; accuracy
    jmp .res_ew_add
.res_ew_zero:
    xorpd xmm0, xmm0
.res_ew_add:
    addsd xmm0, [rsi + RHDR_ACTIVATION]
    addsd xmm0, [rsi + RHDR_PRIME]
    ; Multiply by similarity score (weigh by how fuzzy the match is)
    mulsd xmm0, xmm2          ; effective_weight = (acc + act + prime) * similarity

    ; Compare with current best
    ucomisd xmm0, [rsp + 16 + 8]
    jbe .linear_skip

    ; New best - extract predicted token from resonant region
    ; Resonant layout: [+0] MOV EAX, ctx_hash; [+5] MOV EAX, token_id; [+10] RET
    mov eax, [rsi + RHDR_SIZE + 6]    ; token_id (from second MOV instruction)
    mov [rsp + 16 + 0], eax           ; best_token
    movsd [rsp + 16 + 8], xmm0        ; best_weight
    mov [rsp + 16 + 16], rsi          ; best_region_ptr

.linear_skip:
    pop rdx
    pop rcx
    inc edx
    jmp .linear_scan

.linear_done:
    ; Check if linear scan found anything
    cmp qword [rsp + 16], 0
    jne .dispatch_found

.no_match:
    xor eax, eax             ; no prediction
    lea rcx, [rbx + STATE_OFFSET + ST_PREDICT_REGION]
    mov qword [rcx], 0
    mov qword [rbx + STATE_OFFSET + ST_EXPECT_REGION], 0

    jmp .predict_return

.dispatch_found:
    ; --- We have a match ---
    mov eax, [rsp + 0]        ; best_token
    mov rsi, [rsp + 16]       ; best_region_ptr

    ; --- Coherence tracking: does graph agree with holo? ---
    mov [rbx + STATE_OFFSET + ST_GRAPH_LAST_TOKEN], eax
    mov ecx, [rbx + STATE_OFFSET + ST_HOLO_LAST_TOKEN]
    test ecx, ecx
    jz .skip_coherence         ; no holo prediction to compare
    cmp ecx, eax
    jne .coherence_disagree
    ; AGREE: holographic and graph both predict same thing → internal consistency
    inc dword [rbx + STATE_OFFSET + ST_COHERENCE_AGREE]
    jmp .skip_coherence
.coherence_disagree:
    ; DISAGREE: tension between memory systems → needs resolution
    inc dword [rbx + STATE_OFFSET + ST_COHERENCE_DISAGREE]
.skip_coherence:

    ; Store as predicting region
    lea rcx, [rbx + STATE_OFFSET + ST_PREDICT_REGION]
    mov [rcx], rsi

    ; --- Record firing in fire ring ---
    push rax
    push rsi
    mov rdi, rsi
    call record_fire
    pop rsi
    pop rax

    ; --- Update entry table for this context slot ---
    mov ecx, [rsp + 32]       ; entry_slot
    lea rdx, [rbx + STATE_OFFSET + ST_ENTRY_TABLE]
    mov [rdx + rcx * 8], rsi  ; entry_table[slot] = winning region

    ; --- Store graph trace metrics ---
    mov ecx, [rsp + 24]
    mov [rbx + STATE_OFFSET + ST_GRAPH_DEPTH], ecx
    mov ecx, [rsp + 28]
    mov [rbx + STATE_OFFSET + ST_GRAPH_VISITED], ecx

    ; --- Fill expectation bundle ---
    jmp .fill_expect

.fill_expect:
    ; Fill self-expectation bundle
    ; eax = predicted token, rsi = region ptr
    push rax
    mov [rbx + STATE_OFFSET + ST_EXPECT_REGION], rsi
    ; Confidence = hits/(hits+misses)
    mov ecx, [rsi + RHDR_HITS]
    mov edx, [rsi + RHDR_MISSES]
    add edx, ecx
    test edx, edx
    jz .expect_zero
    cvtsi2ss xmm0, ecx
    cvtsi2ss xmm1, edx
    divss xmm0, xmm1
    jmp .expect_store
.expect_zero:
    xorps xmm0, xmm0
.expect_store:
    movss [rbx + STATE_OFFSET + ST_EXPECT_CONF], xmm0
    pop rax
    mov [rbx + STATE_OFFSET + ST_EXPECT_TOKEN], eax

.predict_return:
    ; Save return value (predicted token)
    push rax

    ; Store runner-up for counterfactual analysis
    mov eax, [rsp + 8 + 40]           ; adjust for push
    mov [rbx + STATE_OFFSET + ST_RUNNER_UP_TOKEN], eax
    cvtsd2ss xmm0, qword [rsp + 8 + 48]
    movss [rbx + STATE_OFFSET + ST_RUNNER_UP_CONF], xmm0
    mov rax, [rsp + 8 + 56]
    mov [rbx + STATE_OFFSET + ST_RUNNER_UP_REGION], rax

    ; Restore return value
    pop rax

    add rsp, 80
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; spread_activation(region_ptr)
;; rdi = firing region header ptr
;; Updates excite/inhibit targets' prime and activation levels.
;; ============================================================
global spread_activation
spread_activation:
    push rbx
    push r12
    mov r12, rdi              ; firing region

    ; Load source activation
    movsd xmm0, [r12 + RHDR_ACTIVATION]   ; source.activation

    ; --- Excite target A ---
    mov rax, [r12 + RHDR_EXCITE_A]
    test rax, rax
    jz .spread_excite_b
    ; target_a.prime += source.activation * w_excite_a
    movsd xmm1, [r12 + RHDR_W_EXCITE_A]
    movsd xmm2, xmm0
    mulsd xmm2, xmm1          ; source.activation * w_excite_a
    addsd xmm2, [rax + RHDR_PRIME]
    movsd [rax + RHDR_PRIME], xmm2

    ; --- Causal chain logging: record this connection fired ---
    push rax
    push rcx
    mov rbx, SURFACE_BASE
    mov ecx, [rbx + STATE_OFFSET + ST_CAUSAL_LOG_POS]
    lea rdi, [rbx + STATE_OFFSET + ST_CAUSAL_LOG]
    imul edx, ecx, ST_CAUSAL_LOG_ENTRY
    ; Entry: (src:u16, dst:u16, step:u32)
    mov eax, r12d
    mov [rdi + rdx], ax           ; src (low 16 bits of ptr)
    pop rcx
    pop rax
    push rax
    push rcx
    mov [rdi + rdx + 2], ax       ; dst (low 16 bits of target ptr)
    mov eax, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    mov [rdi + rdx + 4], eax      ; step
    ; Advance log position (wrap at cap)
    inc ecx
    cmp ecx, ST_CAUSAL_LOG_CAP
    jl .causal_log_no_wrap_a
    xor ecx, ecx
.causal_log_no_wrap_a:
    mov [rbx + STATE_OFFSET + ST_CAUSAL_LOG_POS], ecx
    pop rcx
    pop rax

    ; target_a.activation += source.prime * w_excite_a * 0.5
    movsd xmm2, [r12 + RHDR_PRIME]
    mulsd xmm2, xmm1
    mulsd xmm2, [rel half_point_o]
    addsd xmm2, [rax + RHDR_ACTIVATION]
    ; Clamp to [0.0, 1.0]
    xorpd xmm3, xmm3
    maxsd xmm2, xmm3
    movsd xmm3, [rel one_point_o]
    minsd xmm2, xmm3
    movsd [rax + RHDR_ACTIVATION], xmm2

.spread_excite_b:
    ; --- Excite target B ---
    mov rax, [r12 + RHDR_EXCITE_B]
    test rax, rax
    jz .spread_inhibit_a
    movsd xmm1, [r12 + RHDR_W_EXCITE_B]
    movsd xmm2, xmm0
    mulsd xmm2, xmm1
    addsd xmm2, [rax + RHDR_PRIME]
    movsd [rax + RHDR_PRIME], xmm2

    ; --- Causal chain logging for excite_b ---
    push rax
    push rcx
    mov rbx, SURFACE_BASE
    mov ecx, [rbx + STATE_OFFSET + ST_CAUSAL_LOG_POS]
    lea rdi, [rbx + STATE_OFFSET + ST_CAUSAL_LOG]
    imul edx, ecx, ST_CAUSAL_LOG_ENTRY
    mov eax, r12d
    mov [rdi + rdx], ax           ; src
    pop rcx
    pop rax
    push rax
    push rcx
    mov [rdi + rdx + 2], ax       ; dst
    mov eax, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    mov [rdi + rdx + 4], eax      ; step
    inc ecx
    cmp ecx, ST_CAUSAL_LOG_CAP
    jl .causal_log_no_wrap_b
    xor ecx, ecx
.causal_log_no_wrap_b:
    mov [rbx + STATE_OFFSET + ST_CAUSAL_LOG_POS], ecx
    pop rcx
    pop rax

    ; target_b.activation += source.prime * w_excite_b * 0.5
    movsd xmm2, [r12 + RHDR_PRIME]
    mulsd xmm2, xmm1
    mulsd xmm2, [rel half_point_o]
    addsd xmm2, [rax + RHDR_ACTIVATION]
    xorpd xmm3, xmm3
    maxsd xmm2, xmm3
    movsd xmm3, [rel one_point_o]
    minsd xmm2, xmm3
    movsd [rax + RHDR_ACTIVATION], xmm2

.spread_inhibit_a:
    ; --- Inhibit target A ---
    mov rax, [r12 + RHDR_INHIBIT_A]
    test rax, rax
    jz .spread_inhibit_b
    ; target.activation -= source.activation * w_inhibit_a
    movsd xmm1, [r12 + RHDR_W_INHIBIT_A]
    movsd xmm2, xmm0
    mulsd xmm2, xmm1
    movsd xmm3, [rax + RHDR_ACTIVATION]
    subsd xmm3, xmm2
    ; Clamp to >= 0
    xorpd xmm4, xmm4
    maxsd xmm3, xmm4
    movsd [rax + RHDR_ACTIVATION], xmm3

.spread_inhibit_b:
    ; --- Inhibit target B ---
    mov rax, [r12 + RHDR_INHIBIT_B]
    test rax, rax
    jz .spread_done
    movsd xmm1, [r12 + RHDR_W_INHIBIT_B]
    movsd xmm2, xmm0
    mulsd xmm2, xmm1
    movsd xmm3, [rax + RHDR_ACTIVATION]
    subsd xmm3, xmm2
    xorpd xmm4, xmm4
    maxsd xmm3, xmm4
    movsd [rax + RHDR_ACTIVATION], xmm3

.spread_done:
    ; Set firing region's activation to 1.0 (it just fired)
    movsd xmm0, [rel one_point_o]
    movsd [r12 + RHDR_ACTIVATION], xmm0

    pop r12
    pop rbx
    ret

;; ============================================================
;; decay_all_regions
;; Walk all regions: prime *= PRIME_DECAY, activation *= ACTIVATION_DECAY
;; ============================================================
global decay_all_regions
decay_all_regions:
    push rbx
    push r12
    push r13

    mov rbx, SURFACE_BASE
    lea r12, [rbx + REGION_TABLE_OFFSET]
    lea rax, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    mov r13d, [rax]

    ; Preload decay constants
    movsd xmm4, [rel prime_decay]     ; 0.9
    movsd xmm5, [rel activ_decay]     ; 0.85

    xor ecx, ecx
.decay_loop:
    cmp ecx, r13d
    jge .decay_done
    push rcx

    imul rdi, rcx, RTE_SIZE
    add rdi, r12
    movzx eax, word [rdi + RTE_FLAGS]
    test eax, RFLAG_CONDEMNED
    jnz .decay_next

    mov rsi, [rdi + RTE_ADDR]
    test rsi, rsi              ; null check - skip if RTE_ADDR is 0
    jz .decay_next

    ; prime *= PRIME_DECAY
    movsd xmm0, [rsi + RHDR_PRIME]
    mulsd xmm0, xmm4
    movsd [rsi + RHDR_PRIME], xmm0

    ; activation *= ACTIVATION_DECAY
    movsd xmm0, [rsi + RHDR_ACTIVATION]
    mulsd xmm0, xmm5
    movsd [rsi + RHDR_ACTIVATION], xmm0

.decay_next:
    pop rcx
    inc ecx
    jmp .decay_loop

.decay_done:
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; record_fire(region_ptr)
;; rdi = region header ptr that just fired
;; Writes (ptr, timestamp_f64) to ST_FIRE_RING
;; ============================================================
global record_fire
record_fire:
    push rbx
    mov rbx, SURFACE_BASE

    ; Get fire ring position
    lea rax, [rbx + STATE_OFFSET + ST_FIRE_POS]
    mov ecx, [rax]

    ; Calculate ring entry address
    lea rdx, [rbx + STATE_OFFSET + ST_FIRE_RING]
    imul r8d, ecx, ST_FIRE_RING_ENTRY  ; 16 bytes per entry
    add rdx, r8

    ; Store region ptr
    mov [rdx], rdi

    ; Store timestamp as f64 (convert global_step to f64)
    mov rax, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    cvtsi2sd xmm0, rax
    movsd [rdx + 8], xmm0

    ; Update fire_recency on the region
    movsd [rdi + RHDR_FIRE_RECENCY], xmm0

    ; Advance ring position
    lea rax, [rbx + STATE_OFFSET + ST_FIRE_POS]
    inc ecx
    cmp ecx, ST_FIRE_RING_CAP
    jl .fire_no_wrap
    xor ecx, ecx
.fire_no_wrap:
    mov [rax], ecx

    ; Increment total fire count
    lea rax, [rbx + STATE_OFFSET + ST_FIRE_COUNT]
    inc qword [rax]

    pop rbx
    ret

;; ============================================================
;; update_region_table_hits(header_ptr)
;; rdi=region header address
;; Syncs the hit counter to the region table entry
;; ============================================================
update_region_table_hits:
    push rbx
    mov rbx, SURFACE_BASE
    lea rsi, [rbx + REGION_TABLE_OFFSET]
    lea rax, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    mov ecx, [rax]
    xor edx, edx
.loop:
    cmp edx, ecx
    jge .done
    imul rax, rdx, RTE_SIZE
    add rax, rsi
    cmp [rax + RTE_ADDR], rdi
    jne .next
    ; Found — copy hits from header
    mov ebx, [rdi + RHDR_HITS]
    mov [rax + RTE_HITS], ebx
    ; Reset consecutive errors on hit (region is healthy)
    mov word [rax + RTE_CONSEC_ERRORS], 0
    jmp .done
.next:
    inc edx
    jmp .loop
.done:
    pop rbx
    ret

;; ============================================================
;; update_region_table_misses(header_ptr)
;; Increments consecutive error count; condemns at 9 errors (broken region death)
;; ============================================================
update_region_table_misses:
    push rbx
    push r12
    mov rbx, SURFACE_BASE
    mov r12, rdi                    ; save header ptr
    lea rsi, [rbx + REGION_TABLE_OFFSET]
    lea rax, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    mov ecx, [rax]
    xor edx, edx
.loop:
    cmp edx, ecx
    jge .done
    imul rax, rdx, RTE_SIZE
    add rax, rsi
    cmp [rax + RTE_ADDR], r12
    jne .next
    ; Found — copy misses from header
    mov ebx, [r12 + RHDR_MISSES]
    mov [rax + RTE_MISSES], ebx
    ; Increment consecutive errors (9-error kill rule)
    movzx ebx, word [rax + RTE_CONSEC_ERRORS]
    inc ebx
    mov [rax + RTE_CONSEC_ERRORS], bx
    ; Check if region should die (9 consecutive errors = broken)
    cmp ebx, CONSEC_ERROR_KILL
    jl .done
    ; 9-error death: condemn immediately (code is genuinely broken)
    movzx ebx, word [rax + RTE_FLAGS]
    or ebx, RFLAG_CONDEMNED
    mov [rax + RTE_FLAGS], bx
    ; Also mark header
    movzx ebx, word [r12 + RHDR_FLAGS]
    or ebx, RFLAG_CONDEMNED
    mov [r12 + RHDR_FLAGS], bx
    jmp .done
.next:
    inc edx
    jmp .loop
.done:
    pop r12
    pop rbx
    ret

;; ============================================================
;; find_region_index(header_ptr) → eax (index, or -1 if not found)
;; rdi=region header address
;; ============================================================
global find_region_index
find_region_index:
    push rbx
    push r12
    mov rbx, SURFACE_BASE
    lea r12, [rbx + REGION_TABLE_OFFSET]
    lea rax, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    mov ecx, [rax]
    xor edx, edx
.fri_loop:
    cmp edx, ecx
    jge .fri_not_found
    imul rax, rdx, RTE_SIZE
    add rax, r12
    cmp [rax + RTE_ADDR], rdi
    je .fri_found
    inc edx
    jmp .fri_loop
.fri_found:
    mov eax, edx
    pop r12
    pop rbx
    ret
.fri_not_found:
    mov eax, -1
    pop r12
    pop rbx
    ret

;; ============================================================
;; compute_struct_ctx()
;; Computes structural context: Σ bind(ROLE_POS_i, token_vec[history[i]])
;; Uses last 8 tokens from token ring buffer.
;; Result stored in ST_STRUCT_CTX_VEC.
;;
;; This is Phase 2 of structural learning:
;; - Flat context (ST_CTX_HASH): Rolling hash, loses position info
;; - Structural context (ST_STRUCT_CTX_VEC): Preserves position via role binding
;;
;; Uses SCRATCH_OFFSET for temp vectors to avoid stack overflow.
;; ============================================================
global compute_struct_ctx
compute_struct_ctx:
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub rsp, 8                            ; align stack

    mov rbx, SURFACE_BASE

    ; Use scratch area for temp vectors (safer than stack)
    ; temp_role = SCRATCH_OFFSET + 0
    ; temp_bound = SCRATCH_OFFSET + HOLO_VEC_BYTES
    lea r14, [rbx + SCRATCH_OFFSET]                   ; temp_role ptr
    lea r15, [rbx + SCRATCH_OFFSET + HOLO_VEC_BYTES]  ; temp_bound ptr

    ; --- Zero the structural context vector ---
    lea rdi, [rbx + STATE_OFFSET + ST_STRUCT_CTX_VEC]
    mov ecx, HOLO_VEC_BYTES / 8
    xor eax, eax
.zero_loop:
    mov [rdi], rax
    add rdi, 8
    dec ecx
    jnz .zero_loop

    ; --- Get token count and ring position ---
    mov eax, [rbx + STATE_OFFSET + ST_TOKEN_COUNT]
    test eax, eax
    jz .ctx_done                          ; no tokens yet

    ; Compute how many tokens to use: min(8, token_count)
    cmp eax, 8
    jle .use_count
    mov eax, 8
.use_count:
    mov r12d, eax                         ; r12 = num_tokens to process

    ; r13 = current position index (0 = most recent)
    xor r13d, r13d

.bind_loop:
    cmp r13d, r12d
    jge .ctx_normalize

    ; --- Generate f64 role vector for position r13 ---
    ; Use (position | 0x524F4C00) as seed for unique role vectors
    mov edi, r13d
    or edi, 0x524F4C00                    ; "ROL\0" + position
    mov rsi, r14                          ; output to temp_role (f64[1024])
    push r12
    push r13
    call holo_gen_vec
    pop r13
    pop r12

    ; --- Get token from history ---
    ; ring_idx = (pos - 1 - r13) & (CAP - 1)
    mov eax, [rbx + STATE_OFFSET + ST_TOKEN_POS]
    sub eax, 1
    sub eax, r13d
    and eax, (ST_TOKEN_BUF_CAP - 1)

    ; token_id = token_buf[ring_idx]
    lea rcx, [rbx + STATE_OFFSET + ST_TOKEN_BUF]
    mov r10d, [rcx + rax * 4]             ; token_id (use r10, rcx is clobbered)

    ; --- Generate f64 token vector ---
    ; Use SCRATCH_OFFSET + 2*HOLO_VEC_BYTES for temp_token
    mov edi, r10d                         ; token_id as seed
    lea rsi, [rbx + SCRATCH_OFFSET + HOLO_VEC_BYTES * 2]  ; temp_token (f64[1024])
    push r12
    push r13
    call holo_gen_vec
    pop r13
    pop r12

    ; --- Bind role with token: temp_bound = bind(temp_role, temp_token) ---
    mov rdi, r14                          ; temp_role (f64)
    lea rsi, [rbx + SCRATCH_OFFSET + HOLO_VEC_BYTES * 2]  ; temp_token (f64)
    mov rdx, r15                          ; output to temp_bound (f64)
    push r12
    push r13
    call holo_bind_f64
    pop r13
    pop r12

    ; --- Superpose into structural context (f64) ---
    ; struct_ctx += temp_bound
    lea rdi, [rbx + STATE_OFFSET + ST_STRUCT_CTX_VEC]
    mov rsi, r15                          ; temp_bound (f64)
    push r12
    push r13
    call holo_superpose_f64
    pop r13
    pop r12

    inc r13d
    jmp .bind_loop

.ctx_normalize:
    ; Optional: normalize the structural context
    ; For now, skip normalization to preserve magnitude information

    ; Mark as valid
    mov dword [rbx + STATE_OFFSET + ST_STRUCT_CTX_VALID], 1
    mov rax, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    mov [rbx + STATE_OFFSET + ST_STRUCT_CTX_STEP], rax

.ctx_done:
    add rsp, 8
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; PHASE 3: SCHEMA DISPATCH FUNCTIONS
;; Structural pattern matching with variable extraction
;; ============================================================

section .data
    align 8
    ; NOTE: Schema matching threshold is low (0.01) because current implementation
    ; stores full struct_ctx but doesn't mask variable positions during comparison.
    ; Full variable masking would allow higher thresholds.
    schema_match_thresh: dq 0.01

section .text

;; ============================================================
;; schema_match(schema_ptr) → xmm0 (similarity score)
;; rdi = schema entry pointer
;; Returns cosine similarity between schema template and ST_STRUCT_CTX_VEC
;; ============================================================
global schema_match
schema_match:
    push rbx
    push r12
    sub rsp, 8

    mov r12, rdi                          ; schema_ptr
    mov rbx, SURFACE_BASE

    ; Check if structural context is valid
    cmp dword [rbx + STATE_OFFSET + ST_STRUCT_CTX_VALID], 0
    je .no_match

    ; Compute cosine similarity: cos(template, struct_ctx)
    mov rdi, r12                          ; template is at start of schema entry
    lea rsi, [rbx + STATE_OFFSET + ST_STRUCT_CTX_VEC]
    call holo_cosim_f64
    ; xmm0 = similarity

    jmp .match_done

.no_match:
    xorpd xmm0, xmm0                      ; return 0.0

.match_done:
    add rsp, 8
    pop r12
    pop rbx
    ret

;; ============================================================
;; schema_extract_var(role_idx, out_ptr)
;; edi = role position index (0-7)
;; rsi = output vector pointer
;; Extracts filler from structural context by unbinding with role vector.
;; filler ≈ unbind(struct_ctx, ROLE_POS_idx)
;; ============================================================
global schema_extract_var
schema_extract_var:
    push rbx
    push r12
    push r13
    sub rsp, 8

    mov r12d, edi                         ; role_idx
    mov r13, rsi                          ; out_ptr
    mov rbx, SURFACE_BASE

    ; Generate f64 role vector in scratch area
    mov edi, r12d
    or edi, 0x524F4C00                    ; "ROL\0" + position (same as compute_struct_ctx)
    lea rsi, [rbx + SCRATCH_OFFSET + HOLO_VEC_BYTES * 2]  ; temp for role
    call holo_gen_vec

    ; Unbind: filler = unbind(struct_ctx, role) using f64
    lea rdi, [rbx + STATE_OFFSET + ST_STRUCT_CTX_VEC]
    lea rsi, [rbx + SCRATCH_OFFSET + HOLO_VEC_BYTES * 2]  ; role vector
    mov rdx, r13                          ; output
    call holo_unbind_f64

    add rsp, 8
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; schema_query_filler(filler_ptr) → eax (best matching token)
;; rdi = filler vector pointer
;; Finds the token whose vector is most similar to the filler.
;; Returns token_id of best match, 0 if no good match.
;; Scans the ACTUAL vocabulary table, not hardcoded 0-255.
;; ============================================================
global schema_query_filler
schema_query_filler:
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub rsp, 24                           ; 5 pushes (odd) + 24 = 64 bytes, 16-aligned

    mov r12, rdi                          ; filler_ptr
    mov rbx, SURFACE_BASE
    xor r13d, r13d                        ; best_token = 0
    mov rax, 0xBFF0000000000000           ; -1.0 (any positive beats this)
    movq xmm7, rax                        ; best_sim in xmm7

    ; Get vocabulary count and cap at VOCAB_MAX_SCAN
    mov r15d, [rbx + STATE_OFFSET + ST_VOCAB_COUNT]
    cmp r15d, VOCAB_MAX_SCAN
    jle .vocab_count_ok
    mov r15d, VOCAB_MAX_SCAN
.vocab_count_ok:
    test r15d, r15d
    jz .scan_done                         ; empty vocab

    ; Calculate vocab table base (VOCAB_OFFSET sign-extends, use register)
    mov rax, VOCAB_OFFSET
    add rax, rbx                          ; rax = vocab_table_base
    mov [rsp], rax                        ; save vocab_base on stack

    ; Scan vocabulary entries
    xor r14d, r14d                        ; vocab_idx

.scan_loop:
    cmp r14d, r15d
    jge .scan_done

    ; Read token_id from vocab entry [vocab_base + idx * 8]
    mov rax, [rsp]                        ; vocab_base
    imul rcx, r14, VOCAB_ENTRY_SIZE       ; idx * 8
    mov edi, [rax + rcx]                  ; token_id (first u32 of entry)

    ; Generate f64 token vector in scratch area
    lea rsi, [rbx + SCRATCH_OFFSET + HOLO_VEC_BYTES * 4]  ; temp for token vec
    mov [rsp + 8], r14                    ; save idx
    mov [rsp + 16], r15                   ; save count
    call holo_gen_vec
    mov r14, [rsp + 8]                    ; restore idx
    mov r15, [rsp + 16]                   ; restore count

    ; Compute similarity (f64)
    mov rdi, r12                          ; filler (f64)
    lea rsi, [rbx + SCRATCH_OFFSET + HOLO_VEC_BYTES * 4]  ; token_vec (f64)
    mov [rsp + 8], r14
    mov [rsp + 16], r15
    call holo_cosim_f64
    mov r14, [rsp + 8]
    mov r15, [rsp + 16]
    ; xmm0 = similarity

    ; Check if better than best
    ucomisd xmm0, xmm7
    jbe .next_token

    ; New best - save the actual token_id, not the index
    movapd xmm7, xmm0
    mov rax, [rsp]                        ; vocab_base
    imul rcx, r14, VOCAB_ENTRY_SIZE
    mov r13d, [rax + rcx]                 ; best_token = token_id

.next_token:
    inc r14d
    jmp .scan_loop

.scan_done:
    ; Check if best_sim > 0.1 (lowered for noisy unbinding)
    mov rax, 0x3FB999999999999A           ; 0.1
    movq xmm0, rax
    ucomisd xmm7, xmm0
    jbe .no_good_match

    mov eax, r13d                         ; return best_token
    jmp .query_done

.no_good_match:
    xor eax, eax                          ; return 0

.query_done:
    add rsp, 24
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; schema_dispatch() → eax (predicted token, 0=none)
;; Tries to match structural context against all active schemas.
;; If match found, extracts variables and makes prediction.
;; ============================================================
global schema_dispatch
schema_dispatch:
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub rsp, 24                           ; locals

    mov rbx, SURFACE_BASE

    ; Check if structural context is valid
    cmp dword [rbx + STATE_OFFSET + ST_STRUCT_CTX_VALID], 0
    je .no_schema_match

    ; Get schema count
    mov eax, [rbx + STATE_OFFSET + ST_SCHEMA_COUNT]
    test eax, eax
    jz .no_schema_match

    mov r12d, eax                         ; num_schemas
    xor r13d, r13d                        ; schema_idx
    xor r14d, r14d                        ; best_token = 0
    mov rax, 0xBFF0000000000000           ; -1.0
    mov [rsp], rax                        ; best_score

    ; Schema table base
    lea r15, [rbx + SCHEMA_TABLE_OFFSET]

.schema_loop:
    cmp r13d, r12d
    jge .schema_done

    ; Compute schema entry address
    mov eax, r13d
    imul eax, SCHEMA_ENTRY_SIZE
    lea rdi, [r15 + rax]                  ; schema_ptr

    ; Check if schema is active
    movzx eax, byte [rdi + SCHE_FLAGS]
    test al, SCHEF_ACTIVE
    jz .next_schema

    ; Save schema_ptr
    mov [rsp + 8], rdi

    ; Match schema
    push r12
    push r13
    push r14
    push r15
    call schema_match
    pop r15
    pop r14
    pop r13
    pop r12
    ; xmm0 = match score

    ; Check against threshold
    ucomisd xmm0, [rel schema_match_thresh]
    jbe .next_schema

    ; Check if better than current best
    ucomisd xmm0, [rsp]
    jbe .next_schema

    ; New best match - extract variable and predict
    movsd [rsp], xmm0                     ; update best_score

    ; Get predict_role from schema
    mov rdi, [rsp + 8]                    ; schema_ptr
    movzx edi, byte [rdi + SCHE_PREDICT_ROLE]
    and edi, 7                            ; clamp to 0-7

    ; Output to scratch area
    lea rsi, [rbx + SCRATCH_OFFSET + HOLO_VEC_BYTES * 3]
    push r12
    push r13
    push r14
    push r15
    call schema_extract_var
    pop r15
    pop r14
    pop r13
    pop r12

    ; Query extracted filler to find predicted token
    lea rdi, [rbx + SCRATCH_OFFSET + HOLO_VEC_BYTES * 3]
    push r12
    push r13
    push r14
    push r15
    call schema_query_filler
    pop r15
    pop r14
    pop r13
    pop r12
    ; eax = predicted token

    test eax, eax
    jz .next_schema

    mov r14d, eax                         ; best_token

    ; Update schema stats
    mov rdi, [rsp + 8]                    ; schema_ptr
    inc dword [rdi + SCHE_HITS]

    ; Track match
    inc dword [rbx + STATE_OFFSET + ST_SCHEMA_MATCHES]

.next_schema:
    inc r13d
    jmp .schema_loop

.schema_done:
    mov eax, r14d                         ; return best_token
    test eax, eax
    jz .no_schema_match

    ; Increment schema extraction counter
    inc dword [rbx + STATE_OFFSET + ST_SCHEMA_EXTRACTS]

    jmp .schema_exit

.no_schema_match:
    xor eax, eax

.schema_exit:
    add rsp, 24
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; schema_create(template_ptr, var_mask, predict_role) → rax (schema_ptr)
;; rdi = template vector pointer
;; esi = variable mask (bits for variable positions)
;; edx = predict role (which position to predict)
;; Creates a new schema entry. Returns pointer or 0 if full.
;; ============================================================
global schema_create
schema_create:
    push rbx
    push r12
    push r13
    push r14
    sub rsp, 8

    mov r12, rdi                          ; template_ptr
    mov r13d, esi                         ; var_mask
    mov r14d, edx                         ; predict_role
    mov rbx, SURFACE_BASE

    ; Check if we have room
    mov eax, [rbx + STATE_OFFSET + ST_SCHEMA_COUNT]
    cmp eax, SCHEMA_MAX
    jge .schema_full

    ; Compute new schema entry address
    mov ecx, eax                          ; schema_idx
    imul ecx, SCHEMA_ENTRY_SIZE
    lea rax, [rbx + SCHEMA_TABLE_OFFSET + rcx]
    push rax                              ; save schema_ptr

    ; Copy template vector
    mov rdi, rax                          ; dest = schema entry start
    mov rsi, r12                          ; src = template
    mov ecx, HOLO_VEC_BYTES / 8
.copy_template:
    mov rdx, [rsi]
    mov [rdi], rdx
    add rsi, 8
    add rdi, 8
    dec ecx
    jnz .copy_template

    ; Fill metadata
    pop rax                               ; restore schema_ptr
    mov byte [rax + SCHE_VAR_MASK], r13b
    mov byte [rax + SCHE_PREDICT_ROLE], r14b
    mov byte [rax + SCHE_CONDITION_ROLE], 0
    mov byte [rax + SCHE_FLAGS], SCHEF_ACTIVE | SCHEF_LEARNED
    mov dword [rax + SCHE_MATCH_THRESH], 0x3F19999A  ; 0.6 f32
    mov dword [rax + SCHE_PRED_TOKEN], 0
    mov dword [rax + SCHE_HITS], 0
    mov dword [rax + SCHE_MISSES], 0
    mov ecx, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    mov [rax + SCHE_BIRTH], ecx
    mov [rax + SCHE_LAST_FIRE], ecx

    ; Increment count
    inc dword [rbx + STATE_OFFSET + ST_SCHEMA_COUNT]

    jmp .create_done

.schema_full:
    xor eax, eax                          ; return 0

.create_done:
    add rsp, 8
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; schema_learn_from_context()
;; Creates a schema from the current structural context.
;; Called when a pattern is worth generalizing.
;; Uses current struct_ctx as template, position 0 as condition,
;; position 2 as variable to predict.
;; ============================================================
global schema_learn_from_context
schema_learn_from_context:
    push rbx
    sub rsp, 8

    mov rbx, SURFACE_BASE

    ; Check if structural context is valid
    cmp dword [rbx + STATE_OFFSET + ST_STRUCT_CTX_VALID], 0
    je .learn_done

    ; Use current structural context as template
    lea rdi, [rbx + STATE_OFFSET + ST_STRUCT_CTX_VEC]
    mov esi, 0x04                         ; var_mask = bit 2 (ROLE_POS_2 is variable)
    mov edx, 2                            ; predict_role = 2
    call schema_create

.learn_done:
    add rsp, 8
    pop rbx
    ret
; dreams.asm — Offline consolidation: replay misses, speculate, commit
;
; @entry dream_cycle() -> void ; replay miss buffer, emit speculative
; @entry dream_consolidate() -> void ; review NURSERY, promote/condemn
; @entry dream_extract_schemas() -> void ; holographic schema extraction + self-model awareness
; @calls emit.asm:emit_dispatch_pattern
; @calls vsa.asm:holo_store, vsa.asm:holo_cosim_f64, vsa.asm:holo_scale_f64
; @calls receipt.asm:receipt_resonate, emit_receipt_simple, emit_receipt_full
; @calls dispatch.asm:schema_learn_from_context
; @calledby repl.asm:cmd_dream
;
; FLOW (dream_cycle):
;   miss_buffer → check exists → emit NURSERY pattern → schema extract
; FLOW (consolidate):
;   NURSERY aged>50 → no hits=condemn, hits=promote+reinforce
;
; SCHEMA EXTRACTION (holographic approach):
;   1. Query: holo_cosim_f64(struct_ctx, schema_trace) → cosine similarity
;   2. If similarity > 0.01: call schema_learn_from_context
;   3. Decay trace by 0.5 to prevent saturation
;   The schema trace accumulates struct_ctx on every MISS (in dispatch.asm)
;   High resonance = recurring structural pattern worth generalizing
;
; SELF-MODEL AWARENESS (~line 327):
;   After schema extraction, queries EVENT_SELF resonance
;   If significant self-model violation history detected:
;     - Prints self-model awareness level
;     - Emits EVENT_SELF receipt with aux=1 (dream-discovered)
;   This is where the system becomes "conscious" of its own prediction failures
;
; GOTCHAS:
;   - NURSERY patterns need 50+ steps before judgment
;   - Schema trace decays each dream (0.5x) to allow new patterns
;   - Promoted patterns must be reinforced via holo_store
;   - Uses cosine similarity (normalized) not raw dot product
%include "syscalls.inc"
%include "constants.inc"

section .data
    dream_start:    db "[DREAM] Beginning consolidation cycle...", 10, 0
    dream_end:      db "[DREAM] Cycle complete. Replayed: ", 0
    dream_emit:     db "[DREAM] Speculative pattern emitted", 10, 0
    dream_skip:     db "[DREAM] Pattern rejected (exists or weak)", 10, 0
    dream_count:    db " entries, emitted: ", 0
    dream_nl:       db 10, 0
    schema_msg:     db "[DREAM] Schema extracted (generalized pattern)", 10, 0
    schema_res_msg: db "[DREAM] Schema resonance: ", 0
    self_model_msg: db "[DREAM] Self-model awareness: ", 0
    reinforce_msg:  db "[LTM] Reinforcing proven pattern ctx=0x", 0

    align 8
    ; Reinforcement strength for proven patterns (counteracts decay)
    reinforce_strength: dq 2.0
    ; Schema resonance threshold - structural pattern must resonate above this
    ; NOTE: Very low threshold (0.01) for testing; tune up once working
    schema_resonate_thresh: dq 0.01
    ; Schema trace decay factor - prevents saturation
    schema_trace_decay: dq 0.5

section .text

extern print_cstr
extern print_u64
extern print_newline
extern print_f64
extern find_existing_pattern
extern emit_dispatch_pattern
extern fire_hook
extern gate_test_modification
extern journey_step
extern sym_scan_for_discoveries
extern holo_store
extern holo_dot_f64
extern holo_scale_f64
extern holo_cosim_f64
extern receipt_resonate
extern emit_receipt_simple
extern emit_receipt_full
extern schema_learn_from_context

;; ============================================================
;; dream_cycle
;; Offline replay of the miss buffer:
;; 1. Iterate miss buffer entries
;; 2. For each (context, token) pair:
;;    a. Check if a pattern already exists
;;    b. If not, emit a speculative pattern (NURSERY flag)
;; 3. Consolidation: patterns survive if they help
;; ============================================================
global dream_cycle
dream_cycle:
    push rbx
    push r12
    push r13
    push r14
    push r15

    mov rbx, SURFACE_BASE

    ; JOURNEY: record dream_cycle
    mov edi, TRACE_DREAM_CYCLE
    call journey_step

    ; Fire dream start hook
    mov edi, HOOK_ON_DREAM_START
    xor esi, esi
    call fire_hook

    lea rdi, [rel dream_start]
    call print_cstr

    ; Get miss buffer state
    lea rax, [rbx + STATE_OFFSET + ST_MISS_POS]
    mov r12d, [rax]           ; current miss position (write cursor)

    ; Determine how many entries to replay
    ; Replay up to DREAM_REPLAY_COUNT entries, starting from oldest
    mov r13d, DREAM_REPLAY_COUNT
    cmp r13d, r12d
    jle .cap_ok
    mov r13d, r12d            ; don't replay more than available
.cap_ok:
    test r13d, r13d
    jz .dream_done

    ; Calculate start position (oldest entries)
    mov eax, r12d
    sub eax, r13d
    test eax, eax
    jns .start_ok
    ; Wrapped around — start from 0
    xor eax, eax
.start_ok:
    mov r14d, eax             ; start index

    xor r15d, r15d            ; emitted count

    ; --- Replay loop ---
.replay_loop:
    cmp r14d, r12d
    jge .dream_done
    push r14

    ; Get miss entry
    lea rsi, [rbx + STATE_OFFSET + ST_MISS_BUF]
    imul eax, r14d, ST_MISS_ENTRY_SIZE
    add rsi, rax

    ; Read context hash and token
    mov rdi, [rsi]            ; ctx_hash (u64)
    mov ecx, [rsi + 8]       ; token_id

    ; Use lower 32 bits of context hash for pattern matching
    mov edi, edi              ; zero-extend lower 32
    push rcx                  ; save token_id

    ; Check if pattern already exists
    mov esi, ecx
    call find_existing_pattern
    pop rcx

    test rax, rax
    jnz .skip_entry           ; already exists

    ; --- RESONANCE QUERY: Have we dreamed about this pattern recently? ---
    ; Avoid redundant speculation by checking past DREAM events
    lea rsi, [rbx + STATE_OFFSET + ST_MISS_BUF]
    pop r14
    push r14
    imul eax, r14d, ST_MISS_ENTRY_SIZE
    add rsi, rax
    ; Read ctx_hash and token_id from miss entry
    mov eax, [rsi]            ; ctx_hash (save in eax)
    mov edx, [rsi + 8]        ; token_id
    mov edi, EVENT_DREAM
    mov esi, eax              ; ctx_hash as second param
    call receipt_resonate     ; → xmm0 = similarity to past DREAMs
    ; If very high similarity (>0.8), skip - we've dreamed this recently
    mov rax, 0x3FE999999999999A  ; 0.8 f64
    movq xmm1, rax
    ucomisd xmm0, xmm1
    ja .skip_entry            ; skip if too similar to recent dream

    ; Check region table capacity
    lea rax, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    mov eax, [rax]
    cmp eax, REGION_TABLE_MAX - 8  ; leave room
    jge .table_full            ; table full, stop dreaming

    ; Emit speculative pattern
    ; Recover context and token from miss entry
    lea rsi, [rbx + STATE_OFFSET + ST_MISS_BUF]
    imul eax, r14d, ST_MISS_ENTRY_SIZE
    add rsi, rax
    mov edi, [rsi]            ; ctx_hash (lower 32)
    mov esi, [rsi + 8]       ; token_id

    ; Save ctx and token for receipt emission
    push rdi
    push rsi

    ; Get birth step
    lea rax, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    mov edx, [rax]

    ; Emit
    call emit_dispatch_pattern

    ; Mark as NURSERY (speculative)
    test rax, rax
    jz .dream_skip_receipt
    or word [rax + RHDR_FLAGS], RFLAG_NURSERY

    ; === EMIT RECEIPT: EVENT_DREAM ===
    pop rsi                   ; token_id
    pop rdi                   ; ctx_hash (but we need edi, esi, edx)
    push rdi
    push rsi
    mov edx, esi              ; token_id
    mov esi, edi              ; ctx_hash
    mov edi, EVENT_DREAM      ; event_type
    xorps xmm0, xmm0          ; confidence = 0 (speculative)
    call emit_receipt_simple

.dream_skip_receipt:
    pop rsi
    pop rdi

    lea rdi, [rel dream_emit]
    call print_cstr

    inc r15d
    jmp .next_entry

.skip_entry:
    ; Pattern exists or was rejected

.next_entry:
    pop r14
    inc r14d
    cmp r15d, DREAM_REPLAY_COUNT / 2   ; limit emissions per cycle
    jl .replay_loop
    jmp .dream_done

.table_full:
    ; Stack has loop r14 on top - pop it before exiting
    pop r14

.dream_done:
    ; --- Schema extraction pass ---
    ; Look for pairs of miss entries with same token but similar contexts
    ; If found, emit a generalized pattern (masked context)
    call dream_extract_schemas

    ; Print summary
    lea rdi, [rel dream_end]
    call print_cstr
    movzx rdi, r13w
    call print_u64
    lea rdi, [rel dream_count]
    call print_cstr
    movzx rdi, r15w
    call print_u64
    call print_newline

    ; Scan for emergent patterns (things that work despite looking wrong)
    call sym_scan_for_discoveries

    ; Fire dream end hook
    mov edi, HOOK_ON_DREAM_END
    mov esi, r15d
    call fire_hook

    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; dream_extract_schemas
;; Uses holographic resonance to detect recurring structural patterns.
;;
;; The schema trace (ST_SCHEMA_TRACE_VEC) accumulates structural contexts
;; from every miss. When we dream, we query: does the current struct_ctx
;; resonate with this accumulated trace? High resonance = recurring pattern
;; that should become a schema.
;;
;; This replaces the O(n²) miss buffer scan with O(1) resonance query.
;; The holographic memory IS the index.
;; ============================================================
dream_extract_schemas:
    push rbx
    push r12
    sub rsp, 8                ; align stack (2 pushes = even, need 8 mod 16)

    mov rbx, SURFACE_BASE

    ; Check if structural context is valid
    cmp dword [rbx + STATE_OFFSET + ST_STRUCT_CTX_VALID], 0
    je .no_schema

    ; Query: does current struct_ctx resonate with accumulated schema trace?
    ; Use COSINE similarity (normalized dot product) for magnitude-independent comparison
    ; High similarity = we've seen this structural pattern many times on misses
    lea rdi, [rbx + STATE_OFFSET + ST_STRUCT_CTX_VEC]
    lea rsi, [rbx + STATE_OFFSET + ST_SCHEMA_TRACE_VEC]
    call holo_cosim_f64         ; xmm0 = cosine similarity

    ; DEBUG: Print resonance value
    push rbx
    sub rsp, 8                  ; align for call
    movsd [rsp], xmm0           ; save resonance
    lea rdi, [rel schema_res_msg]
    call print_cstr
    movsd xmm0, [rsp]           ; restore resonance
    call print_f64
    call print_newline
    movsd xmm0, [rsp]           ; restore resonance again
    add rsp, 8
    pop rbx

    ; If resonance > threshold, create schema from current struct_ctx
    movsd xmm1, [rel schema_resonate_thresh]  ; 0.2
    ucomisd xmm0, xmm1
    jbe .decay_trace            ; below threshold, just decay

    ; High resonance detected - create schema using existing function
    ; schema_learn_from_context uses current struct_ctx as template
    call schema_learn_from_context

    lea rdi, [rel schema_msg]
    call print_cstr

    ; === SELF-MODEL SCHEMA EXTRACTION ===
    ; Query EVENT_SELF resonance: do we have recurring self-model violations?
    ; High resonance = we keep failing to predict ourselves in similar contexts
    mov edi, EVENT_SELF           ; event type
    xor esi, esi                  ; any context
    xor edx, edx                  ; any token
    call receipt_resonate         ; xmm0 = self-violation resonance

    ; If significant self-model violation history, note it
    mov rax, 0x3FB999999999999A   ; 0.1 threshold
    movq xmm1, rax
    ucomisd xmm0, xmm1
    jbe .decay_trace

    ; Self-model violations detected - emit receipt for self-awareness tracking
    push rbx
    sub rsp, 8
    movsd [rsp], xmm0             ; save resonance

    ; Print self-model awareness message
    lea rdi, [rel self_model_msg]
    call print_cstr
    movsd xmm0, [rsp]
    call print_f64
    call print_newline

    ; Emit EVENT_SELF receipt to mark dream-discovered self-pattern
    movsd xmm0, [rsp]
    add rsp, 8
    pop rbx

    ; The system is becoming aware of its own prediction failures
    ; This receipt marks the transition from unconscious to conscious self-error
    mov edi, EVENT_SELF
    mov esi, [rbx + STATE_OFFSET + ST_CTX_HASH]
    xor edx, edx                  ; no specific token
    xor ecx, ecx                  ; no prediction
    xor r8d, r8d                  ; no region
    mov r9d, 1                    ; aux=1 marks dream-discovered self-awareness
    ; xmm0 already has resonance as confidence
    xorpd xmm1, xmm1              ; valence=0 (neutral observation)
    call emit_receipt_full

.decay_trace:
    ; Decay trace to prevent saturation (even if no schema created)
    ; This ensures old patterns fade and new ones can emerge
    lea rdi, [rbx + STATE_OFFSET + ST_SCHEMA_TRACE_VEC]
    movsd xmm0, [rel schema_trace_decay]  ; 0.5 decay factor
    call holo_scale_f64

    ; Decay self-model too - old self-knowledge fades, new emerges
    lea rdi, [rbx + STATE_OFFSET + ST_SELF_MODEL_VEC]
    movsd xmm0, [rel schema_trace_decay]  ; same 0.5 decay
    call holo_scale_f64

.no_schema:
    add rsp, 8
    pop r12
    pop rbx
    ret

;; ============================================================
;; dream_consolidate
;; Review NURSERY regions: promote survivors, condemn failures
;; Called after some steps have passed since dreaming
;; ============================================================
global dream_consolidate
dream_consolidate:
    push rbx
    push r12
    push r13

    mov rbx, SURFACE_BASE
    lea r12, [rbx + REGION_TABLE_OFFSET]
    lea rax, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    mov r13d, [rax]

    xor ecx, ecx
.consol_loop:
    cmp ecx, r13d
    jge .consol_done
    push rcx

    imul rdi, rcx, RTE_SIZE
    add rdi, r12

    ; Only check NURSERY regions
    movzx eax, word [rdi + RTE_FLAGS]
    test eax, RFLAG_NURSERY
    jz .consol_next

    ; Get header
    mov rsi, [rdi + RTE_ADDR]

    ; Check age: must have had time to be tested
    lea rax, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    mov eax, [rax]
    sub eax, [rsi + RHDR_BIRTH]
    cmp eax, 50               ; minimum age before judgment
    jl .consol_next

    ; Check performance
    mov eax, [rsi + RHDR_HITS]
    mov edx, [rsi + RHDR_MISSES]
    add edx, eax              ; total
    test edx, edx
    jz .condemn_nursery        ; no activity = condemn

    ; If any hits, promote to ACTIVE
    test eax, eax
    jnz .promote_nursery

.condemn_nursery:
    ; No hits after min age — condemn
    or word [rsi + RHDR_FLAGS], RFLAG_CONDEMNED
    and word [rsi + RHDR_FLAGS], ~RFLAG_NURSERY
    ; Update table flags
    or word [rdi + RTE_FLAGS], RFLAG_CONDEMNED
    jmp .consol_next

.promote_nursery:
    ; Has hits — graduate to ACTIVE (this is now Long-Term Memory)
    and word [rsi + RHDR_FLAGS], ~RFLAG_NURSERY
    or word [rsi + RHDR_FLAGS], RFLAG_ACTIVE
    ; Update table
    and word [rdi + RTE_FLAGS], ~RFLAG_NURSERY

    ; === REINFORCE HOLOGRAPHIC TRACE ===
    ; Proven patterns must be reinforced to counteract decay (LTM)
    ; rsi = region header, code starts at rsi + RHDR_SIZE
    push rdi
    push rsi
    push rcx

    lea rax, [rsi + RHDR_SIZE]     ; code body

    ; Check for cmp eax, imm32 (0x3D) to extract ctx_hash
    cmp byte [rax], 0x3D
    jne .no_reinforce             ; skip if not standard pattern

    mov edi, [rax + 1]            ; ctx_hash = bytes 1-4
    push rdi                      ; save ctx_hash

    ; Scan for mov eax, imm32 (0xB8) to extract pred_token
    movzx ecx, word [rsi + RHDR_CODE_LEN]
    lea rax, [rsi + RHDR_SIZE + 5] ; skip cmp instruction
    sub ecx, 5
.scan_token:
    cmp ecx, 5
    jl .no_token
    cmp byte [rax], 0xB8
    je .found_token
    inc rax
    dec ecx
    jmp .scan_token

.found_token:
    mov esi, [rax + 1]            ; pred_token = bytes after 0xB8
    pop rdi                       ; restore ctx_hash

    ; Save for receipt emission
    push rdi
    push rsi

    ; Call holo_store(ctx_hash, pred_token, reinforce_strength)
    movsd xmm0, [rel reinforce_strength]
    call holo_store

    ; === EMIT RECEIPT: EVENT_PROMOTE ===
    pop rsi                       ; token_id
    pop rdi                       ; ctx_hash
    mov edx, esi                  ; token_id
    mov esi, edi                  ; ctx_hash
    mov edi, EVENT_PROMOTE        ; event_type
    mov eax, 0x3F800000           ; 1.0f confidence (promoted = proven)
    movd xmm0, eax
    call emit_receipt_simple

    jmp .reinforce_done

.no_token:
    pop rdi                       ; clean up saved ctx_hash
.no_reinforce:
.reinforce_done:
    pop rcx
    pop rsi
    pop rdi

.consol_next:
    pop rcx
    inc ecx
    jmp .consol_loop

.consol_done:
    pop r13
    pop r12
    pop rbx
    ret
; drives.asm — Homeostatic drive system: thresholds, goals, actions
;
; ENTRY POINTS:
;   drives_check()               - check all drives vs thresholds, trigger actions
;   drives_show()                - display current drive levels and thresholds
;   drives_set_threshold(id,val) - set threshold for drive id
;
; DRIVES (f32 values in ST_DRIVES[]):
;   [0] Accuracy   - prediction hit rate, triggers exploration when low
;   [1] Efficiency - resource usage, triggers pruning when low
;   [2] Novelty    - pattern diversity, triggers context rotation when low
;   [3] Coherence  - graph/holo agreement, triggers alignment when low
;
; ACTIONS:
;   Accuracy low  → set GOAL_EXPLORATION, increase exploration
;   Efficiency low → set GOAL_EFFICIENCY, call region_compact()
;   Novelty low   → set GOAL_NOVELTY, rotate context
;   Coherence low → set GOAL_COHERENCE, call modify_restructure()
;
; CALLED BY: introspect.asm (update_organic_pressure), repl.asm (periodic)
;
%include "syscalls.inc"
%include "constants.inc"

section .data
    drive_hdr:      db "--- Drives ---", 10, 0
    drive_acc_lbl:  db "  Accuracy:   ", 0
    drive_eff_lbl:  db "  Efficiency: ", 0
    drive_nov_lbl:  db "  Novelty:    ", 0
    drive_coh_lbl:  db "  Coherence:  ", 0
    drive_thresh:   db " (thresh=", 0
    drive_close:    db ")", 10, 0
    drive_trigger:  db "[DRIVE] ", 0
    drive_acc_trig: db "Accuracy low — increasing exploration", 10, 0
    drive_eff_trig: db "Efficiency low — triggering pruning", 10, 0
    drive_nov_trig: db "Novelty low — forcing context rotation", 10, 0
    drive_coh_trig: db "Coherence low — triggering alignment", 10, 0

section .text

extern print_cstr
extern print_f32
extern print_newline
extern fire_hook
extern region_compact
extern modify_restructure

;; ============================================================
;; drives_check
;; Check all drive levels against thresholds, trigger actions
;; Called periodically from the observation loop or REPL
;; ============================================================
global drives_check
drives_check:
    push rbx
    push r12

    mov rbx, SURFACE_BASE
    lea r12, [rbx + STATE_OFFSET]

    ; Clear goal at start (will be set by triggered drive)
    mov dword [r12 + ST_CURRENT_GOAL], GOAL_NONE

    ; --- Drive 0: Accuracy ---
    ; If accuracy < threshold → increase exploration
    movss xmm0, [r12 + ST_DRIVES + 0]        ; current accuracy
    mov eax, [r12 + ST_DRIVE_THRESH + 0]      ; threshold
    movd xmm1, eax
    comiss xmm0, xmm1
    ja .check_efficiency       ; accuracy above threshold, OK

    ; TRIGGER: Accuracy too low
    mov dword [r12 + ST_CURRENT_GOAL], GOAL_EXPLORE
    mov eax, [r12 + ST_GLOBAL_STEP]
    mov [r12 + ST_GOAL_STEP], eax

    lea rdi, [rel drive_trigger]
    call print_cstr
    lea rdi, [rel drive_acc_trig]
    call print_cstr

    ; Action: emit some exploratory patterns from miss buffer
    ; (The observation loop will handle this via learn_pattern calls)
    mov edi, HOOK_ON_DRIVE
    mov esi, DRIVE_ACCURACY
    call fire_hook

.check_efficiency:
    ; --- Drive 1: Efficiency ---
    ; If surface usage > threshold → prune
    movss xmm0, [r12 + ST_DRIVES + 4]
    mov eax, [r12 + ST_DRIVE_THRESH + 4]
    movd xmm1, eax
    comiss xmm0, xmm1
    jb .check_novelty          ; usage below threshold, OK

    ; TRIGGER: Too much surface used
    mov dword [r12 + ST_CURRENT_GOAL], GOAL_PRUNE
    mov eax, [r12 + ST_GLOBAL_STEP]
    mov [r12 + ST_GOAL_STEP], eax

    lea rdi, [rel drive_trigger]
    call print_cstr
    lea rdi, [rel drive_eff_trig]
    call print_cstr

    ; Action: compact condemned regions
    call region_compact

    mov edi, HOOK_ON_DRIVE
    mov esi, DRIVE_EFFICIENCY
    call fire_hook

.check_novelty:
    ; --- Drive 2: Novelty ---
    ; If novelty too low (same regions always firing) → force rotation
    movss xmm0, [r12 + ST_DRIVES + 8]
    mov eax, [r12 + ST_DRIVE_THRESH + 8]
    movd xmm1, eax
    comiss xmm0, xmm1
    jb .check_coherence

    ; TRIGGER: Too repetitive
    mov dword [r12 + ST_CURRENT_GOAL], GOAL_EXPLORE
    mov eax, [r12 + ST_GLOBAL_STEP]
    mov [r12 + ST_GOAL_STEP], eax

    lea rdi, [rel drive_trigger]
    call print_cstr
    lea rdi, [rel drive_nov_trig]
    call print_cstr

    ; Action: restructure dispatch tree (reorder)
    call modify_restructure

    mov edi, HOOK_ON_DRIVE
    mov esi, DRIVE_NOVELTY
    call fire_hook

.check_coherence:
    ; --- Drive 3: Coherence ---
    ; If VSA and dispatch disagree often → alignment pass
    movss xmm0, [r12 + ST_DRIVES + 12]
    mov eax, [r12 + ST_DRIVE_THRESH + 12]
    movd xmm1, eax
    comiss xmm0, xmm1
    ja .drives_done

    ; TRIGGER: Coherence too low
    mov dword [r12 + ST_CURRENT_GOAL], GOAL_ALIGN
    mov eax, [r12 + ST_GLOBAL_STEP]
    mov [r12 + ST_GOAL_STEP], eax

    lea rdi, [rel drive_trigger]
    call print_cstr
    lea rdi, [rel drive_coh_trig]
    call print_cstr

    mov edi, HOOK_ON_DRIVE
    mov esi, DRIVE_COHERENCE
    call fire_hook

.drives_done:
    ; --- Select dispatch mode based on drive state ---
    ; Default: FAST
    mov dword [r12 + ST_DISPATCH_MODE], DMODE_FAST

    ; If accuracy is below threshold → EXPLORE mode
    movss xmm0, [r12 + ST_DRIVES + 0]
    mov eax, [r12 + ST_DRIVE_THRESH + 0]
    movd xmm1, eax
    comiss xmm0, xmm1
    ja .mode_not_explore
    mov dword [r12 + ST_DISPATCH_MODE], DMODE_EXPLORE
    jmp .mode_set
.mode_not_explore:
    ; If accuracy > 0.7 and efficiency OK → BEST mode
    mov eax, 0x3F333333        ; 0.7f
    movd xmm1, eax
    comiss xmm0, xmm1
    jbe .mode_set
    movss xmm0, [r12 + ST_DRIVES + 4]
    mov eax, [r12 + ST_DRIVE_THRESH + 4]
    movd xmm1, eax
    comiss xmm0, xmm1
    ja .mode_set               ; efficiency too high, stay FAST
    mov dword [r12 + ST_DISPATCH_MODE], DMODE_BEST
.mode_set:

    pop r12
    pop rbx
    ret

;; ============================================================
;; drives_show
;; Print current drive levels and thresholds
;; ============================================================
global drives_show
drives_show:
    push rbx
    mov rbx, SURFACE_BASE

    lea rdi, [rel drive_hdr]
    call print_cstr

    ; Accuracy
    lea rdi, [rel drive_acc_lbl]
    call print_cstr
    movss xmm0, [rbx + STATE_OFFSET + ST_DRIVES + 0]
    call print_f32
    lea rdi, [rel drive_thresh]
    call print_cstr
    movss xmm0, [rbx + STATE_OFFSET + ST_DRIVE_THRESH + 0]
    call print_f32
    lea rdi, [rel drive_close]
    call print_cstr

    ; Efficiency
    lea rdi, [rel drive_eff_lbl]
    call print_cstr
    movss xmm0, [rbx + STATE_OFFSET + ST_DRIVES + 4]
    call print_f32
    lea rdi, [rel drive_thresh]
    call print_cstr
    movss xmm0, [rbx + STATE_OFFSET + ST_DRIVE_THRESH + 4]
    call print_f32
    lea rdi, [rel drive_close]
    call print_cstr

    ; Novelty
    lea rdi, [rel drive_nov_lbl]
    call print_cstr
    movss xmm0, [rbx + STATE_OFFSET + ST_DRIVES + 8]
    call print_f32
    lea rdi, [rel drive_thresh]
    call print_cstr
    movss xmm0, [rbx + STATE_OFFSET + ST_DRIVE_THRESH + 8]
    call print_f32
    lea rdi, [rel drive_close]
    call print_cstr

    ; Coherence
    lea rdi, [rel drive_coh_lbl]
    call print_cstr
    movss xmm0, [rbx + STATE_OFFSET + ST_DRIVES + 12]
    call print_f32
    lea rdi, [rel drive_thresh]
    call print_cstr
    movss xmm0, [rbx + STATE_OFFSET + ST_DRIVE_THRESH + 12]
    call print_f32
    lea rdi, [rel drive_close]
    call print_cstr

    pop rbx
    ret

;; ============================================================
;; drives_set_threshold(drive_id, value)
;; edi=drive index (0-3), xmm0=new threshold (f32)
;; ============================================================
global drives_set_threshold
drives_set_threshold:
    cmp edi, 4
    jge .done
    mov rax, SURFACE_BASE
    lea rax, [rax + STATE_OFFSET + ST_DRIVE_THRESH]
    movss [rax + rdi * 4], xmm0
.done:
    ret
; emit.asm — Code emission: write x86 dispatch patterns to surface
;
; ENTRY POINTS:
;   emit_dispatch_pattern(ctx_hash, token, birth_step) → rax=region_ptr
;   emit_resonant_pattern(ctx_hash, token, birth_step) → holo-enhanced pattern
;   emit_call_rel32(dest, target)  - write CALL rel32 at dest
;   emit_nop_sled(dest, len)       - write NOP padding
;   emit_ret(dest), emit_int3(dest) - single-byte instructions
;   emit_cmp_eax_imm32, emit_jne_rel8, emit_mov_eax_imm32, emit_xor_eax_eax
;
; EMITTED PATTERN STRUCTURE (23 bytes):
;   cmp eax, <ctx_hash>    ; 5B - check context match
;   jne .skip              ; 2B - skip if no match
;   inc [header+0]         ; 7B - increment hit counter
;   mov eax, <token>       ; 5B - return predicted token
;   ret                    ; 1B
;   .skip: xor eax,eax     ; 2B - no prediction
;   ret                    ; 1B
;
; CALLS OUT TO:
;   surface.asm: region_alloc(), wire_new_region()
;   verify.asm:  verify_modification()
;   receipt.asm: emit_receipt_full()
;   vsa.asm:     holo_gen_vec(), holo_superpose_f64()
;
%include "syscalls.inc"
%include "constants.inc"

section .data
    emit_msg:       db "[EMIT] New pattern at 0x", 0
    emit_ctx_msg:   db " ctx=0x", 0
    emit_tok_msg:   db " tok=0x", 0
    emit_nl:        db 10, 0
    emit_res_msg:   db "[EMIT] Resonant pattern at 0x", 0

section .text

extern print_cstr
extern print_hex32
extern print_hex64
extern print_newline
extern region_alloc
extern fire_hook
extern wire_new_region
extern journey_step
extern sym_observe_mod
extern verify_modification
extern region_condemn
extern emit_receipt_simple
extern emit_receipt_full
extern holo_gen_vec
extern holo_dot_f64
extern holo_superpose_f64

;; ============================================================
;; emit_dispatch_pattern(ctx_hash_32, token_id, birth_step)
;; edi=context hash (32-bit), esi=predicted token_id, edx=birth_step
;; Emits a new dispatch region:
;;   cmp eax, <ctx_hash>       ; 5 bytes (3D imm32)
;;   jne .skip                  ; 2 bytes (75 xx)
;;   inc dword [header+0]      ; 7 bytes (FF 05 rel32)... simplified
;;   mov eax, <token_id>       ; 5 bytes (B8 imm32)
;;   ret                        ; 1 byte  (C3)
;;   .skip:
;;   xor eax, eax              ; 2 bytes (31 C0)
;;   ret                        ; 1 byte  (C3)
;; Total: 23 bytes
;; Returns: rax = ptr to new region header
;; ============================================================
global emit_dispatch_pattern
emit_dispatch_pattern:
    push rbx
    push r12
    push r13
    push r14

    mov r12d, edi             ; ctx_hash
    mov r13d, esi             ; token_id
    mov r14d, edx             ; birth_step

    ; JOURNEY: record emit_dispatch_pattern
    push r12
    push r13
    mov edi, TRACE_EMIT_DISPATCH_PATTERN
    call journey_step
    pop r13
    pop r12

    ; Allocate region: 17 bytes of code
    mov rdi, 17               ; code size
    mov rsi, RTYPE_DISPATCH   ; type
    mov edx, r14d             ; birth step
    call region_alloc
    mov rbx, rax              ; header ptr

    ; Symbolic observation: log this modification
    lea rdi, [rbx + RHDR_SIZE]  ; code address
    mov rsi, 17                  ; size
    xor edx, edx                 ; type 0 = emit
    mov rcx, SURFACE_BASE
    mov ecx, [rcx + STATE_OFFSET + ST_GLOBAL_STEP]
    call sym_observe_mod
    ; Note: we proceed even if blocked - observer, not gatekeeper

    ; Now write the code at rbx + RHDR_SIZE
    lea rdi, [rbx + RHDR_SIZE]

    ; Byte 0-4: cmp eax, imm32 (opcode 3D)
    mov byte [rdi + 0], 0x3D
    mov [rdi + 1], r12d       ; ctx_hash immediate

    ; Byte 5-6: jne .skip (+15 bytes forward: skip over inc+mov+ret = 13 bytes)
    mov byte [rdi + 5], 0x75
    mov byte [rdi + 6], 13    ; jump offset to .skip

    ; Byte 7-13: inc dword [rbx + RHDR_HITS] — use absolute addressing
    ; Actually, use a simpler approach: inc dword [rip + offset]
    ; For simplicity, use: push rcx; mov rcx, header_addr; inc dword [rcx]; pop rcx
    ; That's too long. Instead, just skip the inc for now and rely on dispatch_predict
    ; to do the counting. Use the space for a NOP sled + mov + ret.
    ;
    ; Revised layout (23 bytes):
    ;   0-4:   cmp eax, imm32      (5)
    ;   5-6:   jne +11              (2)  → jumps to byte 18
    ;   7-11:  mov eax, imm32      (5)  predicted token
    ;   12:    nop                   (1)  padding
    ;   13-17: nop x5               (5)  padding for future inc
    ;   18-19: xor eax, eax        (2)  miss path
    ;   20:    ret                   (1)
    ;   Total = 21... let me redo this properly.
    ;
    ; Clean layout (20 bytes):
    ;   0-4:   cmp eax, <ctx>       (5)  3D xx xx xx xx
    ;   5-6:   jne +8               (2)  75 08
    ;   7-11:  mov eax, <tok>       (5)  B8 xx xx xx xx
    ;   12:    ret                   (1)  C3
    ;   13:    nop                   (1)  90 (alignment)
    ;   14-15: xor eax, eax         (2)  31 C0
    ;   16:    ret                   (1)  C3
    ; Total: 17 bytes. Let's use 20 with padding.

    ; Actually let me just emit a clean 17-byte pattern:
    ; Reset the region header code_len
    mov word [rbx + RHDR_CODE_LEN], 17

    ; cmp eax, ctx_hash
    mov byte [rdi + 0], 0x3D
    mov [rdi + 1], r12d

    ; jne +6 (skip mov+ret, land on xor at offset 13)
    mov byte [rdi + 5], 0x75
    mov byte [rdi + 6], 6     ; +6 lands at offset 13 (7+6=13)

    ; mov eax, token_id (hit path)
    mov byte [rdi + 7], 0xB8
    mov [rdi + 8], r13d

    ; ret (hit path returns)
    mov byte [rdi + 12], 0xC3

    ; xor eax, eax (miss path: no prediction)
    mov byte [rdi + 13], 0x31
    mov byte [rdi + 14], 0xC0

    ; ret (miss path)
    mov byte [rdi + 15], 0xC3

    ; NOP padding to 17
    mov byte [rdi + 16], 0x90

    ; === VERIFY EMITTED CODE (brittleness protection) ===
    lea rdi, [rbx + RHDR_SIZE]    ; code address
    mov rsi, 17                    ; code size
    call verify_modification
    test eax, eax
    jnz .verify_passed
    ; Verification failed - condemn this region
    mov rdi, rbx
    call region_condemn
    xor eax, eax                   ; return NULL
    jmp .emit_done
.verify_passed:

    ; === EMIT RECEIPT: EVENT_EMIT (with region and emit address) ===
    push rbx
    push r12
    push r13
    mov edi, EVENT_EMIT               ; event_type
    mov esi, r12d                     ; ctx_hash
    mov edx, r13d                     ; actual_token
    xor ecx, ecx                      ; predicted = 0
    ; Hash the region pointer
    mov rax, rbx
    shr rax, 4
    mov r8d, eax                      ; region_hash
    ; Use emit address (rbx + RHDR_SIZE) as aux
    lea rax, [rbx + RHDR_SIZE]
    shr rax, 4
    mov r9d, eax                      ; aux = emit_addr_hash
    mov eax, 0x3F800000               ; 1.0f confidence
    movd xmm0, eax
    xorpd xmm1, xmm1                  ; valence = 0
    call emit_receipt_full
    pop r13
    pop r12
    pop rbx

    ; Print emission info
    push rbx
    lea rdi, [rel emit_msg]
    call print_cstr
    lea rdi, [rbx + RHDR_SIZE]
    call print_hex64

    lea rdi, [rel emit_ctx_msg]
    call print_cstr
    mov edi, r12d
    call print_hex32

    lea rdi, [rel emit_tok_msg]
    call print_cstr
    mov edi, r13d
    call print_hex32
    call print_newline
    pop rbx

    ; Fire emit hook
    mov edi, HOOK_ON_EMIT
    mov esi, r12d
    call fire_hook

    ; Wire new region into connectivity graph
    mov rdi, rbx              ; header ptr
    mov esi, r13d             ; token_id (for finding same-token regions)
    call wire_new_region

    ; === Holographic suffix detection ===
    ; Hash suffix → generate vector via holo_gen_vec → query trace → if resonance, signal factoring
    movzx ecx, word [rbx + RHDR_CODE_LEN]
    cmp ecx, SUFFIX_HASH_LEN
    jl .no_suffix_detect

    ; Hash last SUFFIX_HASH_LEN bytes
    lea rdi, [rbx + RHDR_SIZE]
    add rdi, rcx
    sub rdi, SUFFIX_HASH_LEN
    xor eax, eax
    mov ecx, SUFFIX_HASH_LEN
.hash_suffix:
    imul eax, eax, 31
    movzx edx, byte [rdi]
    add eax, edx
    inc rdi
    dec ecx
    jnz .hash_suffix
    ; eax = suffix hash

    ; Allocate temp vector on stack for suffix vector (HOLO_VEC_BYTES = 8192)
    push rbx
    sub rsp, HOLO_VEC_BYTES
    mov r14, rsp              ; r14 = suffix vector (on stack)

    ; Generate suffix vector using holo_gen_vec (handles arbitrary hashes correctly)
    mov edi, eax              ; suffix hash
    mov rsi, r14              ; output = stack vector
    call holo_gen_vec

    ; Get suffix trace address
    ; NOTE: Cannot do "add rdi, HOLO_OFFSET" - 0xC0000000 sign-extends to negative!
    ; Use single 64-bit immediate to avoid sign-extension bug.
    mov rdi, SURFACE_BASE + HOLO_OFFSET + (SUFFIX_TRACE_IDX * HOLO_VEC_BYTES)

    ; Query: dot product for similarity
    push rdi                  ; save trace addr
    mov rsi, r14              ; suffix vec (on stack)
    call holo_dot_f64         ; xmm0 = similarity

    ; Check threshold (0.7 f64)
    mov rax, 0x3FE6666666666666
    movq xmm1, rax
    ucomisd xmm0, xmm1
    jb .no_resonance

    ; Resonance detected - increment pending factor count
    mov rdi, SURFACE_BASE
    inc dword [rdi + STATE_OFFSET + ST_FACTOR_PENDING]

.no_resonance:
    ; Superpose suffix vec into trace (accumulate for future resonance detection)
    pop rdi                   ; trace addr
    mov rsi, r14              ; suffix vec (on stack)
    call holo_superpose_f64

    ; Clean up stack
    add rsp, HOLO_VEC_BYTES
    pop rbx

.no_suffix_detect:
    mov rax, rbx              ; return header ptr
.emit_done:
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; emit_call_rel32(ptr, target)
;; Writes a CALL rel32 instruction at ptr targeting a subroutine.
;; rdi = destination pointer (where to write CALL)
;; rsi = absolute target address
;; Returns: eax = bytes written (5)
;;
;; Instruction: E8 rel32
;; rel32 = target - (current + 5)
;;
;; This enables recursive schema hierarchy: regions can CALL
;; shared subroutines for code reuse.
;; ============================================================
global emit_call_rel32
emit_call_rel32:
    ; Compute relative offset
    lea rax, [rdi + 5]          ; address after CALL instruction
    sub rsi, rax                ; rel32 = target - (current + 5)

    ; Write CALL opcode
    mov byte [rdi], 0xE8

    ; Write 32-bit relative offset
    mov [rdi + 1], esi

    mov eax, 5
    ret

;; ============================================================
;; emit_nop_sled(ptr, count)
;; rdi=destination, esi=byte count
;; Fills with NOP (0x90)
;; ============================================================
global emit_nop_sled
emit_nop_sled:
    movzx ecx, si
.nop_loop:
    test ecx, ecx
    jz .nop_done
    mov byte [rdi], 0x90
    inc rdi
    dec ecx
    jmp .nop_loop
.nop_done:
    ret

;; ============================================================
;; emit_ret(ptr)
;; Writes a RET instruction at ptr
;; ============================================================
global emit_ret
emit_ret:
    mov byte [rdi], 0xC3
    ret

;; ============================================================
;; emit_int3(ptr)
;; Writes INT3 (breakpoint/trap) at ptr
;; ============================================================
global emit_int3
emit_int3:
    mov byte [rdi], 0xCC
    ret

;; ============================================================
;; emit_cmp_eax_imm32(ptr, imm32) → bytes written (5)
;; rdi=dest, esi=immediate
;; ============================================================
global emit_cmp_eax_imm32
emit_cmp_eax_imm32:
    mov byte [rdi], 0x3D
    mov [rdi + 1], esi
    mov eax, 5
    ret

;; ============================================================
;; emit_jne_rel8(ptr, offset) → bytes written (2)
;; rdi=dest, sil=relative offset
;; ============================================================
global emit_jne_rel8
emit_jne_rel8:
    mov byte [rdi], 0x75
    mov [rdi + 1], sil
    mov eax, 2
    ret

;; ============================================================
;; emit_mov_eax_imm32(ptr, imm32) → bytes written (5)
;; rdi=dest, esi=immediate
;; ============================================================
global emit_mov_eax_imm32
emit_mov_eax_imm32:
    mov byte [rdi], 0xB8
    mov [rdi + 1], esi
    mov eax, 5
    ret

;; ============================================================
;; emit_xor_eax_eax(ptr) → bytes written (2)
;; ============================================================
global emit_xor_eax_eax
emit_xor_eax_eax:
    mov byte [rdi], 0x31
    mov byte [rdi + 1], 0xC0
    mov eax, 2
    ret

;; ============================================================
;; emit_resonant_pattern(ctx_hash_32, token_id, birth_step)
;; edi=expected context hash (32-bit), esi=predicted token_id, edx=birth_step
;;
;; Emits a new RESONANT dispatch region for fuzzy matching:
;; Unlike exact dispatch patterns (CMP EAX, imm32), resonant regions
;; store the expected context hash for vector generation and matching
;; via cosine similarity in VSA space.
;;
;; Code layout (11 bytes):
;;   [0-4]:   MOV EAX, <ctx_hash>      ; B8 xx xx xx xx (stores expected ctx)
;;   [5-9]:   MOV EAX, <token_id>      ; B8 xx xx xx xx (predicted token)
;;   [10]:    RET                       ; C3
;;
;; The first MOV stores the expected context hash (not executed directly).
;; dispatch_predict() calls resonant_match() which extracts this hash,
;; generates VSA vectors, and computes similarity.
;;
;; Returns: rax = ptr to new region header
;; ============================================================
global emit_resonant_pattern
emit_resonant_pattern:
    push rbx
    push r12
    push r13
    push r14

    mov r12d, edi             ; ctx_hash
    mov r13d, esi             ; token_id
    mov r14d, edx             ; birth_step

    ; JOURNEY: record emit_resonant_pattern (reuse emit dispatch trace ID)
    push r12
    push r13
    mov edi, TRACE_EMIT_DISPATCH_PATTERN
    call journey_step
    pop r13
    pop r12

    ; Allocate region: 11 bytes of code, RTYPE_RESONANT
    mov rdi, 11               ; code size
    mov rsi, RTYPE_RESONANT   ; type = resonant (fuzzy matching)
    mov edx, r14d             ; birth step
    call region_alloc
    mov rbx, rax              ; header ptr

    ; Symbolic observation: log this modification
    lea rdi, [rbx + RHDR_SIZE]  ; code address
    mov rsi, 11                  ; size
    mov edx, 1                   ; type 1 = resonant emit
    mov rcx, SURFACE_BASE
    mov ecx, [rcx + STATE_OFFSET + ST_GLOBAL_STEP]
    call sym_observe_mod

    ; Now write the code at rbx + RHDR_SIZE
    lea rdi, [rbx + RHDR_SIZE]

    ; Byte 0-4: MOV EAX, ctx_hash (stores expected context for VSA)
    mov byte [rdi + 0], 0xB8
    mov [rdi + 1], r12d       ; expected ctx_hash

    ; Byte 5-9: MOV EAX, token_id (predicted token)
    mov byte [rdi + 5], 0xB8
    mov [rdi + 6], r13d       ; token_id

    ; Byte 10: RET
    mov byte [rdi + 10], 0xC3

    ; Update code length in header
    mov word [rbx + RHDR_CODE_LEN], 11

    ; Print emission info
    push rbx
    lea rdi, [rel emit_res_msg]
    call print_cstr
    lea rdi, [rbx + RHDR_SIZE]
    call print_hex64

    lea rdi, [rel emit_ctx_msg]
    call print_cstr
    mov edi, r12d
    call print_hex32

    lea rdi, [rel emit_tok_msg]
    call print_cstr
    mov edi, r13d
    call print_hex32
    call print_newline
    pop rbx

    ; Fire emit hook
    mov edi, HOOK_ON_EMIT
    mov esi, r12d
    call fire_hook

    ; Wire new region into connectivity graph
    mov rdi, rbx              ; header ptr
    mov esi, r13d             ; token_id (for finding same-token regions)
    call wire_new_region

    mov rax, rbx              ; return header ptr
    pop r14
    pop r13
    pop r12
    pop rbx
    ret
; evolve.asm — Genetic evolution: reproduce, mutate, crossover regions
;
; ENTRY POINTS:
;   evolve_cycle()                    - full evolution pass (select → reproduce → mutate)
;   evolve_reproduce(region_idx)      - copy region with small mutation
;   evolve_mutate(region_idx)         - apply random mutation to region
;   evolve_crossover(idx1, idx2)      - combine two parent regions
;   evolve_from_gene_pool()           - resurrect patterns from gene pool
;
; SELECTION:
;   Fitness = hits / (hits + misses) - regions sorted by fitness
;   Top EVOLVE_POOL_SIZE regions selected for reproduction
;
; MUTATION TYPES:
;   - Context hash bit flip (broaden/narrow matching)
;   - Token substitution (predict different outcome)
;   - Structure modification (via gate_test_modification)
;
; CALLS OUT TO:
;   genes.asm:   gene_pool_sample() for resurrection
;   emit.asm:    emit_dispatch_pattern() for new offspring
;   gate.asm:    gate_test_modification() to validate mutations
;   hooks.asm:   fire_hook(HOOK_EVOLVE)
;
; CALLED BY: introspect.asm (update_organic_pressure when stagnation detected)
;
%include "syscalls.inc"
%include "constants.inc"

section .data
    evolve_msg:     db "[EVOLVE] ", 0
    reproduce_msg:  db "Reproducing region ", 0
    mutate_msg:     db "Mutating region ", 0
    crossover_msg:  db "Crossover regions ", 0
    evolve_and:     db " × ", 0
    evolve_nl:      db 10, 0
    evolve_done:    db "[EVOLVE] Cycle complete", 10, 0
    evolve_gene_msg: db "Resurrecting from gene pool: ctx=0x", 0
    evolve_tok_msg:  db " token=0x", 0

section .text

extern print_cstr
extern print_u64
extern print_hex32
extern print_newline
extern region_alloc
extern emit_dispatch_pattern
extern fire_hook
extern sys_getrandom
extern gate_test_modification
extern sym_observe_mod
extern sym_record_anomaly
extern gene_pool_sample
extern receipt_resonate
extern emit_receipt_simple

;; ============================================================
;; evolve_cycle
;; One evolution cycle:
;; 1. Select top-N regions by fitness (hits / (hits + misses))
;; 2. Reproduce (copy with small mutation)
;; 3. Optionally crossover two parents
;; ============================================================
global evolve_cycle
evolve_cycle:
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub rsp, EVOLVE_POOL_SIZE * 16  ; pool: (index:u32, fitness:f32) × N

    mov rbx, SURFACE_BASE

    ; --- Metabolic cost: evolution is expensive ---
    movsd xmm0, [rbx + STATE_OFFSET + ST_ENERGY]
    mov rax, ENERGY_STARVATION
    movq xmm1, rax
    ucomisd xmm0, xmm1
    jbe .evolve_exit           ; too hungry to evolve
    mov rax, ENERGY_EVOLVE_COST
    movq xmm1, rax
    subsd xmm0, xmm1
    xorpd xmm2, xmm2
    maxsd xmm0, xmm2
    movsd [rbx + STATE_OFFSET + ST_ENERGY], xmm0
    addsd xmm1, [rbx + STATE_OFFSET + ST_ENERGY_SPENT]
    movsd [rbx + STATE_OFFSET + ST_ENERGY_SPENT], xmm1

    ; --- Select candidates by FITNESS (accuracy × diversity) ---
    lea r12, [rbx + REGION_TABLE_OFFSET]
    lea rax, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    mov r13d, [rax]

    xor r14d, r14d            ; pool count
    xor ecx, ecx             ; scan index

.select_loop:
    cmp ecx, r13d
    jge .select_done
    cmp r14d, EVOLVE_POOL_SIZE
    jge .select_done

    push rcx
    imul rdi, rcx, RTE_SIZE
    add rdi, r12

    ; Only DISPATCH, ACTIVE, not CONDEMNED
    movzx eax, word [rdi + RTE_TYPE]
    cmp eax, RTYPE_DISPATCH
    jne .skip_select
    movzx eax, word [rdi + RTE_FLAGS]
    test eax, RFLAG_CONDEMNED
    jnz .skip_select
    test eax, RFLAG_ACTIVE
    jz .skip_select

    ; Must have data (hits + misses > 2)
    mov eax, [rdi + RTE_HITS]
    mov edx, [rdi + RTE_MISSES]
    add edx, eax
    cmp edx, 2
    jl .skip_select

    ; Compute fitness = accuracy * (1 + log2(hits))
    ; accuracy = hits / (hits + misses)
    cvtsi2ss xmm0, eax       ; hits
    cvtsi2ss xmm1, edx       ; total
    divss xmm0, xmm1         ; accuracy

    ; Diversity bonus: regions with unique contexts score higher
    ; Simple: use resonance field (co-fire correlation) as diversity indicator
    mov rsi, [rdi + RTE_ADDR]
    movsd xmm2, [rsi + RHDR_RESONANCE]
    cvtsd2ss xmm2, xmm2
    mov edx, 0x3F800000       ; 1.0f
    movd xmm3, edx
    addss xmm2, xmm3         ; 1.0 + resonance
    mulss xmm0, xmm2         ; fitness = accuracy * (1 + resonance)

    ; --- RESONANCE QUERY: Boost fitness if similar evolved patterns succeeded ---
    ; Query past EVOLVE events for similar contexts
    push rdi
    push rsi
    push rcx
    sub rsp, 8
    movss [rsp], xmm0        ; save fitness
    cmp byte [rsi + RHDR_SIZE], 0x3D
    jne .evolve_no_resonate
    mov edi, EVENT_EVOLVE
    mov esi, [rsi + RHDR_SIZE + 1]  ; ctx_hash from region
    xor edx, edx
    call receipt_resonate    ; → xmm0 = similarity to past EVOLVEs
    ; If high similarity (>0.5), check if those led to HITs
    mov rax, 0x3FE0000000000000     ; 0.5 f64
    movq xmm1, rax
    ucomisd xmm0, xmm1
    jbe .evolve_no_resonate
    ; Query for subsequent HITs
    mov edi, EVENT_HIT
    add rsp, 8
    pop rcx
    pop rsi
    push rsi
    push rcx
    sub rsp, 8
    mov esi, [rsi + RHDR_SIZE + 1]
    xor edx, edx
    call receipt_resonate    ; → xmm0 = HIT similarity
    ; Boost fitness by (1 + 0.3 * hit_similarity)
    cvtsd2ss xmm0, xmm0      ; convert to f32
    mov eax, 0x3E99999A      ; 0.3f
    movd xmm1, eax
    mulss xmm0, xmm1         ; 0.3 * hit_sim
    mov eax, 0x3F800000      ; 1.0f
    movd xmm1, eax
    addss xmm0, xmm1         ; 1 + 0.3 * hit_sim
    movss xmm2, [rsp]        ; restore fitness
    mulss xmm0, xmm2         ; fitness *= (1 + 0.3 * hit_sim)
    movss [rsp], xmm0        ; save boosted fitness
.evolve_no_resonate:
    movss xmm0, [rsp]        ; restore fitness
    add rsp, 8
    pop rcx
    pop rsi
    pop rdi

    ; Add to pool with fitness score
    pop rcx
    push rcx
    imul eax, r14d, 16
    mov [rsp + 8 + rax], ecx           ; index
    movss [rsp + 8 + rax + 4], xmm0   ; fitness
    inc r14d

.skip_select:
    pop rcx
    inc ecx
    jmp .select_loop

.select_done:
    ; Need at least 1 candidate
    test r14d, r14d
    jz .evolve_exit

    ; --- Sort pool by fitness (simple insertion for small N) ---
    ; Find best fitness entry, use as first candidate
    xor ecx, ecx
    xor edx, edx              ; best_idx
    movss xmm0, [rsp + 4]    ; best_fitness = pool[0].fitness
    mov esi, 1
.sort_loop:
    cmp esi, r14d
    jge .sort_done
    imul eax, esi, 16
    movss xmm1, [rsp + rax + 4]
    comiss xmm1, xmm0
    jbe .sort_next
    movss xmm0, xmm1
    mov edx, esi
.sort_next:
    inc esi
    jmp .sort_loop
.sort_done:
    ; edx = index of best candidate in pool
    mov r15d, edx              ; save best_idx in callee-saved register

    ; --- Reproduce best candidate ---
    imul eax, r15d, 16
    mov ecx, [rsp + rax]      ; best candidate's region index
    mov edi, ecx
    call evolve_reproduce

    ; --- Mutate second-best if available ---
    cmp r14d, 2
    jl .no_mutate
    ; Find second-best (first entry that's not the best)
    xor esi, esi
    cmp esi, r15d
    jne .got_second
    mov esi, 1
.got_second:
    imul eax, esi, 16
    mov ecx, [rsp + rax]
    mov edi, ecx
    call evolve_mutate
.no_mutate:

    ; --- Crossover if 2+ candidates ---
    cmp r14d, 2
    jl .no_crossover
    imul eax, r15d, 16
    mov edi, [rsp + rax]      ; parent A (best)
    xor esi, esi
    cmp esi, r15d
    jne .cross_b
    mov esi, 1
.cross_b:
    imul eax, esi, 16
    mov esi, [rsp + rax]      ; parent B (second)
    call evolve_crossover
.no_crossover:

    ; --- Resurrect from gene pool (composted knowledge) ---
    ; Sample a proven pattern from the gene pool and recreate it
    call evolve_from_gene_pool

    lea rdi, [rel evolve_done]
    call print_cstr

    ; Fire evolve hook
    mov edi, HOOK_ON_EVOLVE
    xor esi, esi
    call fire_hook

.evolve_exit:
    add rsp, EVOLVE_POOL_SIZE * 16
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; evolve_reproduce(region_index)
;; edi=index of region to reproduce
;; Creates a copy with same ctx/token (exact duplicate)
;; ============================================================
global evolve_reproduce
evolve_reproduce:
    push rbx
    push r12

    mov r12d, edi
    mov rbx, SURFACE_BASE

    ; Print
    push r12
    lea rdi, [rel evolve_msg]
    call print_cstr
    lea rdi, [rel reproduce_msg]
    call print_cstr
    movzx rdi, r12w
    call print_u64
    call print_newline
    pop r12

    ; Get source region's ctx and token
    lea rax, [rbx + REGION_TABLE_OFFSET]
    imul rcx, r12, RTE_SIZE
    add rax, rcx
    mov rsi, [rax + RTE_ADDR]  ; header ptr

    ; Read ctx from cmp instruction
    cmp byte [rsi + RHDR_SIZE], 0x3D
    jne .done
    mov edi, [rsi + RHDR_SIZE + 1]   ; ctx_hash
    mov esi, [rsi + RHDR_SIZE + 8]   ; token_id (from mov eax, imm32)

    ; Save ctx and token for receipt
    push rdi
    push rsi

    ; Emit as new region (duplicate)
    lea rax, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    mov edx, [rax]
    call emit_dispatch_pattern

    ; === EMIT RECEIPT: EVENT_EVOLVE ===
    pop rsi                   ; token_id
    pop rdi                   ; ctx_hash
    push rdi
    push rsi
    mov edx, esi              ; token_id
    mov esi, edi              ; ctx_hash
    mov edi, EVENT_EVOLVE     ; event_type
    mov eax, 0x3F800000       ; 1.0f confidence
    movd xmm0, eax
    call emit_receipt_simple
    pop rsi
    pop rdi

.done:
    pop r12
    pop rbx
    ret

;; ============================================================
;; evolve_mutate(region_index)
;; edi=index
;; Creates a copy with slightly modified context hash
;; ============================================================
global evolve_mutate
evolve_mutate:
    push rbx
    push r12
    sub rsp, 8

    mov r12d, edi
    mov rbx, SURFACE_BASE

    ; Print
    push r12
    lea rdi, [rel evolve_msg]
    call print_cstr
    lea rdi, [rel mutate_msg]
    call print_cstr
    movzx rdi, r12w
    call print_u64
    call print_newline
    pop r12

    ; Get source region
    lea rax, [rbx + REGION_TABLE_OFFSET]
    imul rcx, r12, RTE_SIZE
    add rax, rcx
    mov rsi, [rax + RTE_ADDR]

    cmp byte [rsi + RHDR_SIZE], 0x3D
    jne .done

    mov edi, [rsi + RHDR_SIZE + 1]   ; ctx_hash
    mov r12d, [rsi + RHDR_SIZE + 8]  ; token_id

    ; Mutate: flip a random bit in the context hash
    lea rdi, [rsp]
    mov rsi, 4
    xor edx, edx
    mov rax, SYS_GETRANDOM
    syscall
    mov eax, [rsp]
    and eax, 0x1F             ; bit position 0-31
    mov ecx, eax
    mov eax, 1
    shl eax, cl               ; bit mask
    xor edi, eax              ; flip one bit in ctx_hash

    ; Keep same token prediction
    mov esi, r12d
    lea rax, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    mov edx, [rax]
    call emit_dispatch_pattern

.done:
    add rsp, 8
    pop r12
    pop rbx
    ret

;; ============================================================
;; evolve_crossover(index_a, index_b)
;; edi=parent A index, esi=parent B index
;; Creates offspring with A's context and B's token prediction
;; ============================================================
global evolve_crossover
evolve_crossover:
    push rbx
    push r12
    push r13

    mov r12d, edi             ; parent A
    mov r13d, esi             ; parent B

    mov rbx, SURFACE_BASE

    ; Print
    push r12
    push r13
    lea rdi, [rel evolve_msg]
    call print_cstr
    lea rdi, [rel crossover_msg]
    call print_cstr
    movzx rdi, r12w
    call print_u64
    lea rdi, [rel evolve_and]
    call print_cstr
    movzx rdi, r13w
    call print_u64
    call print_newline
    pop r13
    pop r12

    ; Get parent A's context
    lea rax, [rbx + REGION_TABLE_OFFSET]
    imul rcx, r12, RTE_SIZE
    add rax, rcx
    mov rsi, [rax + RTE_ADDR]
    cmp byte [rsi + RHDR_SIZE], 0x3D
    jne .done
    mov edi, [rsi + RHDR_SIZE + 1]   ; A's ctx_hash

    ; Get parent B's token
    lea rax, [rbx + REGION_TABLE_OFFSET]
    imul rcx, r13, RTE_SIZE
    add rax, rcx
    mov rsi, [rax + RTE_ADDR]
    cmp byte [rsi + RHDR_SIZE + 7], 0xB8
    jne .done
    mov esi, [rsi + RHDR_SIZE + 8]   ; B's token_id

    ; Emit offspring: A's context → B's prediction
    push rdi
    push rsi
    lea rax, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    mov edx, [rax]
    pop rsi
    pop rdi
    call emit_dispatch_pattern

.done:
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; evolve_from_gene_pool
;; Sample from the gene pool and resurrect a pattern
;; This recycles composted knowledge from condemned regions
;; ============================================================
global evolve_from_gene_pool
evolve_from_gene_pool:
    push rbx
    push r12
    push r13
    sub rsp, 8

    mov rbx, SURFACE_BASE

    ; Sample a gene from the pool
    call gene_pool_sample             ; → eax = ctx_hash, edx = token_id, xmm0 = fitness

    ; Check if we got a valid gene (ctx_hash != 0)
    test eax, eax
    jz .no_gene

    ; Save the gene data
    mov r12d, eax                     ; ctx_hash
    mov r13d, edx                     ; token_id

    ; Print resurrection message
    push r12
    push r13
    lea rdi, [rel evolve_msg]
    call print_cstr
    lea rdi, [rel evolve_gene_msg]
    call print_cstr
    mov edi, r12d
    call print_hex32
    lea rdi, [rel evolve_tok_msg]
    call print_cstr
    mov edi, r13d
    call print_hex32
    call print_newline
    pop r13
    pop r12

    ; Emit a new region from the gene
    mov edi, r12d                     ; ctx_hash
    mov esi, r13d                     ; token_id
    mov edx, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    call emit_dispatch_pattern

.no_gene:
    add rsp, 8
    pop r13
    pop r12
    pop rbx
    ret
; factor.asm — Subroutine extraction: find common suffixes, create shared code
;
; ENTRY POINTS:
;   factor_init()                       - init subroutine table
;   factor_suffix()                     - main: scan regions, extract shared suffixes
;   find_common_suffix(r1, r2)          → eax=common suffix length
;   emit_subroutine(code_ptr, len)      → rax=new RTYPE_SUBROUTINE region
;   rewrite_to_call(region, sub_addr)   - replace suffix with CALL
;   verify_valid_call(addr)             → eax=1 if addr points to valid sub
;   subroutines_show()                  - list all extracted subroutines
;   garbage_collect_subroutines()       - remove subroutines with 0 callers
;
; ALGORITHM (O(n) hash-based grouping):
;   1. Hash last 8 bytes of each region's code
;   2. Group regions by hash into suffix_registry
;   3. For each group with 2+ members, verify byte equality
;   4. Extract matching suffix as RTYPE_SUBROUTINE
;   5. Rewrite original regions to CALL the subroutine
;
; DATA STRUCTURES:
;   subroutine_table[64]:  16B each (addr, len, caller_count, code_hash)
;   suffix_registry[]:     hash + region_ptr pairs for O(1) grouping
;
; CALLED BY: dreams.asm (consolidation phase), repl.asm (factor command)
;
%include "syscalls.inc"
%include "constants.inc"

section .data
    factor_hdr:         db "[FACTOR] ", 0
    factor_scan:        db "Scanning for common suffixes...", 10, 0
    factor_found:       db "Found ", 0
    factor_regions:     db " regions with ", 0
    factor_byte_suffix: db "-byte common suffix", 10, 0
    factor_creating:    db "Creating subroutine at 0x", 0
    factor_rewriting:   db "Rewriting region ", 0
    factor_to_call:     db " to CALL 0x", 0
    factor_none:        db "No factoring opportunities found", 10, 0
    factor_nl:          db 10, 0
    sub_hdr:            db "--- Subroutines ---", 10, 0
    sub_entry:          db "  Sub ", 0
    sub_at:             db " at 0x", 0
    sub_callers:        db " callers=", 0
    sub_code_hash:      db " hash=0x", 0
    sub_none:           db "  (no subroutines)", 10, 0

section .bss
    ; Subroutine table: 64 entries, each 16 bytes
    subroutine_table:   resb SUBROUTINE_TABLE_MAX * SUBROUTINE_ENTRY_SIZE
    subroutine_count:   resd 1

    ; Suffix hash registry: (u32 hash, u64 region_ptr) = 16 bytes per entry (padded)
    ; This replaces O(n²) comparison with O(n) hash + group
    suffix_registry:    resb FACTOR_SCAN_LIMIT * 16  ; hash + ptr pairs
    suffix_reg_count:   resd 1                        ; entries in registry

    ; Suffix comparison buffer (for groups found by hash)
    suffix_candidates:  resq FACTOR_SCAN_LIMIT   ; pointers to candidate regions
    suffix_count:       resd 1                    ; number of candidates
    common_suffix_len:  resd 1                    ; detected common suffix length

section .text

extern print_cstr
extern print_hex32
extern print_hex64
extern print_u64
extern print_newline
extern region_alloc
extern region_find_by_addr

;; ============================================================
;; factor_init
;; Initialize the subroutine table
;; ============================================================
global factor_init
factor_init:
    xor eax, eax
    mov dword [rel subroutine_count], eax
    ; Zero the table
    lea rdi, [rel subroutine_table]
    mov ecx, SUBROUTINE_TABLE_MAX * SUBROUTINE_ENTRY_SIZE
.zero_loop:
    mov byte [rdi], 0
    inc rdi
    dec ecx
    jnz .zero_loop
    ret

;; ============================================================
;; hash_suffix(region_ptr) → eax = hash of last SUFFIX_HASH_LEN bytes
;; Computes a simple hash of the region's code suffix.
;; rdi = region header pointer
;; Returns: eax = 32-bit hash
;; ============================================================
hash_suffix:
    movzx ecx, word [rdi + RHDR_CODE_LEN]
    cmp ecx, SUFFIX_HASH_LEN
    jge .has_enough
    ; Code too short, use what we have
    jmp .hash_start
.has_enough:
    mov ecx, SUFFIX_HASH_LEN
.hash_start:
    ; Point to last 'ecx' bytes of code
    movzx eax, word [rdi + RHDR_CODE_LEN]
    sub eax, ecx
    lea rsi, [rdi + RHDR_SIZE]
    add rsi, rax              ; rsi = start of suffix

    ; Hash: h = h * 31 + byte
    xor eax, eax
.hash_loop:
    test ecx, ecx
    jz .hash_done
    imul eax, eax, 31
    movzx edx, byte [rsi]
    add eax, edx
    inc rsi
    dec ecx
    jmp .hash_loop
.hash_done:
    ret

;; ============================================================
;; find_common_suffix()
;; Scans active DISPATCH regions for common code endings.
;; Uses O(n) hash-based grouping instead of O(n²) comparison.
;;
;; Algorithm:
;;   1. Scan regions, compute suffix hash for each → O(n)
;;   2. Store (hash, region_ptr) in registry
;;   3. Sort registry by hash → O(n log n) but bounded by FACTOR_SCAN_LIMIT
;;   4. Find runs of same hash → O(n)
;;   5. Take largest run with >= SUFFIX_MIN_CALLERS
;;
;; Returns: eax = number of regions sharing a common suffix (0 = none)
;;          suffix_candidates[] filled with region pointers
;;          common_suffix_len set to SUFFIX_HASH_LEN (fixed)
;; ============================================================
global find_common_suffix
find_common_suffix:
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub rsp, 8          ; alignment

    mov rbx, SURFACE_BASE
    lea r12, [rbx + REGION_TABLE_OFFSET]
    mov r13d, [rbx + STATE_OFFSET + ST_REGION_COUNT]

    ; Clear buffers
    mov dword [rel suffix_count], 0
    mov dword [rel common_suffix_len], 0
    mov dword [rel suffix_reg_count], 0

    ; === Phase 1: Collect regions and compute suffix hashes → O(n) ===
    lea r14, [rel suffix_registry]
    xor ecx, ecx        ; region index
    xor r15d, r15d      ; registry count
.collect_loop:
    cmp ecx, r13d
    jge .collect_done
    cmp r15d, FACTOR_SCAN_LIMIT
    jge .collect_done

    push rcx
    imul rdi, rcx, RTE_SIZE
    add rdi, r12

    ; Check type and flags
    movzx eax, word [rdi + RTE_TYPE]
    cmp eax, RTYPE_DISPATCH
    jne .collect_next
    movzx eax, word [rdi + RTE_FLAGS]
    test eax, RFLAG_CONDEMNED
    jnz .collect_next

    ; Get region header pointer
    mov rsi, [rdi + RTE_ADDR]
    test rsi, rsi             ; null check - skip if RTE_ADDR is 0
    jz .collect_next
    movzx eax, word [rsi + RHDR_CODE_LEN]
    cmp eax, SUFFIX_MIN_LEN + 5     ; need enough code to factor
    jl .collect_next

    ; Compute suffix hash
    push rsi
    mov rdi, rsi
    call hash_suffix
    pop rsi
    ; eax = suffix hash, rsi = region ptr

    ; Store in registry: [hash(4) + padding(4) + ptr(8)] = 16 bytes
    imul edi, r15d, 16
    add rdi, r14
    mov [rdi + 0], eax            ; hash
    mov [rdi + 8], rsi            ; region ptr
    inc r15d

.collect_next:
    pop rcx
    inc ecx
    jmp .collect_loop

.collect_done:
    mov [rel suffix_reg_count], r15d

    ; Need at least SUFFIX_MIN_CALLERS regions to factor
    cmp r15d, SUFFIX_MIN_CALLERS
    jl .no_suffix

    ; === Phase 2: Sort registry by hash (insertion sort) → O(n²) worst but small n ===
    ; For FACTOR_SCAN_LIMIT entries, insertion sort is fine
    mov ecx, 1          ; i = 1
.sort_outer:
    cmp ecx, r15d
    jge .sort_done

    ; Load entry[i] into temp
    imul eax, ecx, 16
    add rax, r14
    mov r8d, [rax + 0]        ; temp_hash
    mov r9, [rax + 8]         ; temp_ptr

    mov edx, ecx              ; j = i
.sort_inner:
    test edx, edx
    jz .sort_insert

    ; Compare entry[j-1].hash with temp_hash
    lea eax, [edx - 1]
    imul eax, eax, 16
    add rax, r14
    mov r10d, [rax + 0]       ; entry[j-1].hash
    cmp r10d, r8d
    jle .sort_insert          ; entry[j-1] <= temp, done shifting

    ; Shift entry[j-1] to entry[j]
    imul edi, edx, 16
    add rdi, r14
    mov [rdi + 0], r10d
    mov r11, [rax + 8]
    mov [rdi + 8], r11

    dec edx
    jmp .sort_inner

.sort_insert:
    ; Insert temp at position j
    imul eax, edx, 16
    add rax, r14
    mov [rax + 0], r8d
    mov [rax + 8], r9

    inc ecx
    jmp .sort_outer

.sort_done:
    ; === Phase 3: Find largest run of same hash → O(n) ===
    xor ecx, ecx              ; current position
    xor r8d, r8d              ; best run start
    xor r9d, r9d              ; best run length

.find_runs:
    cmp ecx, r15d
    jge .runs_done

    ; Get current hash
    imul eax, ecx, 16
    add rax, r14
    mov r10d, [rax + 0]       ; current hash

    ; Count run length
    mov edx, ecx              ; run start
    mov r11d, 0               ; run length
.count_run:
    cmp edx, r15d
    jge .run_ended
    imul eax, edx, 16
    add rax, r14
    cmp [rax + 0], r10d
    jne .run_ended
    inc r11d
    inc edx
    jmp .count_run

.run_ended:
    ; Is this run better than best?
    cmp r11d, r9d
    jle .not_better
    mov r8d, ecx              ; best_start = run_start
    mov r9d, r11d             ; best_len = run_len
.not_better:
    mov ecx, edx              ; skip past this run
    jmp .find_runs

.runs_done:
    ; Check if best run meets minimum
    cmp r9d, SUFFIX_MIN_CALLERS
    jl .no_suffix

    ; === Phase 4: Copy best run to suffix_candidates ===
    lea rdi, [rel suffix_candidates]
    xor ecx, ecx
.copy_run:
    cmp ecx, r9d
    jge .copy_done

    ; Get region ptr from registry[best_start + i]
    lea eax, [r8d + ecx]
    imul eax, eax, 16
    add rax, r14
    mov rsi, [rax + 8]        ; region ptr
    mov [rdi + rcx * 8], rsi
    inc ecx
    jmp .copy_run

.copy_done:
    mov [rel suffix_count], r9d
    mov dword [rel common_suffix_len], SUFFIX_HASH_LEN
    mov eax, r9d
    jmp .done

.no_suffix:
    xor eax, eax

.done:
    add rsp, 8
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; emit_subroutine(suffix_ptr, suffix_len)
;; Creates a new RTYPE_SUBROUTINE region containing the given code.
;; rdi = pointer to suffix code bytes
;; esi = length of suffix
;; Returns: rax = pointer to new subroutine region header
;; ============================================================
global emit_subroutine
emit_subroutine:
    push rbx
    push r12
    push r13

    mov r12, rdi            ; suffix source
    mov r13d, esi           ; suffix length

    ; Allocate region for subroutine
    ; The subroutine code is just the suffix bytes (already ends with RET)
    mov rdi, r13            ; code size = suffix length
    mov rsi, RTYPE_SUBROUTINE
    mov rax, SURFACE_BASE
    mov edx, [rax + STATE_OFFSET + ST_GLOBAL_STEP]
    call region_alloc
    mov rbx, rax            ; save header ptr

    ; Copy suffix code into the new region
    lea rdi, [rbx + RHDR_SIZE]
    mov rsi, r12
    mov ecx, r13d
.copy_loop:
    test ecx, ecx
    jz .copy_done
    mov al, [rsi]
    mov [rdi], al
    inc rsi
    inc rdi
    dec ecx
    jmp .copy_loop
.copy_done:

    ; Register in subroutine table
    mov eax, [rel subroutine_count]
    cmp eax, SUBROUTINE_TABLE_MAX
    jge .table_full

    lea rdi, [rel subroutine_table]
    imul edx, eax, SUBROUTINE_ENTRY_SIZE
    add rdi, rdx

    mov [rdi + STE_PTR], rbx
    mov dword [rdi + STE_CALLER_COUNT], 0

    ; Compute simple hash of code for deduplication
    xor eax, eax
    lea rsi, [rbx + RHDR_SIZE]
    mov ecx, r13d
.hash_loop:
    test ecx, ecx
    jz .hash_done
    movzx edx, byte [rsi]
    imul eax, eax, 31
    add eax, edx
    inc rsi
    dec ecx
    jmp .hash_loop
.hash_done:
    mov [rdi + STE_CODE_HASH], eax

    inc dword [rel subroutine_count]

.table_full:
    ; Print creation message
    push rbx
    lea rdi, [rel factor_hdr]
    call print_cstr
    lea rdi, [rel factor_creating]
    call print_cstr
    mov rdi, rbx
    add rdi, RHDR_SIZE
    call print_hex64
    lea rdi, [rel factor_nl]
    call print_cstr
    pop rbx

    mov rax, rbx
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; rewrite_to_call(region_ptr, subroutine_ptr, suffix_len)
;; Rewrites a region to CALL the subroutine instead of having inline code.
;; rdi = region header to rewrite
;; rsi = subroutine to call
;; edx = suffix length (bytes to replace with CALL)
;; ============================================================
global rewrite_to_call
rewrite_to_call:
    push rbx
    push r12
    push r13
    push r14

    mov rbx, rdi            ; region header
    mov r12, rsi            ; subroutine header
    mov r13d, edx           ; suffix length

    ; Get current code length
    movzx r14d, word [rbx + RHDR_CODE_LEN]

    ; Compute where to insert CALL (replace last suffix_len bytes)
    ; New structure: original_prefix + CALL rel32 (5 bytes) + RET (1 byte)
    ; The subroutine handles the RET, so we need: prefix + CALL + RET

    ; Calculate offset where suffix starts (this is where we put CALL)
    mov eax, r14d
    sub eax, r13d           ; offset = code_len - suffix_len

    lea rdi, [rbx + RHDR_SIZE]
    add rdi, rax            ; point to where suffix was

    ; Write CALL rel32 instruction (E8 rel32)
    ; rel32 = target - (current + 5)
    ; target = subroutine_code = r12 + RHDR_SIZE
    lea rcx, [r12 + RHDR_SIZE]   ; call target
    lea rdx, [rdi + 5]           ; address after CALL instruction
    sub rcx, rdx                 ; relative offset

    mov byte [rdi], 0xE8         ; CALL opcode
    mov [rdi + 1], ecx           ; rel32 offset

    ; Write RET after CALL
    mov byte [rdi + 5], 0xC3

    ; Update code length: prefix_len + 6 (CALL + RET)
    mov eax, r14d
    sub eax, r13d
    add eax, 6
    mov word [rbx + RHDR_CODE_LEN], ax

    ; NOP out remaining bytes (if any) - only if new_len < old_len
    movzx ecx, word [rbx + RHDR_CODE_LEN]   ; new code length
    cmp r14d, ecx                            ; old_len >= new_len?
    jbe .nop_done                            ; skip if no bytes to NOP
    lea rsi, [rbx + RHDR_SIZE]
    add rsi, rcx                             ; point past new code
    mov edx, r14d
    sub edx, ecx                             ; bytes to NOP (old - new)
.nop_loop:
    test edx, edx
    jz .nop_done
    mov byte [rsi], 0x90
    inc rsi
    dec edx
    jmp .nop_loop
.nop_done:

    ; Increment caller count in subroutine table
    mov eax, [rel subroutine_count]
    lea rsi, [rel subroutine_table]
    xor ecx, ecx
.find_sub:
    cmp ecx, eax
    jge .sub_not_found
    imul edx, ecx, SUBROUTINE_ENTRY_SIZE
    cmp [rsi + rdx + STE_PTR], r12
    je .found_sub
    inc ecx
    jmp .find_sub
.found_sub:
    inc dword [rsi + rdx + STE_CALLER_COUNT]
.sub_not_found:

    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; factor_suffix()
;; Main factoring routine: finds common suffixes and creates subroutines.
;; Called from observe_cycle periodically.
;; Returns: eax = number of regions rewritten
;; ============================================================
global factor_suffix
factor_suffix:
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub rsp, 8

    ; Print scan message
    lea rdi, [rel factor_hdr]
    call print_cstr
    lea rdi, [rel factor_scan]
    call print_cstr

    ; Find common suffix
    call find_common_suffix
    test eax, eax
    jz .no_opportunities

    mov r14d, eax               ; number of candidates
    mov r15d, [rel common_suffix_len]

    ; Print findings
    lea rdi, [rel factor_hdr]
    call print_cstr
    lea rdi, [rel factor_found]
    call print_cstr
    mov edi, r14d
    call print_u64
    lea rdi, [rel factor_regions]
    call print_cstr
    mov edi, r15d
    call print_u64
    lea rdi, [rel factor_byte_suffix]
    call print_cstr

    ; Get the suffix from first candidate
    lea rbx, [rel suffix_candidates]
    mov r12, [rbx]              ; first candidate
    movzx eax, word [r12 + RHDR_CODE_LEN]
    sub eax, r15d               ; suffix starts at code_len - suffix_len
    lea rdi, [r12 + RHDR_SIZE]
    add rdi, rax                ; pointer to suffix bytes
    mov esi, r15d               ; suffix length

    ; Create the subroutine
    call emit_subroutine
    mov r13, rax                ; subroutine header

    ; Rewrite all candidates to call the subroutine
    xor r14d, r14d              ; rewritten count
    xor ecx, ecx
.rewrite_loop:
    cmp ecx, [rel suffix_count]
    jge .rewrite_done

    push rcx
    lea rbx, [rel suffix_candidates]
    mov rdi, [rbx + rcx * 8]    ; region to rewrite
    mov rsi, r13                ; subroutine
    mov edx, r15d               ; suffix length
    call rewrite_to_call
    inc r14d
    pop rcx

    inc ecx
    jmp .rewrite_loop

.rewrite_done:
    mov eax, r14d
    jmp .done

.no_opportunities:
    lea rdi, [rel factor_hdr]
    call print_cstr
    lea rdi, [rel factor_none]
    call print_cstr
    xor eax, eax

.done:
    add rsp, 8
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; verify_valid_call(call_target)
;; Checks if a CALL target is valid (points to a known subroutine).
;; rdi = absolute target address
;; Returns: eax = 1 if valid, 0 if invalid
;; ============================================================
global verify_valid_call
verify_valid_call:
    push rbx

    mov rbx, rdi

    ; Check if target is within the SURFACE dispatch region
    mov rax, SURFACE_BASE
    add rax, DISPATCH_OFFSET
    cmp rbx, rax
    jl .check_text

    mov rax, SURFACE_BASE
    add rax, DISPATCH_OFFSET
    add rax, DISPATCH_MAX_SIZE
    cmp rbx, rax
    jg .check_text

    ; Target is in dispatch region - check if it's a known subroutine
    ; The target should be RHDR_SIZE into a region (pointing to code)
    sub rbx, RHDR_SIZE          ; get header address

    ; Search subroutine table
    mov eax, [rel subroutine_count]
    test eax, eax
    jz .check_region

    lea rsi, [rel subroutine_table]
    xor ecx, ecx
.search_sub:
    cmp ecx, eax
    jge .check_region
    imul edx, ecx, SUBROUTINE_ENTRY_SIZE
    cmp [rsi + rdx + STE_PTR], rbx
    je .valid_subroutine
    inc ecx
    jmp .search_sub

.valid_subroutine:
    mov eax, 1
    jmp .done

.check_region:
    ; Check if it's a valid region via region_find_by_addr
    mov rdi, rbx
    call region_find_by_addr
    test rax, rax
    jz .check_text

    ; Found a region - check if it's a subroutine type
    movzx eax, word [rax + RTE_TYPE]
    cmp eax, RTYPE_SUBROUTINE
    je .valid_region
    jmp .invalid

.valid_region:
    mov eax, 1
    jmp .done

.check_text:
    ; Allow calls to .text section (system functions)
    ; .text is typically 0x401000 - 0x410000
    add rbx, RHDR_SIZE          ; restore original target
    cmp rbx, 0x401000
    jl .invalid
    cmp rbx, 0x410000
    jl .valid_text
    jmp .invalid

.valid_text:
    mov eax, 1
    jmp .done

.invalid:
    xor eax, eax

.done:
    pop rbx
    ret

;; ============================================================
;; subroutines_show
;; Display all registered subroutines (REPL command)
;; ============================================================
global subroutines_show
subroutines_show:
    push rbx
    push r12
    push r13

    lea rdi, [rel sub_hdr]
    call print_cstr

    mov r12d, [rel subroutine_count]
    test r12d, r12d
    jz .no_subs

    lea rbx, [rel subroutine_table]
    xor r13d, r13d
.show_loop:
    cmp r13d, r12d
    jge .show_done

    ; Print entry
    lea rdi, [rel sub_entry]
    call print_cstr
    mov edi, r13d
    call print_u64

    lea rdi, [rel sub_at]
    call print_cstr
    imul eax, r13d, SUBROUTINE_ENTRY_SIZE
    mov rdi, [rbx + rax + STE_PTR]
    add rdi, RHDR_SIZE          ; code address
    call print_hex64

    lea rdi, [rel sub_callers]
    call print_cstr
    imul eax, r13d, SUBROUTINE_ENTRY_SIZE
    mov edi, [rbx + rax + STE_CALLER_COUNT]
    call print_u64

    lea rdi, [rel sub_code_hash]
    call print_cstr
    imul eax, r13d, SUBROUTINE_ENTRY_SIZE
    mov edi, [rbx + rax + STE_CODE_HASH]
    call print_hex32

    call print_newline

    inc r13d
    jmp .show_loop

.no_subs:
    lea rdi, [rel sub_none]
    call print_cstr

.show_done:
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; garbage_collect_subroutines
;; Remove subroutines with zero callers
;; Returns: eax = number of subroutines removed
;; ============================================================
global garbage_collect_subroutines
garbage_collect_subroutines:
    push rbx
    push r12
    push r13

    lea rbx, [rel subroutine_table]
    mov r12d, [rel subroutine_count]
    xor r13d, r13d              ; removed count

    xor ecx, ecx                ; read index
    xor edx, edx                ; write index
.gc_loop:
    cmp ecx, r12d
    jge .gc_done

    ; Check caller count
    imul eax, ecx, SUBROUTINE_ENTRY_SIZE
    cmp dword [rbx + rax + STE_CALLER_COUNT], 0
    je .gc_remove

    ; Keep this entry - copy if needed
    cmp ecx, edx
    je .gc_no_copy

    imul eax, ecx, SUBROUTINE_ENTRY_SIZE
    imul esi, edx, SUBROUTINE_ENTRY_SIZE

    ; Copy 16 bytes
    mov rdi, [rbx + rax + 0]
    mov [rbx + rsi + 0], rdi
    mov rdi, [rbx + rax + 8]
    mov [rbx + rsi + 8], rdi

.gc_no_copy:
    inc edx                     ; write index++
    jmp .gc_next

.gc_remove:
    ; Condemn the subroutine region
    imul eax, ecx, SUBROUTINE_ENTRY_SIZE
    mov rdi, [rbx + rax + STE_PTR]
    or word [rdi + RHDR_FLAGS], RFLAG_CONDEMNED
    inc r13d

.gc_next:
    inc ecx
    jmp .gc_loop

.gc_done:
    mov [rel subroutine_count], edx
    mov eax, r13d

    pop r13
    pop r12
    pop rbx
    ret
; format.asm — Output formatting with channel routing
;
; @entry set_output_channel(edi=fd) -> routes output to socket fd
; @entry reset_output_channel() -> resets output to stdout (fd=1)
; @entry print_str(rdi=ptr, rsi=len) -> writes to output_fd
; @entry print_cstr(rdi=ptr) -> writes null-terminated string to output_fd
; @entry print_u64(rdi=val) -> prints decimal to output_fd
; @entry print_i64(rdi=val) -> prints signed decimal to output_fd
; @entry print_hex64(rdi=val) -> prints 0x-prefixed 16-digit hex
; @entry print_hex32(edi=val) -> prints 8-digit hex (no prefix)
; @entry print_f32(xmm0=val) -> prints float with 3 decimals
; @entry print_f64(xmm0=val) -> prints double with 4 decimals
; @entry print_newline() -> writes '\n'
; @entry print_space() -> writes ' '
; @calledby nearly every module for debug/status output
;
; OUTPUT ROUTING:
;   output_fd variable (default=1) controls where all print functions write
;   set_output_channel(fd) changes target, reset_output_channel() restores stdout
;   Used by repl.asm to route TCP channel responses to paired output socket
;
; GOTCHAS:
;   - All print functions use output_fd, not hardcoded STDOUT
;   - Caller must call reset_output_channel() after TCP response
;
%include "syscalls.inc"
%include "constants.inc"

section .bss
    fmt_buf: resb 128                ; scratch buffer for formatting

section .data
    output_fd: dd 1                  ; current output fd (1=stdout, or channel socket)

section .text

;; ============================================================
;; set_output_channel(fd)
;; edi=fd (1=stdout, or socket fd for channel output)
;; ============================================================
global set_output_channel
set_output_channel:
    mov [rel output_fd], edi
    ret

;; ============================================================
;; reset_output_channel — reset to stdout
;; ============================================================
global reset_output_channel
reset_output_channel:
    mov dword [rel output_fd], 1
    ret

;; ============================================================
;; print_str(str, len)
;; rdi=str ptr, rsi=len
;; Writes to output_fd (stdout or channel socket)
;; ============================================================
global print_str
print_str:
    mov rdx, rsi
    mov rsi, rdi
    mov edi, [rel output_fd]
    mov rax, SYS_WRITE
    syscall
    ret

;; ============================================================
;; print_cstr(str)
;; rdi=null-terminated string
;; Writes to output_fd (stdout or channel socket)
;; ============================================================
global print_cstr
print_cstr:
    push rdi
    ; find length
    xor rcx, rcx
.scan:
    cmp byte [rdi + rcx], 0
    je .found
    inc rcx
    jmp .scan
.found:
    mov rdx, rcx              ; len
    pop rsi                   ; buf
    mov edi, [rel output_fd]
    mov rax, SYS_WRITE
    syscall
    ret

;; ============================================================
;; print_u64(val)
;; rdi=u64 value, prints decimal
;; ============================================================
global print_u64
print_u64:
    push rbx
    push rbp
    mov rax, rdi
    lea rdi, [rel fmt_buf + 64]    ; work from end
    mov byte [rdi], 0
    mov rbx, 10
    test rax, rax
    jnz .loop
    ; zero case
    dec rdi
    mov byte [rdi], '0'
    jmp .print
.loop:
    test rax, rax
    jz .print
    xor edx, edx
    div rbx
    add dl, '0'
    dec rdi
    mov [rdi], dl
    jmp .loop
.print:
    ; rdi points to start of digits
    lea rsi, [rel fmt_buf + 64]
    sub rsi, rdi               ; len
    mov rdx, rsi
    mov rsi, rdi
    mov edi, [rel output_fd]
    mov rax, SYS_WRITE
    syscall
    pop rbp
    pop rbx
    ret

;; ============================================================
;; print_i64(val)
;; rdi=i64 value, prints signed decimal
;; ============================================================
global print_i64
print_i64:
    test rdi, rdi
    jns print_u64              ; positive → same as u64
    push rdi
    ; print minus sign
    lea rdi, [rel minus_char]
    mov rsi, 1
    call print_str
    pop rdi
    neg rdi
    jmp print_u64

;; ============================================================
;; print_hex64(val)
;; rdi=u64 value, prints 0x prefixed hex
;; ============================================================
global print_hex64
print_hex64:
    push rbx
    mov rax, rdi
    lea rdi, [rel fmt_buf]
    mov word [rdi], '0x'
    add rdi, 2
    mov ecx, 16               ; 16 hex digits
.hexloop:
    dec ecx
    mov rbx, rax
    shr rbx, cl
    shr rbx, cl
    shr rbx, cl
    shr rbx, cl
    ; Actually: shift by (cl*4) bits
    jmp .hexcalc
.hexcalc:
    ; recalculate properly
    push rcx
    mov rbx, rax
    mov cl, 60
.shift:
    cmp cl, 0
    jl .hexdone2
    mov rdx, rbx
    shr rdx, cl
    and edx, 0xF
    cmp dl, 10
    jl .hexdigit
    add dl, ('a' - 10)
    jmp .hexstore
.hexdigit:
    add dl, '0'
.hexstore:
    mov [rdi], dl
    inc rdi
    sub cl, 4
    jmp .shift
.hexdone2:
    pop rcx
    ; print
    lea rsi, [rel fmt_buf]
    mov rdi, rsi
    mov rsi, 18                ; "0x" + 16 digits
    call print_str
    pop rbx
    ret

;; ============================================================
;; print_hex32(val)
;; edi=u32 value, prints hex without prefix
;; ============================================================
global print_hex32
print_hex32:
    push rbx
    mov eax, edi
    lea rdi, [rel fmt_buf]
    mov ecx, 28                ; start shift (7*4)
.loop32:
    mov edx, eax
    mov cl, cl
    shr edx, cl
    and edx, 0xF
    cmp dl, 10
    jl .dig
    add dl, ('a' - 10)
    jmp .store
.dig:
    add dl, '0'
.store:
    mov [rdi], dl
    inc rdi
    sub ecx, 4
    jns .loop32
    ; print 8 chars
    lea rdi, [rel fmt_buf]
    mov rsi, 8
    call print_str
    pop rbx
    ret

;; ============================================================
;; print_f32(val)
;; xmm0=f32 value, prints fixed point (3 decimals)
;; ============================================================
global print_f32
print_f32:
    sub rsp, 16
    ; Check negative
    movd eax, xmm0
    test eax, eax
    jns .pos
    push rax
    lea rdi, [rel minus_char]
    mov rsi, 1
    call print_str
    pop rax
    and eax, 0x7FFFFFFF        ; clear sign bit
    movd xmm0, eax
.pos:
    ; Integer part
    cvttss2si rdi, xmm0
    push rdi                   ; save integer part
    call print_u64
    ; Decimal point
    lea rdi, [rel dot_char]
    mov rsi, 1
    call print_str
    ; Fractional part (3 digits)
    pop rdi
    cvtsi2ss xmm1, rdi
    subss xmm0, xmm1          ; frac = val - int_part
    mov eax, 1000
    cvtsi2ss xmm1, eax
    mulss xmm0, xmm1          ; frac * 1000
    cvttss2si rdi, xmm0
    ; Ensure positive
    test rdi, rdi
    jns .fpos
    neg rdi
.fpos:
    ; Print with leading zeros
    cmp rdi, 100
    jge .f3
    push rdi
    lea rdi, [rel zero_char]
    mov rsi, 1
    call print_str
    pop rdi
.f3:
    cmp rdi, 10
    jge .f2
    push rdi
    lea rdi, [rel zero_char]
    mov rsi, 1
    call print_str
    pop rdi
.f2:
    call print_u64
    add rsp, 16
    ret

;; ============================================================
;; print_f64(val)
;; xmm0=f64 value, prints fixed point (4 decimals)
;; ============================================================
global print_f64
print_f64:
    sub rsp, 24
    movsd [rsp], xmm0           ; save original value

    ; Check for negative
    movq rax, xmm0
    test rax, rax
    jns .f64_pos
    push rax
    lea rdi, [rel minus_char]
    mov rsi, 1
    call print_str
    pop rax
    ; Clear sign bit (make positive)
    mov rcx, 0x7FFFFFFFFFFFFFFF
    and rax, rcx
    movq xmm0, rax
    movsd [rsp], xmm0

.f64_pos:
    ; Integer part
    cvttsd2si rdi, xmm0
    mov [rsp + 8], rdi          ; save integer part
    call print_u64

    ; Decimal point
    lea rdi, [rel dot_char]
    mov rsi, 1
    call print_str

    ; Fractional part (4 digits)
    movsd xmm0, [rsp]           ; reload value
    ; Make sure it's positive (in case original was negative)
    movq rax, xmm0
    mov rcx, 0x7FFFFFFFFFFFFFFF
    and rax, rcx
    movq xmm0, rax

    mov rdi, [rsp + 8]          ; integer part
    cvtsi2sd xmm1, rdi
    subsd xmm0, xmm1            ; frac = val - int_part

    ; Multiply by 10000 for 4 decimal places
    mov rax, 10000
    cvtsi2sd xmm1, rax
    mulsd xmm0, xmm1
    cvttsd2si rdi, xmm0

    ; Ensure positive
    test rdi, rdi
    jns .f64_fpos
    neg rdi
.f64_fpos:
    mov [rsp + 16], rdi         ; save fractional

    ; Print with leading zeros
    cmp rdi, 1000
    jge .f64_4
    push rdi
    lea rdi, [rel zero_char]
    mov rsi, 1
    call print_str
    pop rdi
.f64_4:
    cmp rdi, 100
    jge .f64_3
    push rdi
    lea rdi, [rel zero_char]
    mov rsi, 1
    call print_str
    pop rdi
.f64_3:
    cmp rdi, 10
    jge .f64_2
    push rdi
    lea rdi, [rel zero_char]
    mov rsi, 1
    call print_str
    pop rdi
.f64_2:
    call print_u64

    add rsp, 24
    ret

;; ============================================================
;; print_newline
;; ============================================================
global print_newline
print_newline:
    lea rdi, [rel nl_char]
    mov rsi, 1
    call print_str
    ret

;; ============================================================
;; print_space
;; ============================================================
global print_space
print_space:
    lea rdi, [rel sp_char]
    mov rsi, 1
    call print_str
    ret

section .rodata
    minus_char: db '-'
    dot_char:   db '.'
    zero_char:  db '0'
    nl_char:    db 10
    sp_char:    db ' '
; gate.asm — Predictive gating: test modifications in sandbox before commit
;
; ENTRY POINTS:
;   gate_test_modification(region_ptr, mod_type, arg) → eax=1(pass)/0(fail)
;   gate_check_region(region_ptr)                     → eax=1(valid)/0(invalid)
;
; PROCESS:
;   1. Copy region to ST_NURSERY buffer (sandbox)
;   2. Apply proposed modification to sandbox copy
;   3. Run test cases against sandbox
;   4. Compare accuracy/behavior before vs after
;   5. Return pass/fail without touching original
;
; MODIFICATION TYPES:
;   MOD_MUTATE, MOD_SPECIALIZE, MOD_GENERALIZE, MOD_CROSSOVER
;
; KEY CONSTRAINT:
;   Region + header must fit in ST_NURSERY_SIZE (4KB default)
;   Oversized regions automatically fail
;
; CALLED BY:
;   evolve.asm: evolve_mutate(), evolve_crossover()
;   modify.asm: modify_specialize(), modify_generalize()
;
%include "syscalls.inc"
%include "constants.inc"

section .data
    gate_pass_msg:  db "[GATE] PASS — modification approved", 10, 0
    gate_fail_msg:  db "[GATE] FAIL — modification rejected", 10, 0
    gate_test_msg:  db "[GATE] Testing modification...", 10, 0

section .text

extern print_cstr
extern fire_hook

;; ============================================================
;; gate_test_modification(region_ptr, mod_type, mod_arg)
;; rdi=region header ptr, esi=modification type, rdx=arg
;; Tests a proposed modification before committing:
;; 1. Copy region to nursery buffer
;; 2. Apply modification to copy
;; 3. Run test cases against copy
;; 4. Compare accuracy before/after
;; Returns: eax=1 (pass) or 0 (fail)
;; ============================================================
global gate_test_modification
gate_test_modification:
    push rbx
    push r12
    push r13
    push r14
    push r15

    mov r12, rdi              ; region ptr
    mov r13d, esi             ; mod type
    mov r14, rdx              ; mod arg

    mov rbx, SURFACE_BASE

    lea rdi, [rel gate_test_msg]
    call print_cstr

    ; --- Step 1: Copy region to nursery ---
    lea r15, [rbx + STATE_OFFSET + ST_NURSERY]

    ; Get region size (header + code)
    movzx ecx, word [r12 + RHDR_CODE_LEN]
    add ecx, RHDR_SIZE
    cmp ecx, ST_NURSERY_SIZE
    jg .fail                  ; too large for nursery

    ; Copy bytes
    mov rsi, r12              ; source
    mov rdi, r15              ; dest (nursery)
    push rcx
.copy:
    test ecx, ecx
    jz .copy_done
    mov al, [rsi]
    mov [rdi], al
    inc rsi
    inc rdi
    dec ecx
    jmp .copy
.copy_done:
    pop rcx

    ; --- Step 2: Record baseline accuracy ---
    mov eax, [r15 + RHDR_HITS]
    mov edx, [r15 + RHDR_MISSES]
    mov r13d, eax             ; save baseline hits
    add edx, eax
    test edx, edx
    jz .pass                  ; no data = allow modification (optimistic)

    ; Baseline accuracy ratio (hits / total)
    ; Store as integer ratio for comparison
    ; baseline_hits = r13d, baseline_total = edx
    push rdx                  ; save baseline total

    ; --- Step 3: Simulate modification on copy ---
    ; Apply the modification type to the nursery copy
    ; For now: just test that the modified code is syntactically valid
    ; (doesn't crash when we examine its structure)

    ; Check that the copy still starts with valid instruction prefix
    cmp byte [r15 + RHDR_SIZE], 0x3D  ; cmp eax, imm32
    je .valid_code
    cmp byte [r15 + RHDR_SIZE], 0x31  ; xor
    je .valid_code
    cmp byte [r15 + RHDR_SIZE], 0xB8  ; mov eax, imm
    je .valid_code
    cmp byte [r15 + RHDR_SIZE], 0x90  ; nop
    je .valid_code
    ; Unknown instruction start — risky
    pop rdx
    jmp .fail

.valid_code:
    pop rdx                    ; rdx = baseline_total

    ; --- Step 4: Run test cases from miss buffer (wider scan) ---
    ; Test the copy against ALL available miss buffer entries, not just 8
    lea rsi, [rbx + STATE_OFFSET + ST_MISS_BUF]
    mov ecx, [rbx + STATE_OFFSET + ST_MISS_POS]
    test ecx, ecx
    jz .use_gate_count
    cmp ecx, ST_MISS_BUF_CAP
    jle .use_miss_pos
.use_gate_count:
    mov ecx, GATE_TEST_COUNT
.use_miss_pos:
    ; ecx = number of entries to test (up to miss_pos or GATE_TEST_COUNT)
    xor r8d, r8d             ; test_hits (on copy)
    xor r9d, r9d             ; test_total (context-matching tests)
    xor edx, edx             ; test index

.test_loop:
    cmp edx, ecx
    jge .test_done

    ; Get test case: ctx_hash at [rsi + edx*16], token at [rsi + edx*16 + 8]
    push rcx
    push rdx
    imul eax, edx, ST_MISS_ENTRY_SIZE
    mov edi, [rsi + rax]       ; test context hash (lower 32)
    mov edx, [rsi + rax + 8]   ; expected token

    ; Check if nursery copy would match this context
    cmp byte [r15 + RHDR_SIZE], 0x3D
    jne .test_next
    cmp [r15 + RHDR_SIZE + 1], edi
    jne .test_next

    ; Context matches — count this as a test case
    inc r9d

    ; Check if prediction is correct
    cmp byte [r15 + RHDR_SIZE + 7], 0xB8
    jne .test_next
    cmp [r15 + RHDR_SIZE + 8], edx
    jne .test_next

    ; Hit on test
    inc r8d

.test_next:
    pop rdx
    pop rcx
    inc edx
    jmp .test_loop

.test_done:
    ; --- Decision: compare test accuracy with baseline ---
    ; baseline_accuracy = r13d / (saved total from step 2)
    ; test_accuracy = r8d / r9d
    ; Pass if: no test data OR test_accuracy >= baseline_accuracy * 0.8

    test r9d, r9d
    jz .pass                  ; no applicable tests = optimistic pass

    ; Compute test accuracy (f32)
    cvtsi2ss xmm0, r8d
    cvtsi2ss xmm1, r9d
    divss xmm0, xmm1          ; xmm0 = test_accuracy

    ; Compute baseline accuracy (f32)
    mov eax, [r15 + RHDR_HITS]
    mov ecx, [r15 + RHDR_MISSES]
    add ecx, eax
    test ecx, ecx
    jz .pass                  ; no baseline data = pass
    cvtsi2ss xmm2, eax
    cvtsi2ss xmm3, ecx
    divss xmm2, xmm3          ; xmm2 = baseline_accuracy

    ; threshold = baseline * 0.8 (allow slight degradation)
    mov eax, 0x3F4CCCCD        ; 0.8f
    movd xmm3, eax
    mulss xmm2, xmm3          ; threshold

    ; Pass if test_accuracy >= threshold
    comiss xmm0, xmm2
    jae .pass

    ; Test accuracy degraded too much — reject modification
    jmp .fail

.pass:
    lea rdi, [rel gate_pass_msg]
    call print_cstr

    ; Fire gate pass hook
    mov edi, HOOK_ON_GATE_PASS
    xor esi, esi
    call fire_hook

    mov eax, 1
    jmp .ret

.fail:
    lea rdi, [rel gate_fail_msg]
    call print_cstr

    ; Fire gate fail hook
    mov edi, HOOK_ON_GATE_FAIL
    xor esi, esi
    call fire_hook

    xor eax, eax

.ret:
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; gate_check_region(region_ptr) → eax (1=healthy, 0=should modify)
;; Quick health check on a region
;; ============================================================
global gate_check_region
gate_check_region:
    ; Check hits vs misses ratio
    mov eax, [rdi + RHDR_HITS]
    mov ecx, [rdi + RHDR_MISSES]
    add ecx, eax
    test ecx, ecx
    jz .healthy               ; no data yet = healthy

    ; If accuracy > 0.3, region is healthy
    cvtsi2ss xmm0, eax
    cvtsi2ss xmm1, ecx
    divss xmm0, xmm1

    mov eax, THRESH_ACCURACY  ; 0.3f
    movd xmm1, eax
    comiss xmm0, xmm1
    ja .healthy

    ; Below threshold — needs modification
    xor eax, eax
    ret

.healthy:
    mov eax, 1
    ret
; genes.asm — Gene Pool: metabolic recycling of condemned regions
;
; ENTRY POINTS:
;   gene_pool_init()                  - zero out gene pool
;   gene_extract(region_ptr)          - extract ctx/token/fitness from dying region
;   gene_pool_add(ctx, token, fitness)- add gene, replace lowest if full
;   gene_pool_sample()                → ctx in eax, token in edx (or 0 if empty)
;   gene_pool_show()                  - display pool status and top genes
;
; GENE STRUCTURE (16 bytes each):
;   [0-3]  ctx_hash   - context hash pattern matched
;   [4-7]  token_id   - predicted token
;   [8-15] fitness    - f64 fitness at time of death (hits/(hits+miss))
;
; POOL POLICY:
;   Fixed size: GENE_POOL_SIZE entries (default 64)
;   When full: find lowest-fitness gene, replace if new gene is fitter
;   Minimum fitness threshold: gene_min_fitness (0.05) to avoid junk
;
; CALLED BY:
;   surface.asm: region_condemn() extracts gene before death
;   evolve.asm:  evolve_from_gene_pool() resurrects genes
;
%include "syscalls.inc"
%include "constants.inc"

section .data
    gene_msg:           db "[GENES] ", 0
    gene_extract_msg:   db "Extracted: ctx=0x", 0
    gene_token_msg:     db " token=0x", 0
    gene_fitness_msg:   db " fitness=", 0
    gene_replace_msg:   db " (replaced idx ", 0
    gene_close_msg:     db ")", 0
    gene_sample_msg:    db "Sampled: idx=", 0
    gene_reuse_msg:     db "Reusing gene for evolution", 10, 0
    gene_nl:            db 10, 0
    gene_status_hdr:    db "--- Gene Pool Status ---", 10, 0
    gene_count_lbl:     db "  Active genes: ", 0
    gene_extracted_lbl: db "  Total extracted: ", 0
    gene_reused_lbl:    db "  Total reused: ", 0
    gene_lowest_lbl:    db "  Lowest fitness: ", 0
    gene_at_idx_lbl:    db " at idx ", 0
    gene_list_hdr:      db "  Top genes:", 10, 0
    gene_entry_lbl:     db "    [", 0
    gene_ctx_lbl:       db "] ctx=0x", 0
    gene_tok_lbl:       db " tok=0x", 0
    gene_fit_lbl:       db " fit=", 0
    gene_hits_lbl:      db " h/m=", 0
    gene_slash:         db "/", 0

    align 8
    gene_min_fitness:   dq 0.05         ; minimum fitness to extract a gene

section .text

extern print_cstr
extern print_hex32
extern print_u64
extern print_f32
extern print_newline
extern introspect_region
extern sys_getrandom

;; ============================================================
;; gene_pool_init
;; Initialize the gene pool (zero all entries)
;; Called from surface_init
;; ============================================================
global gene_pool_init
gene_pool_init:
    push rbx
    mov rbx, SURFACE_BASE

    ; Zero the gene pool area
    ; NOTE: GENE_POOL_OFFSET > 32-bit, lea would sign-extend. Use single 64-bit immediate.
    mov rdi, SURFACE_BASE + GENE_POOL_OFFSET
    xor eax, eax
    mov ecx, GENE_POOL_SIZE / 8
.zero_loop:
    mov qword [rdi], rax
    add rdi, 8
    dec ecx
    jnz .zero_loop

    ; Initialize state fields
    mov dword [rbx + STATE_OFFSET + ST_GENE_COUNT], 0
    mov dword [rbx + STATE_OFFSET + ST_GENES_EXTRACTED], 0
    mov dword [rbx + STATE_OFFSET + ST_GENES_REUSED], 0
    mov dword [rbx + STATE_OFFSET + ST_GENE_LOWEST_IDX], 0
    ; Set lowest fitness to max (1.0) initially
    mov eax, 0x3F800000               ; 1.0f
    mov [rbx + STATE_OFFSET + ST_GENE_LOWEST_FIT], eax

    pop rbx
    ret

;; ============================================================
;; gene_extract(region_header_ptr)
;; rdi = pointer to region header (being condemned)
;; Extract the region's (ctx_hash, token_id) pair and fitness.
;; Add to gene pool if the region had any successful predictions.
;; Returns: 1 if extracted, 0 if not worth extracting
;; ============================================================
global gene_extract
gene_extract:
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub rsp, 24                       ; local storage

    mov r12, rdi                      ; save region header ptr
    mov rbx, SURFACE_BASE

    ; Check if region has any hits (worth extracting)
    mov eax, [r12 + RHDR_HITS]
    test eax, eax
    jz .not_worth                     ; no hits = no useful knowledge

    ; Compute fitness = hits / (hits + misses)
    mov r13d, eax                     ; r13d = hits
    mov edx, [r12 + RHDR_MISSES]
    mov r14d, edx                     ; r14d = misses
    add edx, eax                      ; edx = total
    test edx, edx
    jz .not_worth

    cvtsi2ss xmm0, eax                ; hits
    cvtsi2ss xmm1, edx                ; total
    divss xmm0, xmm1                  ; fitness
    movss [rsp], xmm0                 ; save fitness

    ; Check minimum fitness threshold
    cvtss2sd xmm1, xmm0
    movsd xmm2, [rel gene_min_fitness]
    ucomisd xmm1, xmm2
    jb .not_worth                     ; below minimum, don't extract

    ; Use introspect_region to decode ctx_hash and pred_token
    mov rdi, r12
    call introspect_region            ; returns semantic type in eax
    ; After call: we need to re-decode to get ctx_hash and token
    ; introspect_region leaves r12d = ctx_hash, r13d = pred_token in its impl
    ; But those are callee-saved, so they're clobbered. Let's decode directly.

    ; Decode ctx_hash from region code (cmp eax, imm32 at offset 0)
    lea rsi, [r12 + RHDR_SIZE]        ; code body
    cmp byte [rsi], 0x3D              ; cmp eax, imm32?
    jne .not_worth                    ; can't decode, skip
    mov r15d, [rsi + 1]               ; ctx_hash

    ; Decode token_id (mov eax, imm32 - scan for 0xB8)
    movzx ecx, word [r12 + RHDR_CODE_LEN]
    lea rdi, [rsi + 5]                ; skip past cmp
    lea rdx, [rsi + rcx]              ; end of code
    xor eax, eax                      ; token_id (0 = not found)
.scan_token:
    cmp rdi, rdx
    jge .got_token
    cmp byte [rdi], 0xB8
    jne .scan_next_token
    mov eax, [rdi + 1]                ; found token_id
    jmp .got_token
.scan_next_token:
    inc rdi
    jmp .scan_token

.got_token:
    test eax, eax
    jz .not_worth                     ; couldn't find token prediction
    mov [rsp + 4], eax                ; save token_id
    mov [rsp + 8], r15d               ; save ctx_hash

    ; Now add to gene pool
    ; Args: ctx_hash=r15d, token_id=[rsp+4], fitness=[rsp], hits=r13d, misses=r14d
    mov edi, r15d                     ; ctx_hash
    mov esi, [rsp + 4]                ; token_id
    movss xmm0, [rsp]                 ; fitness
    mov edx, r13d                     ; hits
    mov ecx, r14d                     ; misses
    call gene_pool_add

    ; Print extraction message
    push rax
    lea rdi, [rel gene_msg]
    call print_cstr
    lea rdi, [rel gene_extract_msg]
    call print_cstr
    mov edi, [rsp + 16]               ; ctx_hash (offset shifted by push)
    call print_hex32
    lea rdi, [rel gene_token_msg]
    call print_cstr
    mov edi, [rsp + 12]               ; token_id
    call print_hex32
    lea rdi, [rel gene_fitness_msg]
    call print_cstr
    movss xmm0, [rsp + 8]             ; fitness
    call print_f32
    call print_newline
    pop rax

    ; Increment extraction counter
    inc dword [rbx + STATE_OFFSET + ST_GENES_EXTRACTED]

    mov eax, 1                        ; success
    jmp .done

.not_worth:
    xor eax, eax                      ; not extracted

.done:
    add rsp, 24
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; gene_pool_add(ctx_hash, token_id, fitness, hits, misses)
;; edi = ctx_hash, esi = token_id, xmm0 = fitness (f32)
;; edx = hits, ecx = misses
;; Add a gene to the pool. If full, replace lowest-fitness gene.
;; ============================================================
global gene_pool_add
gene_pool_add:
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub rsp, 24

    mov r12d, edi                     ; ctx_hash
    mov r13d, esi                     ; token_id
    movss [rsp], xmm0                 ; fitness
    mov r14d, edx                     ; hits
    mov r15d, ecx                     ; misses
    mov rbx, SURFACE_BASE

    ; Check if pool has space
    mov eax, [rbx + STATE_OFFSET + ST_GENE_COUNT]
    cmp eax, GENE_MAX
    jge .pool_full

    ; Pool has space - add at next available slot
    ; Find first empty slot (flags == 0)
    mov rsi, SURFACE_BASE + GENE_POOL_OFFSET
    xor ecx, ecx
.find_empty:
    cmp ecx, GENE_MAX
    jge .pool_full                    ; shouldn't happen, but safety
    imul edi, ecx, GENE_ENTRY_SIZE
    lea rdi, [rsi + rdi]
    cmp dword [rdi + GENE_FLAGS], 0
    je .found_slot
    inc ecx
    jmp .find_empty

.found_slot:
    ; ecx = slot index, rdi = slot ptr
    mov [rsp + 8], ecx                ; save slot index
    jmp .write_gene

.pool_full:
    ; Replace lowest-fitness gene
    mov ecx, [rbx + STATE_OFFSET + ST_GENE_LOWEST_IDX]
    mov [rsp + 8], ecx                ; slot to replace
    mov rsi, SURFACE_BASE + GENE_POOL_OFFSET
    imul edi, ecx, GENE_ENTRY_SIZE
    lea rdi, [rsi + rdi]
    ; Don't increment gene count (replacing, not adding)
    jmp .write_gene_no_inc

.write_gene:
    ; Increment gene count
    inc dword [rbx + STATE_OFFSET + ST_GENE_COUNT]

.write_gene_no_inc:
    ; rdi = slot ptr, write the gene entry
    mov [rdi + GENE_CTX_HASH], r12d
    mov [rdi + GENE_TOKEN_ID], r13d
    movss xmm0, [rsp]
    movss [rdi + GENE_FITNESS], xmm0
    mov [rdi + GENE_HITS], r14d
    mov [rdi + GENE_MISSES], r15d
    mov eax, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    mov [rdi + GENE_BIRTH_STEP], eax
    mov dword [rdi + GENE_FLAGS], GFLAG_ACTIVE
    ; Set HIGH_FITNESS flag if fitness > 0.5
    movss xmm0, [rsp]
    mov eax, 0x3F000000               ; 0.5f
    movd xmm1, eax
    comiss xmm0, xmm1
    jbe .no_high_fit
    or dword [rdi + GENE_FLAGS], GFLAG_HIGH_FITNESS
.no_high_fit:

    ; Update lowest fitness tracking
    call gene_pool_update_lowest

    add rsp, 24
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; gene_pool_update_lowest
;; Scan pool to find lowest fitness gene, update ST_GENE_LOWEST_*
;; ============================================================
gene_pool_update_lowest:
    push rbx
    push r12
    mov rbx, SURFACE_BASE

    ; Initialize: lowest_fit = 2.0 (above max), lowest_idx = 0
    mov eax, 0x40000000               ; 2.0f
    movd xmm0, eax                    ; lowest fitness seen
    xor r12d, r12d                    ; lowest index

    mov rsi, SURFACE_BASE + GENE_POOL_OFFSET
    xor ecx, ecx
.scan:
    cmp ecx, GENE_MAX
    jge .scan_done

    imul edi, ecx, GENE_ENTRY_SIZE
    lea rdi, [rsi + rdi]

    ; Skip inactive slots
    test dword [rdi + GENE_FLAGS], GFLAG_ACTIVE
    jz .scan_next

    ; Compare fitness
    movss xmm1, [rdi + GENE_FITNESS]
    comiss xmm1, xmm0
    jae .scan_next                    ; not lower

    ; New lowest found
    movss xmm0, xmm1
    mov r12d, ecx

.scan_next:
    inc ecx
    jmp .scan

.scan_done:
    ; Store results
    mov [rbx + STATE_OFFSET + ST_GENE_LOWEST_IDX], r12d
    movss [rbx + STATE_OFFSET + ST_GENE_LOWEST_FIT], xmm0

    pop r12
    pop rbx
    ret

;; ============================================================
;; gene_pool_sample() → ctx_hash in eax, token_id in edx
;; Sample a random gene from the pool, weighted by fitness.
;; Returns: eax = ctx_hash, edx = token_id, xmm0 = fitness
;; Returns ctx_hash=0 if pool is empty
;; ============================================================
global gene_pool_sample
gene_pool_sample:
    push rbx
    push r12
    push r13
    sub rsp, 16

    mov rbx, SURFACE_BASE

    ; Check if pool is empty
    mov eax, [rbx + STATE_OFFSET + ST_GENE_COUNT]
    test eax, eax
    jz .empty

    ; Get random number
    lea rdi, [rsp]
    mov rsi, 4
    xor edx, edx
    mov rax, SYS_GETRANDOM
    syscall

    ; Compute total fitness for weighted sampling
    mov rsi, SURFACE_BASE + GENE_POOL_OFFSET
    xorps xmm2, xmm2                  ; total fitness
    xor ecx, ecx
.sum_fitness:
    cmp ecx, GENE_MAX
    jge .sum_done
    imul edi, ecx, GENE_ENTRY_SIZE
    lea rdi, [rsi + rdi]
    test dword [rdi + GENE_FLAGS], GFLAG_ACTIVE
    jz .sum_next
    addss xmm2, [rdi + GENE_FITNESS]
.sum_next:
    inc ecx
    jmp .sum_fitness
.sum_done:

    ; xmm2 = total fitness. Generate random threshold [0, total)
    mov eax, [rsp]
    and eax, 0x7FFFFFFF               ; positive
    cvtsi2ss xmm0, eax
    mov eax, 0x7FFFFFFF
    cvtsi2ss xmm1, eax
    divss xmm0, xmm1                  ; random [0, 1)
    mulss xmm0, xmm2                  ; random [0, total_fitness)
    ; xmm0 = threshold

    ; Scan and accumulate until we cross threshold
    xorps xmm1, xmm1                  ; accumulated
    xor ecx, ecx
    mov r12d, -1                      ; selected index
.select:
    cmp ecx, GENE_MAX
    jge .select_done
    imul edi, ecx, GENE_ENTRY_SIZE
    lea rdi, [rsi + rdi]
    test dword [rdi + GENE_FLAGS], GFLAG_ACTIVE
    jz .select_next
    addss xmm1, [rdi + GENE_FITNESS]
    comiss xmm1, xmm0
    jb .select_next
    mov r12d, ecx                     ; selected!
    jmp .select_done
.select_next:
    inc ecx
    jmp .select

.select_done:
    ; If no selection (shouldn't happen), pick first active
    cmp r12d, -1
    jne .got_selection
    xor ecx, ecx
.find_any:
    cmp ecx, GENE_MAX
    jge .empty
    imul edi, ecx, GENE_ENTRY_SIZE
    lea rdi, [rsi + rdi]
    test dword [rdi + GENE_FLAGS], GFLAG_ACTIVE
    jnz .found_any
    inc ecx
    jmp .find_any
.found_any:
    mov r12d, ecx

.got_selection:
    ; r12d = selected index
    imul eax, r12d, GENE_ENTRY_SIZE
    lea rdi, [rsi + rax]

    ; Return values
    mov eax, [rdi + GENE_CTX_HASH]
    mov edx, [rdi + GENE_TOKEN_ID]
    movss xmm0, [rdi + GENE_FITNESS]

    ; Mark as proven (used during evolution)
    or dword [rdi + GENE_FLAGS], GFLAG_PROVEN

    ; Increment reuse counter
    inc dword [rbx + STATE_OFFSET + ST_GENES_REUSED]

    jmp .done

.empty:
    xor eax, eax                      ; ctx_hash = 0 means no gene
    xor edx, edx
    xorps xmm0, xmm0

.done:
    add rsp, 16
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; gene_pool_show
;; Print gene pool status (for REPL "genes" command)
;; ============================================================
global gene_pool_show
gene_pool_show:
    push rbx
    push r12
    push r13
    mov rbx, SURFACE_BASE

    ; Header
    lea rdi, [rel gene_status_hdr]
    call print_cstr

    ; Active genes
    lea rdi, [rel gene_count_lbl]
    call print_cstr
    mov edi, [rbx + STATE_OFFSET + ST_GENE_COUNT]
    mov r12d, edi                     ; save count
    call print_u64
    call print_newline

    ; Total extracted
    lea rdi, [rel gene_extracted_lbl]
    call print_cstr
    mov edi, [rbx + STATE_OFFSET + ST_GENES_EXTRACTED]
    call print_u64
    call print_newline

    ; Total reused
    lea rdi, [rel gene_reused_lbl]
    call print_cstr
    mov edi, [rbx + STATE_OFFSET + ST_GENES_REUSED]
    call print_u64
    call print_newline

    ; Lowest fitness
    lea rdi, [rel gene_lowest_lbl]
    call print_cstr
    movss xmm0, [rbx + STATE_OFFSET + ST_GENE_LOWEST_FIT]
    call print_f32
    lea rdi, [rel gene_at_idx_lbl]
    call print_cstr
    mov edi, [rbx + STATE_OFFSET + ST_GENE_LOWEST_IDX]
    call print_u64
    call print_newline

    ; List top genes (first 10 active)
    test r12d, r12d
    jz .no_genes
    lea rdi, [rel gene_list_hdr]
    call print_cstr

    mov rsi, SURFACE_BASE + GENE_POOL_OFFSET
    xor ecx, ecx                      ; index
    xor r13d, r13d                    ; printed count
.list_loop:
    cmp ecx, GENE_MAX
    jge .list_done
    cmp r13d, 10                      ; max 10 entries
    jge .list_done

    push rcx
    imul edi, ecx, GENE_ENTRY_SIZE
    lea rdi, [rsi + rdi]

    test dword [rdi + GENE_FLAGS], GFLAG_ACTIVE
    jz .list_next

    ; Print entry
    push rdi
    push rsi
    lea rdi, [rel gene_entry_lbl]
    call print_cstr
    mov rdi, [rsp + 16]               ; index from stack
    call print_u64
    lea rdi, [rel gene_ctx_lbl]
    call print_cstr
    mov rdi, [rsp]                    ; entry ptr
    mov edi, [rdi + GENE_CTX_HASH]
    call print_hex32
    lea rdi, [rel gene_tok_lbl]
    call print_cstr
    mov rdi, [rsp]
    mov edi, [rdi + GENE_TOKEN_ID]
    call print_hex32
    lea rdi, [rel gene_fit_lbl]
    call print_cstr
    mov rdi, [rsp]
    movss xmm0, [rdi + GENE_FITNESS]
    call print_f32
    lea rdi, [rel gene_hits_lbl]
    call print_cstr
    mov rdi, [rsp]
    mov edi, [rdi + GENE_HITS]
    call print_u64
    lea rdi, [rel gene_slash]
    call print_cstr
    mov rdi, [rsp]
    mov edi, [rdi + GENE_MISSES]
    call print_u64
    call print_newline
    pop rsi
    pop rdi

    inc r13d

.list_next:
    pop rcx
    inc ecx
    jmp .list_loop

.list_done:
.no_genes:

    pop r13
    pop r12
    pop rbx
    ret
; hooks.asm — Event hook system: register callbacks, fire events
;
; ENTRY POINTS:
;   fire_hook(hook_id, arg)           - call all handlers for hook_id with arg
;   hook_register(hook_id, fn_ptr)    → eax=slot index or -1 if full
;   hook_unregister(hook_id, fn_ptr)  - remove handler from hook
;   hook_clear(hook_id)               - remove all handlers from hook
;   hook_get_count(hook_id)           → eax=number of registered handlers
;
; HOOK IDs (0 to NUM_HOOKS-1):
;   HOOK_TOKEN_IN, HOOK_PREDICT, HOOK_HIT, HOOK_MISS, HOOK_LEARN,
;   HOOK_EMIT, HOOK_PRUNE, HOOK_EVOLVE, HOOK_DREAM, HOOK_OBSERVE,
;   HOOK_SAVE, HOOK_LOAD, HOOK_FAULT, etc.
;
; STORAGE (in ST_HOOKS[]):
;   Each hook: HOOK_ENTRY_SIZE bytes
;     [0-1]  handler_count: u16
;     [2-7]  padding
;     [8+]   handler_ptrs: array of function pointers
;
; HANDLER SIGNATURE: fn(hook_id: edi, arg: esi)
; Handlers are called in registration order. fire_hook is safe to call even if empty.
;
; CALLED BY: nearly every module fires hooks at key events
;
%include "syscalls.inc"
%include "constants.inc"

section .text

extern journey_step

;; ============================================================
;; fire_hook(hook_id, arg)
;; edi=hook_id (0-21), esi=argument (context-dependent)
;; Iterates the hook's handler array, calls each registered handler
;; Each handler is called with: rdi=hook_id, rsi=arg
;; ============================================================
global fire_hook
fire_hook:
    push rbx
    push r12
    push r13
    push r14

    mov r12d, edi             ; hook_id
    mov r13d, esi             ; arg

    ; JOURNEY: record fire_hook
    push r12
    push r13
    mov edi, TRACE_FIRE_HOOK
    call journey_step
    pop r13
    pop r12

    ; Validate hook_id
    cmp r12d, NUM_HOOKS
    jge .done

    ; Calculate hook entry address in state block
    mov rbx, SURFACE_BASE
    lea rax, [rbx + STATE_OFFSET + ST_HOOKS]

    ; Offset: hook_id * HOOK_ENTRY_SIZE
    imul rcx, r12, HOOK_ENTRY_SIZE
    add rax, rcx              ; rax = hook entry base

    ; Read handler count
    movzx r14d, word [rax]    ; count
    test r14d, r14d
    jz .done                  ; no handlers

    ; Skip header (8 bytes: count:u16 + pad:u16 + pad:u32)
    add rax, 8                ; rax = start of fn_ptr array

    ; Iterate handlers
    xor ecx, ecx             ; index
.fire_loop:
    cmp ecx, r14d
    jge .done
    push rcx
    push rax

    ; Load function pointer
    mov rdx, [rax + rcx * 8]
    test rdx, rdx
    jz .skip_handler

    ; Safety: validate handler is in valid .text section
    ; Valid code range: 0x401000 - 0x408000 (program's .text)
    ; Reject: NULL, data sections (.bss/.data), surface region
    mov r8, 0x401000
    cmp rdx, r8
    jb .skip_handler                ; below .text = invalid (NULL, etc)
    mov r8, 0x408000
    cmp rdx, r8
    jae .skip_handler               ; above .text = invalid (data section, surface, etc)

.call_safe:
    ; Call handler(hook_id, arg)
    mov edi, r12d
    mov esi, r13d
    call rdx

.skip_handler:
    pop rax
    pop rcx
    inc ecx
    jmp .fire_loop

.done:
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; hook_register(hook_id, handler_ptr)
;; edi=hook_id, rsi=function pointer
;; Adds a handler to the hook's array
;; Returns: 0=success, -1=full or invalid
;; ============================================================
global hook_register
hook_register:
    push rbx

    ; Validate
    cmp edi, NUM_HOOKS
    jge .fail

    mov rbx, SURFACE_BASE
    lea rax, [rbx + STATE_OFFSET + ST_HOOKS]

    ; Find hook entry
    imul rcx, rdi, HOOK_ENTRY_SIZE
    add rax, rcx

    ; Check if full
    movzx ecx, word [rax]     ; current count
    cmp ecx, HOOK_MAX_HANDLERS
    jge .fail

    ; Add handler at position [count]
    mov [rax + 8 + rcx * 8], rsi

    ; Increment count
    inc word [rax]

    xor eax, eax              ; success
    pop rbx
    ret

.fail:
    mov eax, -1
    pop rbx
    ret

;; ============================================================
;; hook_unregister(hook_id, handler_ptr)
;; edi=hook_id, rsi=function pointer to remove
;; Removes first matching handler from the hook
;; Returns: 0=success, -1=not found
;; ============================================================
global hook_unregister
hook_unregister:
    push rbx
    push r12

    cmp edi, NUM_HOOKS
    jge .fail

    mov rbx, SURFACE_BASE
    lea rax, [rbx + STATE_OFFSET + ST_HOOKS]
    imul rcx, rdi, HOOK_ENTRY_SIZE
    add rax, rcx

    movzx ecx, word [rax]     ; count
    test ecx, ecx
    jz .fail

    ; Search for the handler
    xor edx, edx
.search:
    cmp edx, ecx
    jge .fail
    cmp [rax + 8 + rdx * 8], rsi
    je .found
    inc edx
    jmp .search

.found:
    ; Shift remaining handlers down
    mov r12d, edx             ; found index
.shift:
    inc edx
    cmp edx, ecx
    jge .shift_done
    mov rbx, [rax + 8 + rdx * 8]
    mov [rax + 8 + rdx * 8 - 8], rbx
    jmp .shift
.shift_done:
    ; Clear last slot
    dec ecx
    mov qword [rax + 8 + rcx * 8], 0
    ; Decrement count
    dec word [rax]

    xor eax, eax
    pop r12
    pop rbx
    ret

.fail:
    mov eax, -1
    pop r12
    pop rbx
    ret

;; ============================================================
;; hook_clear(hook_id)
;; edi=hook_id
;; Removes all handlers from a hook
;; ============================================================
global hook_clear
hook_clear:
    cmp edi, NUM_HOOKS
    jge .done

    mov rax, SURFACE_BASE
    lea rax, [rax + STATE_OFFSET + ST_HOOKS]
    imul rcx, rdi, HOOK_ENTRY_SIZE
    add rax, rcx

    ; Zero count
    mov word [rax], 0

    ; Zero all pointers
    xor ecx, ecx
.clear_loop:
    cmp ecx, HOOK_MAX_HANDLERS
    jge .done
    mov qword [rax + 8 + rcx * 8], 0
    inc ecx
    jmp .clear_loop

.done:
    ret

;; ============================================================
;; hook_get_count(hook_id) → eax
;; edi=hook_id
;; ============================================================
global hook_get_count
hook_get_count:
    cmp edi, NUM_HOOKS
    jge .zero

    mov rax, SURFACE_BASE
    lea rax, [rax + STATE_OFFSET + ST_HOOKS]
    imul rcx, rdi, HOOK_ENTRY_SIZE
    add rax, rcx
    movzx eax, word [rax]
    ret
.zero:
    xor eax, eax
    ret
; hub.asm — Multi-agent communication hub (IRC-like)
;
; Single port, bidirectional sockets, plain text protocol.
; Learned from pitfalls: no paired ports, no timing dance, ignore SIGPIPE.
;
; @entry hub_main() -> noreturn     ; standalone hub entry
; @entry hub_init() -> void         ; init for embedding in UHMA
; @entry hub_poll() -> void         ; poll once (for UHMA integration)
;
; PROTOCOL:
;   Client -> Hub:
;     HELLO <name>\n        - register (max 31 chars)
;     @<name> <msg>\n       - send to specific client
;     * <msg>\n             - broadcast to all
;     <msg>\n               - broadcast (default)
;
;   Hub -> Client:
;     WELCOME\n             - registration ok
;     FROM <name>: <msg>\n  - message from client
;     JOINED <name>\n       - client joined
;     LEFT <name>\n         - client left
;     ERROR <msg>\n         - error
;
; BUILD: nasm -f elf64 hub.asm -o hub.o && ld hub.o -o hub
; or link with UHMA: add hub.o to link step

bits 64
default rel

; ============================================================================
; Constants
; ============================================================================

HUB_PORT        equ 7777
MAX_CLIENTS     equ 16
CLIENT_SIZE     equ 48          ; fd(4) + name(32) + state(4) + pad(8)
NAME_MAX        equ 31
BUF_SIZE        equ 4096

; Client states
STATE_EMPTY     equ 0
STATE_CONNECTED equ 1           ; connected but not registered
STATE_READY     equ 2           ; registered with name

; Syscall numbers
SYS_READ        equ 0
SYS_WRITE       equ 1
SYS_CLOSE       equ 3
SYS_POLL        equ 7
SYS_SOCKET      equ 41
SYS_ACCEPT      equ 43
SYS_BIND        equ 49
SYS_LISTEN      equ 50
SYS_SETSOCKOPT  equ 54
SYS_EXIT        equ 60
SYS_FCNTL       equ 72
SYS_RT_SIGACTION equ 13

; Socket constants
AF_INET         equ 2
SOCK_STREAM     equ 1
SOL_SOCKET      equ 1
SO_REUSEADDR    equ 2
INADDR_ANY      equ 0

; fcntl
F_GETFL         equ 3
F_SETFL         equ 4
O_NONBLOCK      equ 2048

; poll
POLLIN          equ 1
POLLHUP         equ 16
POLLERR         equ 8

; Signal
SIGPIPE         equ 13
SIG_IGN         equ 1

; ============================================================================
; Data Section
; ============================================================================

section .data

hub_running:    dq 1

; Listen socket
listen_fd:      dd -1

; Client table: MAX_CLIENTS entries of CLIENT_SIZE bytes
; Layout per entry: fd(4), name(32), state(4), pad(8)
align 8
client_table:   times (MAX_CLIENTS * CLIENT_SIZE) db 0

; Poll structures: listen socket + MAX_CLIENTS
; pollfd: fd(4), events(2), revents(2) = 8 bytes
align 8
poll_fds:       times ((MAX_CLIENTS + 1) * 8) db 0

; Buffers
align 8
recv_buf:       times BUF_SIZE db 0
send_buf:       times BUF_SIZE db 0

; Messages
msg_welcome:    db "WELCOME", 10, 0
msg_welcome_len equ $ - msg_welcome - 1

msg_error_name: db "ERROR name required", 10, 0
msg_error_name_len equ $ - msg_error_name - 1

msg_error_full: db "ERROR server full", 10, 0
msg_error_full_len equ $ - msg_error_full - 1

msg_error_unknown: db "ERROR unknown recipient", 10, 0
msg_error_unknown_len equ $ - msg_error_unknown - 1

msg_joined:     db "JOINED ", 0
msg_left:       db "LEFT ", 0
msg_from:       db "FROM ", 0

; sockaddr_in for bind (port 7777 = 0x1E61 -> network order 0x611E)
align 4
server_addr:
    dw AF_INET              ; sin_family
    dw 0x611E               ; sin_port (7777 in network byte order)
    dd INADDR_ANY           ; sin_addr
    times 8 db 0            ; padding

; ============================================================================
; Code Section
; ============================================================================

section .text

global _start
global hub_main
global hub_init
global hub_poll
global hub_stop

; ----------------------------------------------------------------------------
; _start - Entry point for standalone hub
; ----------------------------------------------------------------------------
_start:
hub_main:
    ; Ignore SIGPIPE (critical for TCP server)
    call ignore_sigpipe

    ; Initialize hub
    call hub_init
    test eax, eax
    js .init_failed

    ; Print startup message
    mov rdi, 1                  ; stdout
    lea rsi, [rel startup_msg]
    mov rdx, startup_msg_len
    mov rax, SYS_WRITE
    syscall

    ; Main loop
.loop:
    mov rax, [rel hub_running]
    test rax, rax
    jz .shutdown

    call hub_poll
    jmp .loop

.shutdown:
    call hub_cleanup
    xor edi, edi
    mov rax, SYS_EXIT
    syscall

.init_failed:
    mov rdi, 2                  ; stderr
    lea rsi, [rel init_fail_msg]
    mov rdx, init_fail_msg_len
    mov rax, SYS_WRITE
    syscall
    mov edi, 1
    mov rax, SYS_EXIT
    syscall

startup_msg:    db "HUB: listening on port 7777", 10, 0
startup_msg_len equ $ - startup_msg - 1

init_fail_msg:  db "HUB: init failed", 10, 0
init_fail_msg_len equ $ - init_fail_msg - 1

; ----------------------------------------------------------------------------
; ignore_sigpipe - Set SIGPIPE to SIG_IGN
; ----------------------------------------------------------------------------
ignore_sigpipe:
    push rbp
    mov rbp, rsp
    sub rsp, 32                 ; sigaction struct

    ; struct sigaction { handler, flags, restorer, mask }
    mov qword [rsp], SIG_IGN    ; sa_handler = SIG_IGN
    mov qword [rsp+8], 0        ; sa_flags
    mov qword [rsp+16], 0       ; sa_restorer
    mov qword [rsp+24], 0       ; sa_mask

    mov rdi, SIGPIPE
    lea rsi, [rsp]              ; new action
    xor rdx, rdx                ; old action (NULL)
    mov r10, 8                  ; sigsetsize
    mov rax, SYS_RT_SIGACTION
    syscall

    leave
    ret

; ----------------------------------------------------------------------------
; hub_init - Initialize hub (create listen socket)
; Returns: 0 on success, -1 on failure
; ----------------------------------------------------------------------------
hub_init:
    push rbp
    mov rbp, rsp
    push rbx

    ; Clear client table
    lea rdi, [rel client_table]
    mov rcx, MAX_CLIENTS * CLIENT_SIZE
    xor al, al
    rep stosb

    ; Mark all slots as empty (fd = -1)
    lea rdi, [rel client_table]
    mov ecx, MAX_CLIENTS
.clear_loop:
    mov dword [rdi], -1         ; fd = -1
    add rdi, CLIENT_SIZE
    dec ecx
    jnz .clear_loop

    ; Create socket
    mov rdi, AF_INET
    mov rsi, SOCK_STREAM
    xor rdx, rdx
    mov rax, SYS_SOCKET
    syscall
    test eax, eax
    js .fail
    mov ebx, eax                ; save socket fd
    mov [rel listen_fd], eax

    ; Set SO_REUSEADDR
    mov rdi, rbx
    mov rsi, SOL_SOCKET
    mov rdx, SO_REUSEADDR
    lea r10, [rel one_val]
    mov r8, 4
    mov rax, SYS_SETSOCKOPT
    syscall

    ; Set non-blocking
    mov rdi, rbx
    mov rsi, F_GETFL
    xor rdx, rdx
    mov rax, SYS_FCNTL
    syscall
    or eax, O_NONBLOCK
    mov rdi, rbx
    mov rsi, F_SETFL
    mov rdx, rax
    mov rax, SYS_FCNTL
    syscall

    ; Bind
    mov rdi, rbx
    lea rsi, [rel server_addr]
    mov rdx, 16
    mov rax, SYS_BIND
    syscall
    test eax, eax
    js .fail_close

    ; Listen
    mov rdi, rbx
    mov rsi, 16                 ; backlog
    mov rax, SYS_LISTEN
    syscall
    test eax, eax
    js .fail_close

    ; Success
    xor eax, eax
    pop rbx
    leave
    ret

.fail_close:
    mov rdi, rbx
    mov rax, SYS_CLOSE
    syscall
    mov dword [rel listen_fd], -1
.fail:
    mov eax, -1
    pop rbx
    leave
    ret

one_val:    dd 1

; ----------------------------------------------------------------------------
; hub_poll - Poll for events and handle them
; ----------------------------------------------------------------------------
hub_poll:
    push rbp
    mov rbp, rsp
    push rbx
    push r12
    push r13
    push r14
    push r15

    ; Build poll array
    ; First entry: listen socket
    lea rdi, [rel poll_fds]
    mov eax, [rel listen_fd]
    mov [rdi], eax              ; fd
    mov word [rdi+4], POLLIN    ; events
    mov word [rdi+6], 0         ; revents

    ; Add client sockets
    mov r12d, 1                 ; poll index (starts at 1)
    lea r13, [rel client_table]
    mov r14d, MAX_CLIENTS

.build_poll:
    mov eax, [r13]              ; client fd
    cmp eax, -1
    je .next_client

    ; Add to poll array
    lea rdi, [rel poll_fds]
    imul r15d, r12d, 8          ; offset = index * 8
    add rdi, r15
    mov [rdi], eax              ; fd
    mov word [rdi+4], POLLIN    ; events
    mov word [rdi+6], 0         ; revents
    inc r12d

.next_client:
    add r13, CLIENT_SIZE
    dec r14d
    jnz .build_poll

    ; Call poll
    lea rdi, [rel poll_fds]
    mov rsi, r12                ; nfds
    mov rdx, 100                ; timeout ms
    mov rax, SYS_POLL
    syscall

    test eax, eax
    jle .done                   ; no events or error

    ; Check listen socket for new connections
    lea rdi, [rel poll_fds]
    mov ax, [rdi+6]             ; revents
    test ax, POLLIN
    jz .check_clients
    call accept_client

.check_clients:
    ; Check each client for data
    mov r12d, 1                 ; poll index
    lea r13, [rel client_table]
    mov r14d, MAX_CLIENTS

.check_loop:
    mov eax, [r13]              ; client fd
    cmp eax, -1
    je .next_check

    ; Find this fd in poll array
    lea rdi, [rel poll_fds]
    imul r15d, r12d, 8
    add rdi, r15

    mov ax, [rdi+6]             ; revents
    test ax, POLLIN
    jz .check_hup

    ; Data available - read and process
    mov rdi, r13                ; client entry
    call handle_client_data

.check_hup:
    ; Recalculate poll entry (rdi was clobbered by function call)
    lea rdi, [rel poll_fds]
    imul r15d, r12d, 8
    add rdi, r15
    mov ax, [rdi+6]
    test ax, (POLLHUP | POLLERR)
    jz .next_poll_idx

    ; Client disconnected
    mov rdi, r13
    call remove_client
    jmp .next_check             ; don't increment poll index

.next_poll_idx:
    inc r12d
.next_check:
    add r13, CLIENT_SIZE
    dec r14d
    jnz .check_loop

.done:
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    leave
    ret

; ----------------------------------------------------------------------------
; accept_client - Accept new connection
; ----------------------------------------------------------------------------
accept_client:
    push rbp
    mov rbp, rsp
    push rbx
    push r12

    ; Accept connection
    mov edi, [rel listen_fd]
    xor rsi, rsi                ; addr = NULL
    xor rdx, rdx                ; addrlen = NULL
    mov rax, SYS_ACCEPT
    syscall

    test eax, eax
    js .done                    ; no connection or error
    mov ebx, eax                ; new client fd

    ; Set non-blocking
    mov rdi, rbx
    mov rsi, F_GETFL
    xor rdx, rdx
    mov rax, SYS_FCNTL
    syscall
    or eax, O_NONBLOCK
    mov rdi, rbx
    mov rsi, F_SETFL
    mov rdx, rax
    mov rax, SYS_FCNTL
    syscall

    ; Find empty slot
    lea r12, [rel client_table]
    mov ecx, MAX_CLIENTS
.find_slot:
    cmp dword [r12], -1
    je .found_slot
    add r12, CLIENT_SIZE
    dec ecx
    jnz .find_slot

    ; No slots - close connection
    mov rdi, rbx
    mov rax, SYS_CLOSE
    syscall

    ; Send error
    mov rdi, rbx
    lea rsi, [rel msg_error_full]
    mov rdx, msg_error_full_len
    mov rax, SYS_WRITE
    syscall
    jmp .done

.found_slot:
    ; Initialize client entry
    mov [r12], ebx              ; fd
    mov dword [r12+36], STATE_CONNECTED  ; state

    ; Clear name
    lea rdi, [r12+4]
    mov ecx, 32
    xor al, al
    rep stosb

.done:
    pop r12
    pop rbx
    leave
    ret

; ----------------------------------------------------------------------------
; handle_client_data - Read and process data from client
; rdi = client entry pointer
; Processes ALL lines in received data (multi-line support)
; ----------------------------------------------------------------------------
handle_client_data:
    push rbp
    mov rbp, rsp
    push rbx
    push r12
    push r13
    push r14
    push r15

    mov r12, rdi                ; client entry
    mov ebx, [r12]              ; client fd

    ; Read data
    mov rdi, rbx
    lea rsi, [rel recv_buf]
    mov rdx, BUF_SIZE - 1
    mov rax, SYS_READ
    syscall

    test eax, eax
    jle .disconnect             ; EOF or error

    ; r14 = current line start, r15 = end of data
    lea r14, [rel recv_buf]
    lea r15, [r14 + rax]        ; end of data
    mov byte [r15], 0           ; null terminate

.next_line:
    ; Skip leading whitespace/newlines
    cmp r14, r15
    jge .done
    mov al, [r14]
    cmp al, 10
    je .skip_char
    cmp al, 13
    je .skip_char
    cmp al, 0
    je .done
    jmp .process_line
.skip_char:
    inc r14
    jmp .next_line

.process_line:
    ; Find end of this line (newline or end of buffer)
    mov r13, r14                ; line start
.find_eol:
    cmp r13, r15
    jge .eol_found
    mov al, [r13]
    cmp al, 10
    je .eol_found
    cmp al, 13
    je .eol_found
    cmp al, 0
    je .eol_found
    inc r13
    jmp .find_eol
.eol_found:
    mov byte [r13], 0           ; null-terminate this line

    ; Now process line at r14
    ; Check for HELLO command
    mov rdi, r14
    cmp byte [rdi], 'H'
    jne .not_hello
    cmp dword [rdi], 'HELL'
    jne .not_hello
    cmp byte [rdi+4], 'O'
    jne .not_hello
    cmp byte [rdi+5], ' '
    jne .not_hello

    ; HELLO <name> - register client
    lea rsi, [rdi+6]            ; name starts after "HELLO "
    mov rdi, r12
    call register_client
    jmp .advance_line

.not_hello:
    ; Must be registered to send messages
    cmp dword [r12+36], STATE_READY
    jne .advance_line           ; ignore if not registered

    ; Check for @name (directed message)
    mov rdi, r14
    cmp byte [rdi], '@'
    jne .broadcast

    ; Directed message: @name message
    mov rdi, r12                ; from client
    lea rsi, [r14 + 1]          ; skip @
    call send_directed
    jmp .advance_line

.broadcast:
    ; Check for * prefix (explicit broadcast)
    mov rdi, r14
    cmp byte [rdi], '*'
    jne .default_broadcast
    cmp byte [rdi+1], ' '
    jne .default_broadcast
    lea rsi, [rdi+2]            ; skip "* "
    jmp .do_broadcast

.default_broadcast:
    mov rsi, r14

.do_broadcast:
    mov rdi, r12                ; from client
    call broadcast_message

.advance_line:
    ; Move to next line
    lea r14, [r13 + 1]          ; skip past the null we wrote
    jmp .next_line

.disconnect:
    mov rdi, r12
    call remove_client

.done:
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    leave
    ret

; ----------------------------------------------------------------------------
; register_client - Register client with name
; rdi = client entry, rsi = name (null or newline terminated)
; ----------------------------------------------------------------------------
register_client:
    push rbp
    mov rbp, rsp
    push rbx
    push r12
    push r13

    mov r12, rdi                ; client entry
    mov r13, rsi                ; name
    mov ebx, [r12]              ; client fd

    ; Skip leading whitespace
.skip_ws:
    mov al, [r13]
    cmp al, ' '
    je .next_ws
    cmp al, 9                   ; tab
    jne .check_name
.next_ws:
    inc r13
    jmp .skip_ws

.check_name:
    ; Check name not empty
    mov al, [r13]
    cmp al, 0
    je .error_name
    cmp al, 10                  ; newline
    je .error_name
    cmp al, 13                  ; CR
    je .error_name

    ; Copy name (max 31 chars)
    lea rdi, [r12+4]            ; name field
    mov rsi, r13
    mov ecx, NAME_MAX
.copy_name:
    lodsb
    cmp al, 0
    je .name_done
    cmp al, 10
    je .name_done
    cmp al, 13
    je .name_done
    cmp al, ' '
    je .name_done
    stosb
    dec ecx
    jnz .copy_name
.name_done:
    mov byte [rdi], 0           ; null terminate

    ; Set state to ready
    mov dword [r12+36], STATE_READY

    ; Send WELCOME
    mov rdi, rbx
    lea rsi, [rel msg_welcome]
    mov rdx, msg_welcome_len
    mov rax, SYS_WRITE
    syscall

    ; Broadcast JOINED
    mov rdi, r12
    call broadcast_joined
    jmp .done

.error_name:
    mov rdi, rbx
    lea rsi, [rel msg_error_name]
    mov rdx, msg_error_name_len
    mov rax, SYS_WRITE
    syscall

.done:
    pop r13
    pop r12
    pop rbx
    leave
    ret

; ----------------------------------------------------------------------------
; broadcast_joined - Notify all clients that someone joined
; rdi = client entry that joined
; ----------------------------------------------------------------------------
broadcast_joined:
    push rbp
    mov rbp, rsp
    push rbx
    push r12
    push r13
    push r14

    mov r12, rdi                ; new client

    ; Build message: "JOINED <name>\n"
    lea rdi, [rel send_buf]
    lea rsi, [rel msg_joined]
.copy_joined:
    lodsb
    test al, al
    jz .add_name_j
    stosb
    jmp .copy_joined
.add_name_j:
    lea rsi, [r12+4]            ; name
.copy_name_j:
    lodsb
    test al, al
    jz .add_nl_j
    stosb
    jmp .copy_name_j
.add_nl_j:
    mov byte [rdi], 10
    inc rdi

    ; Calculate length
    lea rax, [rel send_buf]
    sub rdi, rax
    mov r13, rdi                ; message length

    ; Send to all OTHER registered clients
    lea r14, [rel client_table]
    mov ebx, MAX_CLIENTS
.send_joined:
    cmp dword [r14], -1
    je .next_joined
    cmp r14, r12                ; skip sender
    je .next_joined
    cmp dword [r14+36], STATE_READY
    jne .next_joined

    mov edi, [r14]              ; fd
    lea rsi, [rel send_buf]
    mov rdx, r13
    mov rax, SYS_WRITE
    syscall

.next_joined:
    add r14, CLIENT_SIZE
    dec ebx
    jnz .send_joined

    pop r14
    pop r13
    pop r12
    pop rbx
    leave
    ret

; ----------------------------------------------------------------------------
; broadcast_message - Send message to all clients
; rdi = from client entry, rsi = message
; ----------------------------------------------------------------------------
broadcast_message:
    push rbp
    mov rbp, rsp
    push rbx
    push r12
    push r13
    push r14
    push r15

    mov r12, rdi                ; from client
    mov r13, rsi                ; message

    ; Build message: "FROM <name>: <message>\n"
    lea rdi, [rel send_buf]
    lea rsi, [rel msg_from]
.copy_from:
    lodsb
    test al, al
    jz .add_sender
    stosb
    jmp .copy_from
.add_sender:
    lea rsi, [r12+4]            ; sender name
.copy_sender:
    lodsb
    test al, al
    jz .add_colon
    stosb
    jmp .copy_sender
.add_colon:
    mov byte [rdi], ':'
    mov byte [rdi+1], ' '
    add rdi, 2

    ; Copy message
    mov rsi, r13
.copy_msg:
    lodsb
    cmp al, 0
    je .msg_done
    cmp al, 10
    je .msg_done
    cmp al, 13
    je .msg_done
    stosb
    jmp .copy_msg
.msg_done:
    mov byte [rdi], 10
    inc rdi

    ; Calculate length
    lea rax, [rel send_buf]
    sub rdi, rax
    mov r14, rdi                ; message length

    ; Send to all OTHER registered clients
    lea r15, [rel client_table]
    mov ebx, MAX_CLIENTS
.send_bc:
    cmp dword [r15], -1
    je .next_bc
    cmp r15, r12                ; skip sender
    je .next_bc
    cmp dword [r15+36], STATE_READY
    jne .next_bc

    mov edi, [r15]              ; fd
    lea rsi, [rel send_buf]
    mov rdx, r14
    mov rax, SYS_WRITE
    syscall

.next_bc:
    add r15, CLIENT_SIZE
    dec ebx
    jnz .send_bc

    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    leave
    ret

; ----------------------------------------------------------------------------
; send_directed - Send message to specific client
; rdi = from client entry, rsi = "@name message" (without @)
; ----------------------------------------------------------------------------
send_directed:
    push rbp
    mov rbp, rsp
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub rsp, 40                 ; local: target name buffer

    mov r12, rdi                ; from client
    mov r13, rsi                ; @name message

    ; Extract target name
    lea rdi, [rsp]              ; target name buffer
    mov rsi, r13
    mov ecx, NAME_MAX
.extract_name:
    lodsb
    cmp al, ' '
    je .name_extracted
    cmp al, 0
    je .name_extracted
    cmp al, 10
    je .name_extracted
    stosb
    dec ecx
    jnz .extract_name
.name_extracted:
    mov byte [rdi], 0
    mov r14, rsi                ; message starts here

    ; Find target client by name
    lea r15, [rel client_table]
    mov ebx, MAX_CLIENTS
.find_target:
    cmp dword [r15], -1
    je .next_target
    cmp dword [r15+36], STATE_READY
    jne .next_target

    ; Compare names
    lea rdi, [r15+4]            ; client name
    lea rsi, [rsp]              ; target name
.cmp_names:
    mov al, [rdi]
    mov cl, [rsi]
    cmp al, cl
    jne .next_target
    test al, al
    jz .found_target
    inc rdi
    inc rsi
    jmp .cmp_names

.next_target:
    add r15, CLIENT_SIZE
    dec ebx
    jnz .find_target

    ; Target not found - send error
    mov edi, [r12]              ; sender fd
    lea rsi, [rel msg_error_unknown]
    mov rdx, msg_error_unknown_len
    mov rax, SYS_WRITE
    syscall
    jmp .done

.found_target:
    ; Build message: "FROM <sender>: <message>\n"
    lea rdi, [rel send_buf]
    lea rsi, [rel msg_from]
.copy_from_d:
    lodsb
    test al, al
    jz .add_sender_d
    stosb
    jmp .copy_from_d
.add_sender_d:
    lea rsi, [r12+4]            ; sender name
.copy_sender_d:
    lodsb
    test al, al
    jz .add_colon_d
    stosb
    jmp .copy_sender_d
.add_colon_d:
    mov byte [rdi], ':'
    mov byte [rdi+1], ' '
    add rdi, 2

    ; Copy message
    mov rsi, r14
.copy_msg_d:
    lodsb
    cmp al, 0
    je .msg_done_d
    cmp al, 10
    je .msg_done_d
    cmp al, 13
    je .msg_done_d
    stosb
    jmp .copy_msg_d
.msg_done_d:
    mov byte [rdi], 10
    inc rdi

    ; Calculate length
    lea rax, [rel send_buf]
    sub rdi, rax
    mov r13, rdi

    ; Send to target
    mov edi, [r15]              ; target fd
    lea rsi, [rel send_buf]
    mov rdx, r13
    mov rax, SYS_WRITE
    syscall

.done:
    add rsp, 40
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    leave
    ret

; ----------------------------------------------------------------------------
; remove_client - Remove client and notify others
; rdi = client entry
; ----------------------------------------------------------------------------
remove_client:
    push rbp
    mov rbp, rsp
    push rbx
    push r12
    push r13
    push r14

    mov r12, rdi                ; client entry
    mov ebx, [r12]              ; fd

    ; Check if was registered (to send LEFT)
    cmp dword [r12+36], STATE_READY
    jne .just_close

    ; Build LEFT message
    lea rdi, [rel send_buf]
    lea rsi, [rel msg_left]
.copy_left:
    lodsb
    test al, al
    jz .add_name_l
    stosb
    jmp .copy_left
.add_name_l:
    lea rsi, [r12+4]            ; name
.copy_name_l:
    lodsb
    test al, al
    jz .add_nl_l
    stosb
    jmp .copy_name_l
.add_nl_l:
    mov byte [rdi], 10
    inc rdi

    lea rax, [rel send_buf]
    sub rdi, rax
    mov r13, rdi                ; length

    ; Send LEFT to all other clients
    lea r14, [rel client_table]
    mov ecx, MAX_CLIENTS
.send_left:
    cmp dword [r14], -1
    je .next_left
    cmp r14, r12
    je .next_left
    cmp dword [r14+36], STATE_READY
    jne .next_left

    push rcx
    mov edi, [r14]
    lea rsi, [rel send_buf]
    mov rdx, r13
    mov rax, SYS_WRITE
    syscall
    pop rcx

.next_left:
    add r14, CLIENT_SIZE
    dec ecx
    jnz .send_left

.just_close:
    ; Close socket
    mov rdi, rbx
    mov rax, SYS_CLOSE
    syscall

    ; Mark slot as empty
    mov dword [r12], -1
    mov dword [r12+36], STATE_EMPTY

    pop r14
    pop r13
    pop r12
    pop rbx
    leave
    ret

; ----------------------------------------------------------------------------
; hub_stop - Signal hub to stop
; ----------------------------------------------------------------------------
hub_stop:
    mov qword [rel hub_running], 0
    ret

; ----------------------------------------------------------------------------
; hub_cleanup - Close all sockets
; ----------------------------------------------------------------------------
hub_cleanup:
    push rbp
    mov rbp, rsp
    push rbx
    push r12

    ; Close listen socket
    mov edi, [rel listen_fd]
    cmp edi, -1
    je .close_clients
    mov rax, SYS_CLOSE
    syscall
    mov dword [rel listen_fd], -1

.close_clients:
    lea r12, [rel client_table]
    mov ebx, MAX_CLIENTS
.close_loop:
    mov edi, [r12]
    cmp edi, -1
    je .next_close
    mov rax, SYS_CLOSE
    syscall
    mov dword [r12], -1
.next_close:
    add r12, CLIENT_SIZE
    dec ebx
    jnz .close_loop

    pop r12
    pop rbx
    leave
    ret
; hub_client.asm — Hub client for UHMA
;
; Connects UHMA to the multi-agent hub on port 7777.
; UHMA can receive commands from other agents and send responses.
;
; @entry hub_client_init() -> eax (0=success, -1=fail)
; @entry hub_client_poll() -> eax (1=has data, 0=no data, -1=disconnected)
; @entry hub_client_read(buf, len) -> bytes read
; @entry hub_client_send(msg) -> bytes sent
; @entry hub_client_close() -> void
;
; INTEGRATION:
;   In repl.asm, add hub socket to poll alongside stdin.
;   Messages from hub: "FROM <name>: <command>" -> extract command, process, respond
;   Responses: hub_client_send("result text")

bits 64
default rel

; ============================================================================
; Constants
; ============================================================================

HUB_PORT        equ 7777
HUB_BUF_SIZE    equ 4096

; Syscalls
SYS_READ        equ 0
SYS_WRITE       equ 1
SYS_CLOSE       equ 3
SYS_POLL        equ 7
SYS_SOCKET      equ 41
SYS_CONNECT     equ 42
SYS_FCNTL       equ 72

; Socket
AF_INET         equ 2
SOCK_STREAM     equ 1

; fcntl
F_GETFL         equ 3
F_SETFL         equ 4
O_NONBLOCK      equ 2048

; poll
POLLIN          equ 1

; ============================================================================
; Data
; ============================================================================

section .data

global hub_fd
global hub_connected
global hub_registered

hub_fd:         dd -1           ; hub socket fd
hub_connected:  dd 0            ; 1 if connected
hub_registered: dd 0            ; 1 if registered with name

; Hub address (127.0.0.1:7777)
hub_addr:
    dw AF_INET                  ; sin_family
    dw 0x611E                   ; sin_port (7777 in network byte order)
    dd 0x0100007F               ; sin_addr (127.0.0.1 in network byte order)
    times 8 db 0                ; padding

; Registration message
hub_hello:      db "HELLO uhma", 10, 0
hub_hello_len   equ $ - hub_hello - 1

; Response prefix for hub (identifies responses from UHMA)
hub_prefix:     db "* ", 0      ; broadcast responses

section .bss

hub_recv_buf:   resb HUB_BUF_SIZE
hub_send_buf:   resb HUB_BUF_SIZE

; ============================================================================
; Code
; ============================================================================

section .text

global hub_client_init
global hub_client_poll
global hub_client_read
global hub_client_send
global hub_client_broadcast
global hub_client_close
global hub_client_get_fd
global hub_extract_command

; ----------------------------------------------------------------------------
; hub_client_init - Connect to hub and register as "uhma"
; Returns: 0 on success, -1 on failure
; ----------------------------------------------------------------------------
hub_client_init:
    push rbp
    mov rbp, rsp
    push rbx

    ; Create socket
    mov rdi, AF_INET
    mov rsi, SOCK_STREAM
    xor rdx, rdx
    mov rax, SYS_SOCKET
    syscall
    test eax, eax
    js .fail
    mov ebx, eax
    mov [rel hub_fd], eax

    ; Connect to hub
    mov rdi, rbx
    lea rsi, [rel hub_addr]
    mov rdx, 16
    mov rax, SYS_CONNECT
    syscall
    test eax, eax
    js .fail_close

    ; Set non-blocking
    mov rdi, rbx
    mov rsi, F_GETFL
    xor rdx, rdx
    mov rax, SYS_FCNTL
    syscall
    or eax, O_NONBLOCK
    mov rdi, rbx
    mov rsi, F_SETFL
    mov rdx, rax
    mov rax, SYS_FCNTL
    syscall

    ; Send HELLO
    mov rdi, rbx
    lea rsi, [rel hub_hello]
    mov rdx, hub_hello_len
    mov rax, SYS_WRITE
    syscall
    test eax, eax
    js .fail_close

    mov dword [rel hub_connected], 1
    mov dword [rel hub_registered], 1

    ; Success
    xor eax, eax
    pop rbx
    leave
    ret

.fail_close:
    mov rdi, rbx
    mov rax, SYS_CLOSE
    syscall
    mov dword [rel hub_fd], -1
.fail:
    mov dword [rel hub_connected], 0
    mov eax, -1
    pop rbx
    leave
    ret

; ----------------------------------------------------------------------------
; hub_client_poll - Check if hub has data (non-blocking)
; Returns: 1 if data available, 0 if not, -1 if disconnected
; ----------------------------------------------------------------------------
hub_client_poll:
    push rbp
    mov rbp, rsp
    sub rsp, 16                 ; pollfd struct

    mov eax, [rel hub_fd]
    cmp eax, -1
    je .disconnected

    ; Setup pollfd
    mov [rsp], eax              ; fd
    mov word [rsp+4], POLLIN    ; events
    mov word [rsp+6], 0         ; revents

    ; Poll with 0 timeout (non-blocking check)
    lea rdi, [rsp]
    mov rsi, 1                  ; nfds
    xor rdx, rdx                ; timeout = 0
    mov rax, SYS_POLL
    syscall

    test eax, eax
    jle .no_data

    ; Check revents
    mov ax, [rsp+6]
    test ax, POLLIN
    jz .no_data

    mov eax, 1                  ; has data
    leave
    ret

.no_data:
    xor eax, eax
    leave
    ret

.disconnected:
    mov eax, -1
    leave
    ret

; ----------------------------------------------------------------------------
; hub_client_read - Read data from hub
; rdi = buffer, rsi = max length
; Returns: bytes read, 0 if no data, -1 if error/disconnected
; ----------------------------------------------------------------------------
hub_client_read:
    push rbp
    mov rbp, rsp
    push rbx
    push r12
    push r13

    mov r12, rdi                ; buffer
    mov r13, rsi                ; max len

    mov ebx, [rel hub_fd]
    cmp ebx, -1
    je .error

    mov rdi, rbx
    mov rsi, r12
    mov rdx, r13
    mov rax, SYS_READ
    syscall

    ; Check result
    test eax, eax
    jle .check_error
    jmp .done

.check_error:
    ; 0 = EOF (disconnect), negative = error
    cmp eax, 0
    je .disconnected
    ; EAGAIN/EWOULDBLOCK = no data (non-blocking)
    cmp eax, -11                ; EAGAIN
    je .no_data
    cmp eax, -35                ; EWOULDBLOCK
    je .no_data
    jmp .error

.no_data:
    xor eax, eax
    jmp .done

.disconnected:
    call hub_client_close
.error:
    mov eax, -1

.done:
    pop r13
    pop r12
    pop rbx
    leave
    ret

; ----------------------------------------------------------------------------
; hub_client_send - Send message to hub (directed to specific client)
; rdi = target name (null = broadcast), rsi = message
; Returns: bytes sent or -1
; ----------------------------------------------------------------------------
hub_client_send:
    push rbp
    mov rbp, rsp
    push rbx
    push r12
    push r13

    mov r12, rdi                ; target (or NULL for broadcast)
    mov r13, rsi                ; message

    mov ebx, [rel hub_fd]
    cmp ebx, -1
    je .error

    ; Build message in hub_send_buf
    lea rdi, [rel hub_send_buf]

    ; If target is NULL, broadcast with "*"
    test r12, r12
    jz .broadcast

    ; Directed: "@target message\n"
    mov byte [rdi], '@'
    inc rdi
    mov rsi, r12
.copy_target:
    lodsb
    test al, al
    jz .add_space
    stosb
    jmp .copy_target
.add_space:
    mov byte [rdi], ' '
    inc rdi
    jmp .copy_message

.broadcast:
    ; Broadcast: "* message\n"
    mov byte [rdi], '*'
    mov byte [rdi+1], ' '
    add rdi, 2

.copy_message:
    mov rsi, r13
.copy_msg:
    lodsb
    cmp al, 0
    je .msg_done
    cmp al, 10
    je .msg_done
    stosb
    jmp .copy_msg
.msg_done:
    mov byte [rdi], 10          ; newline
    inc rdi

    ; Calculate length
    lea rax, [rel hub_send_buf]
    sub rdi, rax
    mov r13, rdi                ; length

    ; Send
    mov rdi, rbx
    lea rsi, [rel hub_send_buf]
    mov rdx, r13
    mov rax, SYS_WRITE
    syscall
    jmp .done

.error:
    mov eax, -1
.done:
    pop r13
    pop r12
    pop rbx
    leave
    ret

; ----------------------------------------------------------------------------
; hub_client_broadcast - Broadcast message to all hub clients
; rdi = message
; Returns: bytes sent or -1
; ----------------------------------------------------------------------------
hub_client_broadcast:
    push rdi
    xor rdi, rdi                ; target = NULL (broadcast)
    pop rsi                     ; message
    jmp hub_client_send

; ----------------------------------------------------------------------------
; hub_client_close - Close hub connection
; ----------------------------------------------------------------------------
hub_client_close:
    push rbp
    mov rbp, rsp

    mov edi, [rel hub_fd]
    cmp edi, -1
    je .done

    mov rax, SYS_CLOSE
    syscall

    mov dword [rel hub_fd], -1
    mov dword [rel hub_connected], 0
    mov dword [rel hub_registered], 0

.done:
    leave
    ret

; ----------------------------------------------------------------------------
; hub_client_get_fd - Get hub socket fd (for poll integration)
; Returns: fd or -1 if not connected
; ----------------------------------------------------------------------------
hub_client_get_fd:
    mov eax, [rel hub_fd]
    ret

; ----------------------------------------------------------------------------
; hub_extract_command - Extract command from "FROM <name>: <command>"
; rdi = input buffer
; rsi = output buffer for sender name (32 bytes)
; rdx = output buffer for command
; Returns: 1 if valid FROM message, 0 otherwise
; ----------------------------------------------------------------------------
hub_extract_command:
    push rbp
    mov rbp, rsp
    push rbx
    push r12
    push r13
    push r14

    mov r12, rdi                ; input
    mov r13, rsi                ; name output
    mov r14, rdx                ; command output

    ; Check for "FROM " prefix
    cmp dword [r12], 'FROM'
    jne .not_from
    cmp byte [r12+4], ' '
    jne .not_from

    ; Skip "FROM "
    add r12, 5

    ; Copy sender name until ':'
    mov rdi, r13
    mov ecx, 31
.copy_name:
    mov al, [r12]
    cmp al, ':'
    je .name_done
    cmp al, 0
    je .not_from
    cmp al, 10
    je .not_from
    stosb
    inc r12
    dec ecx
    jnz .copy_name
.name_done:
    mov byte [rdi], 0           ; null terminate name

    ; Skip ": "
    inc r12                     ; skip ':'
    cmp byte [r12], ' '
    jne .copy_cmd
    inc r12                     ; skip space

.copy_cmd:
    ; Copy command
    mov rdi, r14
.copy_command:
    mov al, [r12]
    cmp al, 0
    je .cmd_done
    cmp al, 10
    je .cmd_done
    cmp al, 13
    je .cmd_done
    stosb
    inc r12
    jmp .copy_command
.cmd_done:
    mov byte [rdi], 0           ; null terminate command

    mov eax, 1                  ; success
    jmp .done

.not_from:
    xor eax, eax
.done:
    pop r14
    pop r13
    pop r12
    pop rbx
    leave
    ret
; introspect.asm — Semantic self-model, bootstrap, and organic regulation
;
; THIS IS WHERE SELF-AWARENESS LIVES.
;
; @entry tick_workers()               → autonomous idle processing (called by REPL on timeout)
; @entry introspect_scan_regions()    → builds semantic self-model (SELF-AWARE reading)
; @entry introspect_repair_cycle()    → processes RFLAG_NEEDS_REPAIR regions
; @entry metacog_report()             → REPL 'intro' command output
;
; AUTONOMOUS BEHAVIOR (tick_workers):
;   Called by REPL on poll timeout. Makes UHMA do useful work when idle:
;   1. Bootstrap: if SELF-AWARE < 0.3 → force observe_cycle (build self-model)
;   2. Startup consolidation: if regions > 100 and fresh session → dream_cycle
;   3. Organic pressure: decay + check thresholds → fire appropriate cycles
;
; SEMANTIC SELF-MODEL:
;   introspect_scan_regions() encodes each region via encode_region_to_vector()
;   Similar code → similar vectors. Superposed into ST_SELF_MODEL_VEC.
;   After observe cycle: SELF-AWARE reading typically 0.9+ (97.3% measured)
;
; ORGANIC PRESSURE (thresholds):
;   dream_pressure     > 0.5 → dream_cycle()      (misses accumulate)
;   observe_pressure   > 1.0 → observe_cycle()    (accuracy variance)
;   introspect_pressure > 0.75 → repair_cycle()   (SURPRISE_SELF events)
;
; SELF/OTHER BOUNDARY:
;   SURPRISE_SELF → introspect pressure (I was wrong about myself)
;   SURPRISE_OUTCOME → dream pressure (world surprised me)
;
; @calls vsa_ops.asm:encode_region_to_vector
; @calls receipt.asm:meta_recommend_strategy, intro_get_self_awareness
; @calls dreams.asm:dream_cycle, observe.asm:observe_cycle
; @calledby repl.asm (on poll timeout)
;
%include "syscalls.inc"
%include "constants.inc"

section .data
    intro_hdr:          db "[INTROSPECT] ", 0
    intro_decode_msg:   db "Decoded region: ctx=0x", 0
    intro_pred_msg:     db " pred=0x", 0
    intro_sem_msg:      db " sem=", 0
    intro_antic_msg:    db "[ANTICIPATE] Signal materializing: token=0x", 0
    intro_antic_accum:  db "[ANTICIPATE] Accumulating: token=0x", 0
    intro_conf_msg:     db " conf=", 0
    intro_organic_msg:  db "[ORGANIC] ", 0
    intro_dream_trig:   db "Dream fired (miss pressure)", 10, 0
    intro_observe_trig: db "Observe fired (accuracy drift)", 10, 0
    intro_evolve_trig:  db "Evolve fired (stagnation)", 10, 0
    intro_introspect_trig: db "Introspect fired (self-surprise)", 10, 0
    intro_repair_msg:   db "[SELF-REPAIR] Examining region that violated self-model", 10, 0
    intro_flatness_msg: db "[OSCILLATION] Flatness detected — perturbing", 10, 0
    intro_nl:           db 10, 0

    ; Semantic signature names
    sem_unknown:    db "UNKNOWN", 0
    sem_cmp_je:     db "CMP-JE-RET", 0
    sem_chain:      db "CMP-CHAIN", 0
    sem_multi:      db "MULTI-CMP", 0
    sem_schema:     db "SCHEMA", 0
    sem_relay:      db "CALL-RELAY", 0

    align 8
    antic_decay:    dq 0.97     ; anticipation decays each step (slow fade)
    pressure_decay: dq 0.985    ; pressure decays toward zero (slow drain)
    pressure_boost: dq 0.04     ; miss adds this to dream pressure (gentle)
    observe_boost:  dq 0.02     ; accuracy variance adds to observe pressure
    evolve_boost:   dq 0.01     ; stagnation adds to evolve pressure (rare event)
    one_f64:        dq 1.0
    zero_f64:       dq 0.0

section .text

extern print_cstr
extern print_hex32
extern print_f32
extern print_u64
extern print_newline
extern dream_cycle
extern observe_cycle
extern evolve_cycle
extern fire_hook
extern drives_check
extern journey_step
extern modify_generalize
extern modify_specialize
extern meta_recommend_strategy  ; from receipt.asm - causal model guidance
extern intro_get_self_awareness ; from receipt.asm - SELF-AWARE ratio
extern encode_region_to_vector  ; from vsa_ops.asm - semantic code encoding
extern holo_superpose_f64       ; from vsa.asm - holographic accumulation
extern holo_normalize_f64       ; from vsa.asm - prevent magnitude explosion

;; ============================================================
;; introspect_region(region_ptr) → fills cache entry
;; rdi = pointer to region header
;; Decodes the x86 instructions in the region's code body.
;; Extracts: context hash compared, token predicted, structure type.
;; Returns: eax = semantic signature (RSEM_*)
;; ============================================================
global introspect_region
introspect_region:
    push rbx
    push r12
    push r13
    push r14

    mov rbx, rdi                ; region header ptr
    xor r12d, r12d              ; decoded ctx_hash
    xor r13d, r13d              ; decoded pred_token
    mov r14d, RSEM_UNKNOWN      ; semantic signature

    ; Get code length
    movzx ecx, word [rbx + RHDR_CODE_LEN]
    test ecx, ecx
    jz .decode_done
    cmp ecx, 3                  ; minimum useful region
    jl .decode_done

    ; Point to code body (after 128-byte header)
    lea rsi, [rbx + RHDR_SIZE]

    ; --- Decode first instruction ---
    ; Dispatch regions start with: cmp eax, imm32 (opcode 0x3D, 5 bytes)
    ; or: 81 /7 (cmp [reg], imm32)
    cmp byte [rsi], 0x3D        ; cmp eax, imm32?
    je .decode_cmp_eax

    cmp byte [rsi], 0x81        ; cmp r/m32, imm32?
    je .decode_cmp_rm

    ; Check for call instruction (relay pattern)
    cmp byte [rsi], 0xE8        ; call rel32?
    je .decode_call

    ; Check for mov eax, imm32 (direct token return)
    cmp byte [rsi], 0xB8        ; mov eax, imm32?
    je .decode_mov_eax

    jmp .decode_done

.decode_cmp_eax:
    ; 0x3D imm32 — comparing context hash
    mov r12d, [rsi + 1]         ; extract the context hash being compared
    mov r14d, RSEM_CMP_JE_RET  ; assume simple pattern

    ; Check if lower nibble is 0 → schema (masked comparison)
    test r12d, 0x0F
    jnz .find_predicted_token
    mov r14d, RSEM_SCHEMA
    jmp .find_predicted_token

.decode_cmp_rm:
    ; 81 FF imm32 — cmp edi, imm32 (less common but valid)
    cmp byte [rsi + 1], 0xFF   ; ModRM for edi
    jne .decode_done
    mov r12d, [rsi + 2]         ; extract context hash
    mov r14d, RSEM_CMP_JE_RET
    jmp .find_predicted_token

.decode_call:
    ; E8 rel32 — relay to another function
    mov r14d, RSEM_CALL_RELAY
    jmp .decode_done

.decode_mov_eax:
    ; B8 imm32 — direct token return (no comparison, always returns)
    mov r13d, [rsi + 1]         ; the token being returned
    mov r14d, RSEM_CMP_JE_RET
    jmp .decode_done

.find_predicted_token:
    ; Scan forward for mov eax, imm32 (0xB8) — the predicted token
    movzx ecx, word [rbx + RHDR_CODE_LEN]
    lea rdi, [rsi + 5]          ; skip past the cmp instruction
    lea rdx, [rsi + rcx]       ; end of code

    ; Also check for multiple cmp instructions (MULTI_CMP pattern)
    xor eax, eax               ; cmp_count
.scan_code:
    cmp rdi, rdx
    jge .decode_done

    cmp byte [rdi], 0xB8       ; mov eax, imm32?
    je .found_token

    cmp byte [rdi], 0x3D       ; another cmp eax, imm32?
    jne .scan_next
    inc eax
    cmp eax, 1
    jle .scan_next
    mov r14d, RSEM_MULTI_CMP   ; multiple comparisons
    jmp .scan_next

.found_token:
    mov r13d, [rdi + 1]         ; extract predicted token
    ; Check if there's a jmp/call after (chain pattern)
    lea rax, [rdi + 5]
    cmp rax, rdx
    jge .decode_done
    cmp byte [rax], 0xE9       ; jmp rel32? (chain to next region)
    je .is_chain
    cmp byte [rax], 0xEB       ; jmp rel8?
    je .is_chain
    jmp .decode_done

.is_chain:
    cmp r14d, RSEM_SCHEMA
    je .decode_done             ; keep SCHEMA if already set
    mov r14d, RSEM_CMP_JE_CHAIN
    jmp .decode_done

.scan_next:
    inc rdi
    jmp .scan_code

.decode_done:
    ; Return values in registers for caller to use
    ; eax = semantic signature
    ; r12d = ctx_hash decoded
    ; r13d = pred_token decoded
    mov eax, r14d

    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; introspect_scan_regions()
;; Scan all active regions, decode their semantics, fill cache.
;; This is the system reading its own code as data.
;; ============================================================
global introspect_scan_regions
introspect_scan_regions:
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub rsp, (HOLO_VEC_BYTES + 8)               ; temp vector + 8 alignment (5 pushes = odd)

    mov rbx, SURFACE_BASE
    lea r12, [rbx + REGION_TABLE_OFFSET]  ; region table base
    mov r13d, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    xor r14d, r14d              ; region index
    xor r15d, r15d              ; cache write index

.scan_loop:
    cmp r14d, r13d
    jge .scan_done
    cmp r15d, ST_INTRO_CACHE_CAP
    jge .scan_done

    ; Get region table entry
    imul eax, r14d, RTE_SIZE
    lea rsi, [r12 + rax]

    ; Check if active
    movzx ecx, word [rsi + RTE_FLAGS]
    test ecx, RFLAG_ACTIVE
    jz .scan_next
    test ecx, RFLAG_CONDEMNED
    jnz .scan_next

    ; Get region address
    mov rdi, [rsi + RTE_ADDR]
    test rdi, rdi
    jz .scan_next

    ; Decode this region
    push rsi
    push r14
    call introspect_region      ; → eax = semantic sig, r12d/r13d decoded
    pop r14
    pop rsi

    ; Fill cache entry
    lea rcx, [rbx + STATE_OFFSET + ST_INTRO_CACHE]
    imul edx, r15d, ST_INTRO_ENTRY_SIZE
    add rcx, rdx

    mov rdi, [rsi + RTE_ADDR]
    mov [rcx + ICE_REGION_PTR], rdi
    ; Note: introspect_region clobbered r12/r13, but we saved them
    ; Actually we need to re-decode or restructure. Let me use the return value approach.
    ; For now store what we have:
    mov [rcx + ICE_SEMANTIC_SIG], eax

    ; Compute accuracy for this region
    mov edi, [rsi + RTE_HITS]
    mov edx, [rsi + RTE_MISSES]
    add edx, edi
    test edx, edx
    jz .store_zero_acc
    cvtsi2ss xmm0, edi
    cvtsi2ss xmm1, edx
    divss xmm0, xmm1
    movss [rcx + ICE_ACCURACY], xmm0
    jmp .count_neighbors

.store_zero_acc:
    xor eax, eax
    mov [rcx + ICE_ACCURACY], eax

.count_neighbors:
    ; Count non-null neighbor pointers
    mov rdi, [rsi + RTE_ADDR]
    xor edx, edx               ; neighbor count
    cmp qword [rdi + RHDR_NEXT_A], 0
    je .n1
    inc edx
.n1:
    cmp qword [rdi + RHDR_EXCITE_A], 0
    je .n2
    inc edx
.n2:
    cmp qword [rdi + RHDR_EXCITE_B], 0
    je .n3
    inc edx
.n3:
    cmp qword [rdi + RHDR_INHIBIT_A], 0
    je .n4
    inc edx
.n4:
    mov [rcx + ICE_NEIGHBOR_COUNT], dx

    ; === SEMANTIC SELF-MODEL: encode region code into self-model ===
    ; This builds a holographic representation of "what code I am"
    ; using semantic encoding where similar code → similar vectors
    push rsi                        ; save RTE pointer
    mov rdi, [rsi + RTE_ADDR]       ; region header
    lea rsi, [rsp + 8]              ; temp vector on stack (offset for push)
    call encode_region_to_vector    ; encode region semantically

    ; Superpose into self-model: ST_SELF_MODEL_VEC += region_vec
    lea rdi, [rbx + STATE_OFFSET + ST_SELF_MODEL_VEC]
    lea rsi, [rsp + 8]              ; temp vector
    call holo_superpose_f64

    ; Normalize to prevent magnitude explosion
    lea rdi, [rbx + STATE_OFFSET + ST_SELF_MODEL_VEC]
    call holo_normalize_f64
    pop rsi                         ; restore RTE pointer

    inc r15d

.scan_next:
    inc r14d
    jmp .scan_loop

.scan_done:
    add rsp, (HOLO_VEC_BYTES + 8)               ; free temp vector + alignment
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; update_anticipatory(token_id, confidence)
;; edi = token_id, xmm0 = confidence (f64)
;; Called from dispatch with sub-threshold holographic signals.
;; Accumulates weak signals — "things forming in the distance."
;; When accumulated confidence crosses threshold → signal materializes.
;; ============================================================
global update_anticipatory
update_anticipatory:
    push rbx
    push r12
    push r13
    sub rsp, 16                 ; save xmm0
    movsd [rsp], xmm0

    mov r12d, edi               ; token_id
    mov rbx, SURFACE_BASE

    ; Check if signal is above noise floor
    movsd xmm1, [rsp]
    mov rax, ANTIC_SIGNAL_FLOOR
    movq xmm2, rax
    ucomisd xmm1, xmm2
    jbe .antic_done             ; below noise floor, ignore

    ; Search anticipatory buffer for this token
    lea rdi, [rbx + STATE_OFFSET + ST_ANTIC_BUF]
    xor ecx, ecx               ; index
    mov r13d, -1                ; free slot (-1 = none found)

.antic_search:
    cmp ecx, ST_ANTIC_CAP
    jge .antic_not_found

    imul edx, ecx, ST_ANTIC_ENTRY_SIZE
    lea rsi, [rdi + rdx]

    ; Check if this slot has our token
    cmp dword [rsi + ABE_TOKEN_ID], r12d
    je .antic_found

    ; Track first empty slot
    cmp dword [rsi + ABE_TOKEN_ID], 0
    jne .antic_search_next
    cmp r13d, -1
    jne .antic_search_next
    mov r13d, ecx               ; remember free slot

.antic_search_next:
    inc ecx
    jmp .antic_search

.antic_found:
    ; Accumulate confidence
    imul edx, ecx, ST_ANTIC_ENTRY_SIZE
    lea rsi, [rdi + rdx]
    movsd xmm0, [rsi + ABE_ACCUM_CONF]
    addsd xmm0, [rsp]          ; add new signal
    movsd [rsi + ABE_ACCUM_CONF], xmm0
    inc dword [rsi + ABE_HIT_COUNT]

    ; Update last_step
    mov eax, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    mov [rsi + ABE_LAST_STEP], eax

    ; Check if materialized (accumulated > threshold)
    mov rax, ANTIC_MATERIALIZE_THRESH
    movq xmm1, rax
    ucomisd xmm0, xmm1
    jbe .antic_done

    ; MATERIALIZED — a distant signal has become concrete
    ; Print notification
    push rcx
    push rdi
    lea rdi, [rel intro_antic_msg]
    call print_cstr
    mov edi, r12d
    call print_hex32
    lea rdi, [rel intro_nl]
    call print_cstr
    pop rdi
    pop rcx

    ; Increment materialized counter
    inc dword [rbx + STATE_OFFSET + ST_ANTIC_FIRED]

    ; Clear this slot (it has materialized, no longer anticipatory)
    imul edx, ecx, ST_ANTIC_ENTRY_SIZE
    lea rsi, [rdi + rdx]
    mov qword [rsi], 0
    mov qword [rsi + 8], 0
    mov qword [rsi + 16], 0
    jmp .antic_done

.antic_not_found:
    ; No existing entry — use free slot if available
    cmp r13d, -1
    je .antic_done              ; buffer full, oldest will decay away

    imul edx, r13d, ST_ANTIC_ENTRY_SIZE
    lea rsi, [rdi + rdx]
    mov [rsi + ABE_TOKEN_ID], r12d
    movsd xmm0, [rsp]
    movsd [rsi + ABE_ACCUM_CONF], xmm0
    mov eax, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    mov [rsi + ABE_LAST_STEP], eax
    mov dword [rsi + ABE_HIT_COUNT], 1

    ; Update active count
    inc dword [rbx + STATE_OFFSET + ST_ANTIC_ACTIVE]

.antic_done:
    add rsp, 16
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; decay_anticipatory()
;; Decay all anticipatory signals each step.
;; Signals that don't get reinforced fade — the distance stays distant.
;; ============================================================
global decay_anticipatory
decay_anticipatory:
    push rbx
    mov rbx, SURFACE_BASE
    lea rdi, [rbx + STATE_OFFSET + ST_ANTIC_BUF]
    xor ecx, ecx

.decay_loop:
    cmp ecx, ST_ANTIC_CAP
    jge .decay_done

    imul edx, ecx, ST_ANTIC_ENTRY_SIZE
    lea rsi, [rdi + rdx]

    ; Skip empty slots
    cmp dword [rsi + ABE_TOKEN_ID], 0
    je .decay_next

    ; Decay accumulated confidence
    movsd xmm0, [rsi + ABE_ACCUM_CONF]
    mulsd xmm0, [rel antic_decay]
    movsd [rsi + ABE_ACCUM_CONF], xmm0

    ; If decayed below noise floor, clear the slot
    mov rax, ANTIC_SIGNAL_FLOOR
    movq xmm1, rax
    ucomisd xmm0, xmm1
    ja .decay_next

    ; Signal faded away — clear slot
    mov qword [rsi], 0
    mov qword [rsi + 8], 0
    mov qword [rsi + 16], 0
    dec dword [rbx + STATE_OFFSET + ST_ANTIC_ACTIVE]

.decay_next:
    inc ecx
    jmp .decay_loop

.decay_done:
    pop rbx
    ret

;; ============================================================
;; update_organic_pressure()
;; Called after each token. Updates miss pressure, dream/observe/evolve
;; pressure based on actual system dynamics — not timers, not commands.
;; Triggers actions when pressure exceeds thresholds.
;; ============================================================
global update_organic_pressure
update_organic_pressure:
    push rbx
    push r12
    sub rsp, 8                  ; alignment

    mov rbx, SURFACE_BASE
    lea r12, [rbx + STATE_OFFSET]

    ; JOURNEY: record update_organic_pressure
    mov edi, TRACE_UPDATE_ORGANIC
    call journey_step

    ; --- Update miss pressure (EMA of recent miss rate) ---
    ; miss_pressure = alpha * (was_miss ? 1.0 : 0.0) + (1-alpha) * miss_pressure
    movsd xmm0, [r12 + ST_MISS_PRESSURE]    ; current pressure

    ; Check if last step was a miss (surprise type != NONE)
    cmp dword [r12 + ST_SURPRISE_TYPE], SURPRISE_NONE
    je .no_miss_boost

    ; Was a miss — boost pressure
    movsd xmm1, [rel pressure_boost]
    addsd xmm0, xmm1
    jmp .cap_pressure

.no_miss_boost:
    ; Decay pressure toward zero
    mulsd xmm0, [rel pressure_decay]

.cap_pressure:
    ; Cap at 1.0
    movsd xmm1, [rel one_f64]
    ucomisd xmm0, xmm1
    jbe .store_miss_pressure
    movsd xmm0, xmm1
.store_miss_pressure:
    movsd [r12 + ST_MISS_PRESSURE], xmm0

    ; --- Accumulate dream pressure from miss pressure ---
    movsd xmm1, [r12 + ST_MISS_PRESSURE]
    movsd xmm2, [r12 + ST_DREAM_PRESSURE]
    ; dream_pressure += miss_pressure * boost_factor
    mov rax, MISS_PRESSURE_ALPHA
    movq xmm3, rax
    mulsd xmm1, xmm3
    addsd xmm2, xmm1
    ; Decay dream pressure
    mulsd xmm2, [rel pressure_decay]
    movsd [r12 + ST_DREAM_PRESSURE], xmm2

    ; --- Check dream pressure threshold → ORGANIC DREAM ---
    mov rax, DREAM_PRESSURE_THRESH
    movq xmm3, rax
    ucomisd xmm2, xmm3
    jbe .check_observe

    ; --- Energy check: can we afford to dream? ---
    movsd xmm4, [rbx + STATE_OFFSET + ST_ENERGY]
    mov rax, ENERGY_STARVATION
    movq xmm5, rax
    ucomisd xmm4, xmm5
    jbe .check_observe         ; too hungry to dream — skip

    ; ORGANIC DREAM: miss pressure demands consolidation
    ; Deduct energy cost
    mov rax, ENERGY_DREAM_COST
    movq xmm5, rax
    subsd xmm4, xmm5
    xorpd xmm6, xmm6
    maxsd xmm4, xmm6
    movsd [rbx + STATE_OFFSET + ST_ENERGY], xmm4
    addsd xmm5, [rbx + STATE_OFFSET + ST_ENERGY_SPENT]
    movsd [rbx + STATE_OFFSET + ST_ENERGY_SPENT], xmm5

    push rdi
    lea rdi, [rel intro_organic_msg]
    call print_cstr
    lea rdi, [rel intro_dream_trig]
    call print_cstr
    pop rdi

    inc dword [r12 + ST_ORGANIC_DREAMS]

    ; Reset dream pressure (action taken)
    movsd xmm0, [rel zero_f64]
    movsd [r12 + ST_DREAM_PRESSURE], xmm0

    ; Fire the dream
    call dream_cycle

.check_observe:
    ; --- Accumulate observe pressure from accuracy variance ---
    movss xmm0, [r12 + ST_ACCURACY_VARIANCE]
    cvtss2sd xmm0, xmm0        ; convert to f64
    movsd xmm1, [r12 + ST_OBSERVE_PRESSURE]
    movsd xmm2, [rel observe_boost]
    mulsd xmm0, xmm2
    addsd xmm1, xmm0
    mulsd xmm1, [rel pressure_decay]
    movsd [r12 + ST_OBSERVE_PRESSURE], xmm1

    ; Check observe pressure threshold
    mov rax, OBSERVE_PRESSURE_THRESH
    movq xmm2, rax
    ucomisd xmm1, xmm2
    jbe .check_evolve

    ; ORGANIC OBSERVE: accuracy is drifting, system needs to look at itself
    push rdi
    lea rdi, [rel intro_organic_msg]
    call print_cstr
    lea rdi, [rel intro_observe_trig]
    call print_cstr
    pop rdi

    inc dword [r12 + ST_ORGANIC_OBSERVES]

    ; Reset observe pressure
    movsd xmm0, [rel zero_f64]
    movsd [r12 + ST_OBSERVE_PRESSURE], xmm0

    ; Fire observation
    call observe_cycle
    call drives_check

.check_evolve:
    ; --- Accumulate evolve pressure from stagnation (flatness) ---
    ; Only accumulates when system has been flat LONGER than the minimum window.
    ; This is organic: evolution only fires from sustained stagnation, not brief pauses.
    mov eax, [r12 + ST_FLATNESS_COUNT]
    cmp eax, OSCILLATION_MIN
    jle .evolve_decay_only      ; not yet stagnant, just decay
    sub eax, OSCILLATION_MIN    ; excess flatness beyond threshold
    cvtsi2sd xmm0, eax
    movsd xmm1, [rel evolve_boost]
    mulsd xmm0, xmm1
    movsd xmm1, [r12 + ST_EVOLVE_PRESSURE]
    addsd xmm1, xmm0
    mulsd xmm1, [rel pressure_decay]
    movsd [r12 + ST_EVOLVE_PRESSURE], xmm1
    jmp .check_evolve_fire
.evolve_decay_only:
    movsd xmm1, [r12 + ST_EVOLVE_PRESSURE]
    mulsd xmm1, [rel pressure_decay]
    movsd [r12 + ST_EVOLVE_PRESSURE], xmm1

.check_evolve_fire:
    ; Check evolve pressure threshold
    mov rax, EVOLVE_PRESSURE_THRESH
    movq xmm2, rax
    ucomisd xmm1, xmm2
    jbe .pressure_done

    ; ORGANIC EVOLVE: system is stagnant, needs mutation
    push rdi
    lea rdi, [rel intro_organic_msg]
    call print_cstr
    lea rdi, [rel intro_evolve_trig]
    call print_cstr
    pop rdi

    inc dword [r12 + ST_ORGANIC_EVOLVES]

    ; Reset evolve pressure and flatness
    movsd xmm0, [rel zero_f64]
    movsd [r12 + ST_EVOLVE_PRESSURE], xmm0
    mov dword [r12 + ST_FLATNESS_COUNT], 0

    ; Fire evolution
    call evolve_cycle

.check_introspect:
    ; --- SELF-SURPRISE HANDLING: Introspect pressure from self-model violations ---
    ; This is the self/other boundary: when the system's confident predictions about
    ; ITSELF are wrong, it triggers introspection rather than world-learning.
    ; Introspect pressure is boosted in dispatch.asm on SURPRISE_SELF events.
    movsd xmm1, [r12 + ST_INTROSPECT_PRESSURE]
    mulsd xmm1, [rel pressure_decay]    ; decay toward zero
    movsd [r12 + ST_INTROSPECT_PRESSURE], xmm1

    ; Check introspect pressure threshold
    mov rax, INTROSPECT_PRESSURE_THRESH
    movq xmm2, rax
    ucomisd xmm1, xmm2
    jbe .pressure_done

    ; ORGANIC INTROSPECT: self-model is broken, examine regions that violated it
    push rdi
    lea rdi, [rel intro_organic_msg]
    call print_cstr
    lea rdi, [rel intro_introspect_trig]
    call print_cstr
    pop rdi

    ; Reset introspect pressure (action taken)
    movsd xmm0, [rel zero_f64]
    movsd [r12 + ST_INTROSPECT_PRESSURE], xmm0

    ; Fire self-repair cycle
    call introspect_repair_cycle

.pressure_done:
    add rsp, 8
    pop r12
    pop rbx
    ret

;; ============================================================
;; update_oscillation()
;; Track whether the system is oscillating (alive) or flat (dead).
;; If flat for too long, inject perturbation via presence field.
;; ============================================================
global update_oscillation
update_oscillation:
    push rbx
    mov rbx, SURFACE_BASE
    lea rdi, [rbx + STATE_OFFSET]

    ; Shift accuracy history: prev_prev = prev, prev = current
    movsd xmm0, [rdi + ST_PREV_ACCURACY]
    movsd [rdi + ST_PREV_PREV_ACC], xmm0

    ; Current accuracy → prev
    movss xmm1, [rdi + ST_DRIVES + 0]      ; current accuracy (f32)
    cvtss2sd xmm1, xmm1
    movsd [rdi + ST_PREV_ACCURACY], xmm1

    ; Compute oscillation amplitude = |current - prev| + |prev - prev_prev|
    movsd xmm2, [rdi + ST_PREV_PREV_ACC]
    subsd xmm1, xmm0           ; current - prev
    ; Absolute value
    movsd xmm3, xmm1
    movsd xmm4, [rel zero_f64]
    ucomisd xmm3, xmm4
    jae .pos1
    movsd xmm5, [rel zero_f64]
    subsd xmm5, xmm3
    movsd xmm3, xmm5
.pos1:
    subsd xmm0, xmm2           ; prev - prev_prev
    movsd xmm4, [rel zero_f64]
    ucomisd xmm0, xmm4
    jae .pos2
    movsd xmm5, [rel zero_f64]
    subsd xmm5, xmm0
    movsd xmm0, xmm5
.pos2:
    addsd xmm3, xmm0           ; total amplitude
    movsd [rdi + ST_OSCILLATION_AMP], xmm3

    ; Check flatness
    mov rax, FLATNESS_THRESH
    movq xmm1, rax
    ucomisd xmm3, xmm1
    ja .not_flat

    ; System is flat — increment flatness counter
    inc dword [rdi + ST_FLATNESS_COUNT]

    ; If flat for too long, perturb via presence
    cmp dword [rdi + ST_FLATNESS_COUNT], OSCILLATION_MIN
    jl .osc_done

    ; PERTURBATION: inject novelty pressure through presence field
    ; Boost arousal, reduce stability, increase surprise
    lea rsi, [rbx + STATE_OFFSET + ST_PRESENCE]
    ; Arousal += 0.3
    mov eax, 0x3E99999A         ; 0.3f
    movd xmm0, eax
    addss xmm0, [rsi + PRES_AROUSAL * 4]
    movss [rsi + PRES_AROUSAL * 4], xmm0
    ; Stability -= 0.2
    mov eax, 0x3E4CCCCD         ; 0.2f
    movd xmm0, eax
    movss xmm1, [rsi + PRES_STABILITY * 4]
    subss xmm1, xmm0
    movss [rsi + PRES_STABILITY * 4], xmm1
    ; Temperature += 0.25
    mov eax, 0x3E800000         ; 0.25f
    movd xmm0, eax
    addss xmm0, [rsi + PRES_TEMPERATURE * 4]
    movss [rsi + PRES_TEMPERATURE * 4], xmm0

    ; Print flatness warning
    push rdi
    lea rdi, [rel intro_flatness_msg]
    call print_cstr
    pop rdi

    jmp .osc_done

.not_flat:
    ; System is oscillating — reset flatness counter
    mov dword [rdi + ST_FLATNESS_COUNT], 0

.osc_done:
    pop rbx
    ret

;; ============================================================
;; update_presence_dispatch()
;; Let the presence field influence dispatch mode selection.
;; High arousal → explore. High fatigue → fast. High focus → deliberate.
;; The presence IS the experience influencing behavior.
;; ============================================================
global update_presence_dispatch
update_presence_dispatch:
    push rbx
    mov rbx, SURFACE_BASE
    lea rdi, [rbx + STATE_OFFSET]
    lea rsi, [rbx + STATE_OFFSET + ST_PRESENCE]

    ; Read presence dimensions
    movss xmm0, [rsi + PRES_AROUSAL * 4]     ; arousal
    movss xmm1, [rsi + PRES_FOCUS * 4]       ; focus
    movss xmm2, [rsi + PRES_FATIGUE * 4]     ; fatigue
    movss xmm3, [rsi + PRES_TEMPERATURE * 4] ; temperature

    ; Compute risk appetite = arousal - fatigue + temperature * 0.5
    movss xmm4, xmm0           ; arousal
    subss xmm4, xmm2           ; - fatigue
    mov eax, 0x3F000000         ; 0.5f
    movd xmm5, eax
    mulss xmm5, xmm3           ; temperature * 0.5
    addss xmm4, xmm5           ; risk appetite
    movss [rdi + ST_PRES_RISK_APPETITE], xmm4

    ; Compute dispatch bias = focus - arousal * 0.3
    movss xmm5, xmm1           ; focus
    mov eax, 0x3E99999A         ; 0.3f
    movd xmm6, eax
    mulss xmm6, xmm0           ; arousal * 0.3
    subss xmm5, xmm6
    movss [rdi + ST_PRES_DISPATCH_BIAS], xmm5

    ; Mode selection based on presence state and energy:
    ; Starving → FAST always (survival mode)
    ; High fatigue → FAST (conserve energy)
    ; High arousal + low focus → EXPLORE
    ; High focus + low arousal → DELIBERATE
    ; Otherwise → drive-selected or BEST

    ; Check energy starvation first (overrides everything)
    movsd xmm5, [rbx + STATE_OFFSET + ST_ENERGY]
    mov rax, ENERGY_STARVATION
    movq xmm6, rax
    ucomisd xmm5, xmm6
    ja .energy_ok
    ; STARVING: force minimal-cost dispatch
    mov dword [rdi + ST_DISPATCH_MODE], DMODE_FAST
    jmp .pres_done
.energy_ok:

    mov eax, 0x3F19999A         ; 0.6f threshold
    movd xmm5, eax

    ; Check fatigue first (fatigue overrides — tired system goes fast)
    comiss xmm2, xmm5
    jbe .check_arousal
    mov dword [rdi + ST_DISPATCH_MODE], DMODE_FAST
    jmp .pres_done

.check_arousal:
    ; High arousal + high temperature → EXPLORE
    addss xmm0, xmm3           ; arousal + temperature
    mov eax, 0x3F800000         ; 1.0f
    movd xmm5, eax
    comiss xmm0, xmm5
    jbe .check_focus
    mov dword [rdi + ST_DISPATCH_MODE], DMODE_EXPLORE
    jmp .pres_done

.check_focus:
    ; High focus → DELIBERATE
    mov eax, 0x3F333333         ; 0.7f
    movd xmm5, eax
    comiss xmm1, xmm5
    jbe .pres_done              ; leave mode as-is (drive-selected)
    mov dword [rdi + ST_DISPATCH_MODE], DMODE_DELIBERATE

.pres_done:
    pop rbx
    ret

;; ============================================================
;; Topological Metacognition Reporting
;; ============================================================

section .data
    meta_msg:       db "[METACOG] ", 0
    meta_feeling:   db "feeling=", 0
    meta_neutral:   db "NEUTRAL", 0
    meta_confident: db "CONFIDENT", 0
    meta_anxious:   db "ANXIOUS", 0
    meta_conf_val:  db " confidence=", 0
    meta_mode:      db " → mode=", 0
    meta_fast:      db "FAST", 0
    meta_deliberate: db "DELIBERATE", 0
    meta_other:     db "OTHER", 0
    meta_updates:   db " (updates=", 0
    meta_close:     db ")", 0

section .text

extern confidence_query
extern confidence_get_feeling
extern confidence_get_update_count

;; ============================================================
;; metacog_report(ctx_hash)
;; edi=ctx_hash
;; Prints the system's metacognitive state for this context:
;; feeling (neutral/confident/anxious), raw confidence score,
;; and resulting dispatch mode.
;; Actively queries the confidence vector (doesn't just read stored values).
;; ============================================================
global metacog_report
metacog_report:
    push rbx
    push r12
    sub rsp, 24               ; space for confidence value (f64)

    mov r12d, edi             ; save ctx_hash
    mov rbx, SURFACE_BASE

    ; Query confidence for this specific context
    mov edi, r12d
    call confidence_query     ; → xmm0 = confidence score (f64)
    movsd [rsp], xmm0         ; save confidence value

    ; Get feeling for this context
    mov edi, r12d
    call confidence_get_feeling  ; → eax = feeling enum
    mov [rsp + 8], eax        ; save feeling

    ; Print header
    lea rdi, [rel meta_msg]
    call print_cstr

    ; Print feeling label
    lea rdi, [rel meta_feeling]
    call print_cstr

    ; Print feeling
    mov eax, [rsp + 8]
    cmp eax, FEELING_CONFIDENT
    je .print_confident
    cmp eax, FEELING_ANXIOUS
    je .print_anxious
    lea rdi, [rel meta_neutral]
    jmp .printed_feeling
.print_confident:
    lea rdi, [rel meta_confident]
    jmp .printed_feeling
.print_anxious:
    lea rdi, [rel meta_anxious]
.printed_feeling:
    call print_cstr

    ; Print raw confidence value (convert f64 to f32 for printing)
    lea rdi, [rel meta_conf_val]
    call print_cstr
    movsd xmm0, [rsp]         ; reload confidence
    cvtsd2ss xmm0, xmm0       ; f64 → f32
    call print_f32

    ; Print resulting mode
    lea rdi, [rel meta_mode]
    call print_cstr
    mov eax, [rbx + STATE_OFFSET + ST_DISPATCH_MODE]
    cmp eax, DMODE_FAST
    je .mode_fast
    cmp eax, DMODE_DELIBERATE
    je .mode_deliberate
    lea rdi, [rel meta_other]
    jmp .printed_mode
.mode_fast:
    lea rdi, [rel meta_fast]
    jmp .printed_mode
.mode_deliberate:
    lea rdi, [rel meta_deliberate]
.printed_mode:
    call print_cstr

    ; Print update count for debugging
    lea rdi, [rel meta_updates]
    call print_cstr
    call confidence_get_update_count
    mov rdi, rax
    call print_u64
    lea rdi, [rel meta_close]
    call print_cstr

    call print_newline

    add rsp, 24
    pop r12
    pop rbx
    ret

;; ============================================================
;; STRUCTURAL ABSORPTION: Learning Grammar from Ingested Code
;; "You are what you eat" — valid code becomes high-value schema
;; ============================================================

section .data
    absorb_msg:         db "[ABSORB] Analyzing ingested code (", 0
    absorb_bytes:       db " bytes)...", 10, 0
    absorb_valid:       db "[ABSORB] VALID — storing as schema", 10, 0
    absorb_invalid:     db "[ABSORB] INVALID — rejected (", 0
    absorb_errors:      db " errors)", 10, 0
    absorb_energy:      db "[ABSORB] Energy gained from valid schema: ", 0

    align 8
    schema_energy:      dq 5.0    ; energy reward for absorbing valid code

section .text

extern verify_abstract
extern holo_store
extern vsa_energy_to_valence

;; ============================================================
;; absorb_code(code_ptr, code_len) -> eax (1=absorbed, 0=rejected)
;; rdi=code pointer, rsi=code length
;; Applies the Logic Probe to ingested code. If valid:
;;   - Stores in holographic memory as high-value schema
;;   - Rewards system with energy (valid code = nutritious food)
;; If invalid:
;;   - Rejected with negative valence (bad food = poison)
;; ============================================================
global absorb_code
absorb_code:
    push rbx
    push r12
    push r13
    push r14
    sub rsp, VCS_SIZE + 16    ; verification state + locals

    mov r12, rdi              ; code ptr
    mov r13, rsi              ; code len
    mov rbx, SURFACE_BASE

    ; Print analysis message
    lea rdi, [rel absorb_msg]
    call print_cstr
    mov rdi, r13
    call print_u64
    lea rdi, [rel absorb_bytes]
    call print_cstr

    ; Skip if too short or too long
    cmp r13, 3
    jl .absorb_reject
    cmp r13, 4096             ; max schema size
    jg .absorb_reject

    ; Run abstract interpreter
    mov rdi, r12              ; code
    mov rsi, r13              ; length
    lea rdx, [rsp]            ; output state
    call verify_abstract
    mov r14d, eax             ; save error count

    test eax, eax
    jnz .absorb_reject

    ; --- VALID CODE: Store as schema ---
    lea rdi, [rel absorb_valid]
    call print_cstr

    ; Generate hash from code bytes
    xor eax, eax
    mov rcx, r13
    mov rsi, r12
.hash_code:
    test rcx, rcx
    jz .hash_done
    movzx edx, byte [rsi]
    imul eax, eax, 31
    add eax, edx
    inc rsi
    dec rcx
    jmp .hash_code
.hash_done:
    mov r14d, eax             ; code hash

    ; Store in holographic memory with high strength
    mov edi, r14d             ; ctx = code_hash
    mov esi, r14d             ; token = code_hash (self-reference)
    mov rax, 0x3FF0000000000000  ; 1.0 f64 (max strength)
    movq xmm0, rax
    call holo_store

    ; Reward energy
    movsd xmm0, [rbx + STATE_OFFSET + ST_ENERGY]
    addsd xmm0, [rel schema_energy]
    mov rax, ENERGY_MAX
    movq xmm1, rax
    minsd xmm0, xmm1
    movsd [rbx + STATE_OFFSET + ST_ENERGY], xmm0

    ; Print energy gained
    lea rdi, [rel absorb_energy]
    call print_cstr
    movsd xmm0, [rel schema_energy]
    cvtsd2ss xmm0, xmm0
    call print_f32
    call print_newline

    mov eax, 1                ; return absorbed
    jmp .absorb_done

.absorb_reject:
    lea rdi, [rel absorb_invalid]
    call print_cstr
    mov edi, r14d
    call print_u64
    lea rdi, [rel absorb_errors]
    call print_cstr

    xor eax, eax              ; return rejected

.absorb_done:
    add rsp, VCS_SIZE + 16
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; HIVE WORKER SYSTEM: Pheromone-Driven Swarm Intelligence
;; Replaces centralized REPL control with pheromone-triggered
;; worker castes. Each caste responds to its pheromone channel
;; and performs specialized work when threshold exceeded.
;; ============================================================

section .data
    worker_trigger_msg: db "[HIVE] ", 0
    worker_dream:       db "Dream worker activated (pheromone=", 0
    worker_observe:     db "Observe worker activated (pheromone=", 0
    worker_evolve:      db "Evolve worker activated (pheromone=", 0
    worker_compact:     db "Compact worker activated", 10, 0
    worker_rest:        db "Rest worker activated (fatigue=", 0
    worker_ingest:      db "Self-ingest worker activated (SELF-AWARE=", 0
    worker_bootstrap:   db "Bootstrap: low self-awareness, triggering observe", 10, 0
    worker_startup_dream: db "Startup consolidation: prior knowledge found, dreaming...", 10, 0
    worker_close:       db ")", 10, 0

    align 8
    pheromone_threshold: dq 0.5   ; default activation threshold
    self_aware_threshold: dq 0.3  ; below this, trigger self-observation
    self_ingest_done: dq 0        ; flag: have we ingested own code this session?
    startup_consolidation_done: dq 0  ; flag: have we dreamed on startup?

section .text

extern dream_cycle
extern observe_cycle
extern evolve_cycle
extern region_compact

;; ============================================================
;; tick_workers()
;; Called each processing step. Scans pheromone levels and
;; activates worker castes when thresholds exceeded.
;; This is the hive's swarm intelligence — distributed control.
;; Returns: eax = number of workers activated
;; ============================================================
global tick_workers
tick_workers:
global tick_regulators          ; legacy alias
tick_regulators:
    push rbx
    push r12
    push r13
    sub rsp, 8                ; alignment (3 pushes = odd, need 8 more)

    mov rbx, SURFACE_BASE
    xor r12d, r12d            ; actions triggered

    ; === BOOTSTRAP CHECK ===
    ; If self-awareness is low and we haven't bootstrapped, trigger observe
    cmp qword [rel self_ingest_done], 0
    jne .skip_bootstrap

    ; Get current self-awareness reading
    call intro_get_self_awareness     ; xmm0 = SELF-AWARE ratio
    movsd xmm1, [rel self_aware_threshold]
    ucomisd xmm0, xmm1
    jae .skip_bootstrap               ; already self-aware enough

    ; Self-awareness is low - boost observe pressure to trigger self-observation
    lea rdi, [rel worker_bootstrap]
    call print_cstr

    ; Set observe_pressure = 1.0 to force observe_cycle
    mov rax, 0x3FF0000000000000       ; 1.0 f64
    mov [rbx + STATE_OFFSET + ST_OBSERVE_PRESSURE], rax

    ; Mark bootstrap done so we don't spam
    mov qword [rel self_ingest_done], 1

.skip_bootstrap:
    ; === STARTUP CONSOLIDATION ===
    ; If we have prior knowledge (regions > 100) and haven't consolidated, trigger dream
    cmp qword [rel startup_consolidation_done], 0
    jne .skip_startup_dream

    ; Check region count
    mov eax, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    cmp eax, 100
    jl .skip_startup_dream        ; fresh start, skip

    ; Have prior knowledge - trigger consolidation
    lea rdi, [rel worker_trigger_msg]
    call print_cstr
    lea rdi, [rel worker_startup_dream]
    call print_cstr

    ; Set dream pressure high to trigger dream_cycle
    mov rax, 0x3FF0000000000000   ; 1.0 f64
    mov [rbx + STATE_OFFSET + ST_DREAM_PRESSURE], rax

    mov qword [rel startup_consolidation_done], 1

.skip_startup_dream:
    ; Load threshold
    movsd xmm7, [rel pheromone_threshold]

    ; --- Check dream pheromone ---
    movsd xmm0, [rbx + STATE_OFFSET + ST_DREAM_PRESSURE]
    ucomisd xmm0, xmm7
    jbe .check_observe

    ; Dream pheromone exceeded — activate consolidation worker
    lea rdi, [rel worker_trigger_msg]
    call print_cstr
    lea rdi, [rel worker_dream]
    call print_cstr
    movsd xmm0, [rbx + STATE_OFFSET + ST_DREAM_PRESSURE]
    cvtsd2ss xmm0, xmm0
    call print_f32
    lea rdi, [rel worker_close]
    call print_cstr

    call dream_cycle
    inc r12d

    ; Reset pressure after firing
    xorpd xmm0, xmm0
    movsd [rbx + STATE_OFFSET + ST_DREAM_PRESSURE], xmm0

.check_observe:
    ; --- Check observe pheromone ---
    movsd xmm0, [rbx + STATE_OFFSET + ST_OBSERVE_PRESSURE]
    ucomisd xmm0, xmm7
    jbe .check_evolve

    ; Observe pheromone exceeded — activate observation worker
    lea rdi, [rel worker_trigger_msg]
    call print_cstr
    lea rdi, [rel worker_observe]
    call print_cstr
    movsd xmm0, [rbx + STATE_OFFSET + ST_OBSERVE_PRESSURE]
    cvtsd2ss xmm0, xmm0
    call print_f32
    lea rdi, [rel worker_close]
    call print_cstr

    call observe_cycle
    inc r12d

    ; Reset pressure
    xorpd xmm0, xmm0
    movsd [rbx + STATE_OFFSET + ST_OBSERVE_PRESSURE], xmm0

.check_evolve:
    ; --- Check evolve pheromone ---
    movsd xmm0, [rbx + STATE_OFFSET + ST_EVOLVE_PRESSURE]
    ucomisd xmm0, xmm7
    jbe .check_fatigue

    ; Evolve pheromone exceeded — activate evolution worker
    lea rdi, [rel worker_trigger_msg]
    call print_cstr
    lea rdi, [rel worker_evolve]
    call print_cstr
    movsd xmm0, [rbx + STATE_OFFSET + ST_EVOLVE_PRESSURE]
    cvtsd2ss xmm0, xmm0
    call print_f32
    lea rdi, [rel worker_close]
    call print_cstr

    call evolve_cycle
    inc r12d

    ; Reset pressure
    xorpd xmm0, xmm0
    movsd [rbx + STATE_OFFSET + ST_EVOLVE_PRESSURE], xmm0

.check_fatigue:
    ; --- Check fatigue (high fatigue = rest worker) ---
    movss xmm0, [rbx + STATE_OFFSET + ST_PRESENCE + PRES_FATIGUE * 4]
    cvtss2sd xmm0, xmm0
    mov rax, 0x3FE8000000000000  ; 0.75 threshold for rest
    movq xmm1, rax
    ucomisd xmm0, xmm1
    jbe .workers_done

    ; Fatigue high — activate rest worker (reduce activity)
    lea rdi, [rel worker_trigger_msg]
    call print_cstr
    lea rdi, [rel worker_rest]
    call print_cstr
    movss xmm0, [rbx + STATE_OFFSET + ST_PRESENCE + PRES_FATIGUE * 4]
    call print_f32
    lea rdi, [rel worker_close]
    call print_cstr

    ; Rest worker action: reduce fatigue, slow down dispatch
    movss xmm0, [rbx + STATE_OFFSET + ST_PRESENCE + PRES_FATIGUE * 4]
    mov eax, 0x3F000000        ; 0.5f multiplier
    movd xmm1, eax
    mulss xmm0, xmm1
    movss [rbx + STATE_OFFSET + ST_PRESENCE + PRES_FATIGUE * 4], xmm0

    inc r12d

.workers_done:
    mov eax, r12d             ; return workers activated
    add rsp, 8
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; release_pheromone(channel, delta)
;; edi=pheromone channel (PHERO_*), xmm0=delta (f64)
;; Adds delta to the specified pheromone level.
;; This is how events signal worker castes in the hive.
;; ============================================================
global release_pheromone
release_pheromone:
global accrue_pressure          ; legacy alias
accrue_pressure:
    mov rax, SURFACE_BASE

    cmp edi, RPRES_DREAM
    je .accrue_dream
    cmp edi, RPRES_OBSERVE
    je .accrue_observe
    cmp edi, RPRES_EVOLVE
    je .accrue_evolve
    ret                       ; unknown source

.accrue_dream:
    addsd xmm0, [rax + STATE_OFFSET + ST_DREAM_PRESSURE]
    ; Clamp to [0, 1]
    xorpd xmm1, xmm1
    maxsd xmm0, xmm1
    mov rcx, 0x3FF0000000000000
    movq xmm1, rcx
    minsd xmm0, xmm1
    movsd [rax + STATE_OFFSET + ST_DREAM_PRESSURE], xmm0
    ret

.accrue_observe:
    addsd xmm0, [rax + STATE_OFFSET + ST_OBSERVE_PRESSURE]
    xorpd xmm1, xmm1
    maxsd xmm0, xmm1
    mov rcx, 0x3FF0000000000000
    movq xmm1, rcx
    minsd xmm0, xmm1
    movsd [rax + STATE_OFFSET + ST_OBSERVE_PRESSURE], xmm0
    ret

.accrue_evolve:
    addsd xmm0, [rax + STATE_OFFSET + ST_EVOLVE_PRESSURE]
    xorpd xmm1, xmm1
    maxsd xmm0, xmm1
    mov rcx, 0x3FF0000000000000
    movq xmm1, rcx
    minsd xmm0, xmm1
    movsd [rax + STATE_OFFSET + ST_EVOLVE_PRESSURE], xmm0
    ret

;; ============================================================
;; introspect_repair_cycle()
;; SELF/OTHER BOUNDARY: Process regions that violated self-model.
;;
;; When SURPRISE_SELF occurs, it means a high-confidence region was wrong.
;; This is qualitatively different from SURPRISE_OUTCOME (world unknown).
;; Self-surprise demands introspection and self-repair, not just learning.
;;
;; Actions for regions with RFLAG_NEEDS_REPAIR:
;;   1. If hits > misses: specialize (make more specific)
;;   2. If misses > hits: generalize (make broader)
;;   3. Clear RFLAG_NEEDS_REPAIR after processing
;; ============================================================
global introspect_repair_cycle
introspect_repair_cycle:
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub rsp, 8                      ; align stack (5 pushes = odd → aligned)

    mov rbx, SURFACE_BASE
    lea r12, [rbx + REGION_TABLE_OFFSET]
    mov r13d, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    xor r14d, r14d                  ; loop index
    xor r15d, r15d                  ; repaired count

.repair_loop:
    cmp r14d, r13d
    jge .repair_done

    ; Get region table entry
    imul rdi, r14, RTE_SIZE
    add rdi, r12

    ; Check if RFLAG_NEEDS_REPAIR is set
    movzx eax, word [rdi + RTE_FLAGS]
    test eax, RFLAG_NEEDS_REPAIR
    jz .repair_next

    ; Found region that violated self-model
    push rdi
    lea rdi, [rel intro_repair_msg]
    call print_cstr
    pop rdi

    ; Get region header
    mov rsi, [rdi + RTE_ADDR]
    test rsi, rsi
    jz .clear_flag

    ; First, consult causal model for guidance
    xor edi, edi              ; use current context
    call meta_recommend_strategy  ; eax = recommended event type

    ; If causal model has data, use it
    cmp eax, EVENT_GENERALIZE
    je .do_generalize
    cmp eax, EVENT_SPECIALIZE
    je .do_specialize
    ; No causal guidance - fall back to heuristic

    ; Heuristic: Analyze performance: hits vs misses
    imul rdi, r14, RTE_SIZE
    add rdi, r12
    mov rsi, [rdi + RTE_ADDR]
    mov eax, [rsi + RHDR_HITS]
    mov ecx, [rsi + RHDR_MISSES]
    cmp eax, ecx
    jg .do_specialize
    ; misses >= hits: generalize (too specific?)

.do_generalize:
    push r14
    mov edi, r14d
    call modify_generalize
    pop r14
    jmp .clear_flag

.do_specialize:
    ; hits > misses but violated: specialize (conflating contexts?)
    push r14
    mov edi, r14d
    call modify_specialize
    pop r14

.clear_flag:
    ; Clear RFLAG_NEEDS_REPAIR
    imul rdi, r14, RTE_SIZE
    add rdi, r12
    movzx eax, word [rdi + RTE_FLAGS]
    and eax, ~RFLAG_NEEDS_REPAIR
    mov word [rdi + RTE_FLAGS], ax

    ; Also clear in header if present
    mov rsi, [rdi + RTE_ADDR]
    test rsi, rsi
    jz .repair_count
    movzx eax, word [rsi + RHDR_FLAGS]
    and eax, ~RFLAG_NEEDS_REPAIR
    mov word [rsi + RHDR_FLAGS], ax

.repair_count:
    inc r15d

.repair_next:
    inc r14d
    jmp .repair_loop

.repair_done:
    ; r15d = number of regions repaired
    mov eax, r15d
    add rsp, 8
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret
; io.asm — Syscall wrappers, file digestion, motor system
;
; @entry digest_file(rdi=path) -> void ; read file, tokenize, process
; @entry sys_write/read/mmap/open/close/exit ; syscall wrappers
; @entry motor_file_read/write_sandboxed ; staged file access
; @calls dispatch.asm:process_token
; @calls maturity.asm:gate_fd_write, gate_fd_read
; @calledby repl.asm:cmd_eat
;
; FLOW (digest_file): open → mmap → tokenize → process_token each → unmap
; TOKEN ABSTRACTION: 0x... → TOKEN_HEX, digits → TOKEN_NUM
;
; SELF-REFERENCE DETECTION (~line 437):
;   Scans path for ".asm" to detect self-digestion
;   Sets ST_IS_SELF_REF flag during digestion of own source code
;   Clears flag at digest completion
;   Enables dispatch.asm to emit EVENT_SELF on misses during self-digestion
;
; SELF-MODEL LEARNING (~line 612):
;   When ST_IS_SELF_REF is set, each token is superposed into ST_SELF_MODEL_VEC
;   This builds a holographic representation of "what I am" (own code patterns)
;   Uses holo_gen_vec to generate token vector, holo_superpose_f64 to accumulate
;
; MATURITY GATING:
;   Stage 0: stdout/stderr/stdin only
;   Stage 1: + read files
;   Stage 2: + write files
;
; GOTCHAS:
;   - Token abstraction MUST match dispatch.asm:process_input exactly
;   - Fault handler longjmps to REPL - save fault_safe_rsp/rip before process_token
;   - rcx clobbered by calls, use r10-r15 in digest loop
;   - Restore r14 (SURFACE_BASE) after fault recovery in continue_loop
;
%include "syscalls.inc"
%include "constants.inc"

section .text

extern gate_fd_write
extern gate_fd_read

;; ============================================================
;; sys_write(fd, buf, len)
;; rdi=fd, rsi=buf, rdx=len
;; Returns: bytes written in rax, or -1 if blocked by maturity gate
;; ============================================================
global sys_write
sys_write:
    ; Save args
    push rdi
    push rsi
    push rdx

    ; Check if this fd is allowed for writing
    ; edi already has fd
    call gate_fd_write
    test eax, eax
    jz .write_blocked

    ; Allowed - restore args and do syscall
    pop rdx
    pop rsi
    pop rdi
    mov rax, SYS_WRITE
    syscall
    ret

.write_blocked:
    ; Blocked by maturity gate
    pop rdx
    pop rsi
    pop rdi
    mov rax, -1             ; return error
    ret

;; ============================================================
;; sys_read(fd, buf, len)
;; rdi=fd, rsi=buf, rdx=len
;; Returns: bytes read in rax, or -1 if blocked by maturity gate
;; ============================================================
global sys_read
sys_read:
    ; Save args
    push rdi
    push rsi
    push rdx

    ; Check if this fd is allowed for reading
    call gate_fd_read
    test eax, eax
    jz .read_blocked

    ; Allowed - restore args and do syscall
    pop rdx
    pop rsi
    pop rdi
    mov rax, SYS_READ
    syscall
    ret

.read_blocked:
    ; Blocked by maturity gate
    pop rdx
    pop rsi
    pop rdi
    mov rax, -1
    ret

;; ============================================================
;; sys_mmap(addr, len, prot, flags, fd, offset)
;; rdi=addr, rsi=len, rdx=prot, r10=flags, r8=fd, r9=offset
;; Returns: mapped address in rax
;; ============================================================
global sys_mmap
sys_mmap:
    mov rax, SYS_MMAP
    mov r10, rcx              ; syscall convention: r10 instead of rcx
    syscall
    ret

;; ============================================================
;; sys_mprotect(addr, len, prot)
;; rdi=addr, rsi=len, rdx=prot
;; ============================================================
global sys_mprotect
sys_mprotect:
    mov rax, SYS_MPROTECT
    syscall
    ret

;; ============================================================
;; sys_open(path, flags, mode)
;; rdi=path, rsi=flags, rdx=mode
;; Returns: fd in rax
;; ============================================================
global sys_open
sys_open:
    mov rax, SYS_OPEN
    syscall
    ret

;; ============================================================
;; sys_close(fd)
;; rdi=fd
;; ============================================================
global sys_close
sys_close:
    mov rax, SYS_CLOSE
    syscall
    ret

;; ============================================================
;; sys_exit(code)
;; rdi=exit code
;; ============================================================
global sys_exit
sys_exit:
    mov rax, SYS_EXIT
    syscall
    ; no return

;; ============================================================
;; sys_sigaction(signum, act, oldact)
;; rdi=signum, rsi=act ptr, rdx=oldact ptr
;; r10=sigsetsize (8)
;; ============================================================
global sys_sigaction
sys_sigaction:
    mov r10, 8                ; sizeof(sigset_t) / 8
    mov rax, SYS_RT_SIGACTION
    syscall
    ret

;; ============================================================
;; sys_clock_gettime(clockid, timespec_ptr)
;; rdi=clockid (0=REALTIME, 1=MONOTONIC)
;; rsi=ptr to timespec {tv_sec:u64, tv_nsec:u64}
;; ============================================================
global sys_clock_gettime
sys_clock_gettime:
    mov rax, SYS_CLOCK_GETTIME
    syscall
    ret

;; ============================================================
;; sys_getrandom(buf, buflen, flags)
;; rdi=buf, rsi=buflen, rdx=flags
;; ============================================================
global sys_getrandom
sys_getrandom:
    mov rax, SYS_GETRANDOM
    syscall
    ret

;; ============================================================
;; write_stdout(buf, len)
;; Convenience: write to stdout
;; rdi=buf, rsi=len
;; ============================================================
global write_stdout
write_stdout:
    mov rdx, rsi              ; len
    mov rsi, rdi              ; buf
    mov edi, STDOUT
    mov rax, SYS_WRITE
    syscall
    ret

;; ============================================================
;; write_stderr(buf, len)
;; rdi=buf, rsi=len
;; ============================================================
global write_stderr
write_stderr:
    mov rdx, rsi
    mov rsi, rdi
    mov edi, STDERR
    mov rax, SYS_WRITE
    syscall
    ret

;; ============================================================
;; read_stdin(buf, max_len)
;; rdi=buf, rsi=max_len
;; Returns: bytes read in rax
;; ============================================================
global read_stdin
read_stdin:
    mov rdx, rsi              ; max len
    mov rsi, rdi              ; buf
    xor edi, edi              ; STDIN
    mov rax, SYS_READ
    syscall
    ret

;; ============================================================
;; DIGESTION SYSTEM: File Ingestion as "Food"
;; Files are metabolic resources. Reading a file extracts
;; tokens (nutrients) that feed the dispatch system.
;; The Motor Interface provides sandboxed syscall access.
;; ============================================================

section .data
    align 8
    digest_msg:         db "[DIGEST] reading file: ", 0
    digest_bytes_msg:   db " (", 0
    digest_bytes_end:   db " bytes)", 10, 0
    digest_err_msg:     db "[DIGEST] error opening file: ", 0
    digest_nl:          db 10, 0
    motor_err_msg:      db "[MOTOR] command failed: ", 0

    ; Sandbox whitelist directory (hardcoded for safety)
    sandbox_dir:        db "/tmp/uhma-sandbox/", 0
    sandbox_dir_len:    equ $ - sandbox_dir - 1

    ; f64 constants for energy calculation
    align 8
    energy_per_byte:    dq 0.001   ; 0.001 energy per byte read (food value)
    energy_per_token:   dq 0.1     ; 0.1 energy per token extracted

section .bss
    ; File read buffer (4MB - fits in L3 cache)
    align 16
    digest_buffer:      resb 4194304
    digest_buffer_len:  equ 4194304

section .text

;; ============================================================
;; motor_file_read(path, buffer, max_len) -> rax (bytes read)
;; rdi=path (null-terminated), rsi=buffer, rdx=max_len
;; Reads file with sandboxing (read-only, size-limited)
;; Returns: bytes read, or negative on error
;; ============================================================
global motor_file_read
motor_file_read:
    push rbx
    push r12
    push r13
    push r14

    mov r12, rdi              ; path
    mov r13, rsi              ; buffer
    mov r14, rdx              ; max_len

    ; Open file (read-only)
    mov rdi, r12
    xor esi, esi              ; O_RDONLY = 0
    xor edx, edx              ; mode = 0 (not creating)
    mov rax, SYS_OPEN
    syscall
    test rax, rax
    js .motor_read_err        ; open failed

    mov rbx, rax              ; save fd

    ; Read file content
    mov rdi, rbx              ; fd
    mov rsi, r13              ; buffer
    mov rdx, r14              ; max_len
    mov rax, SYS_READ
    syscall
    mov r14, rax              ; save bytes read

    ; Close file
    mov rdi, rbx
    mov rax, SYS_CLOSE
    syscall

    ; Return bytes read
    mov rax, r14
    jmp .motor_read_done

.motor_read_err:
    ; Return error code
    ; rax already contains negative error

.motor_read_done:
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; motor_file_write_sandboxed(path, buffer, len) -> rax (bytes written)
;; rdi=path (relative to sandbox), rsi=buffer, rdx=len
;; Writes file ONLY to sandbox directory for safety.
;; Returns: bytes written, or negative on error
;; ============================================================
global motor_file_write_sandboxed
motor_file_write_sandboxed:
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub rsp, 256              ; space for full path

    mov r12, rdi              ; relative path
    mov r13, rsi              ; buffer
    mov r14, rdx              ; len

    ; Construct full path: sandbox_dir + relative_path
    lea rdi, [rsp]            ; dest buffer
    lea rsi, [rel sandbox_dir]
    ; Copy sandbox_dir prefix
    mov rcx, sandbox_dir_len
.copy_prefix:
    test rcx, rcx
    jz .copy_filename
    lodsb
    stosb
    dec rcx
    jmp .copy_prefix

.copy_filename:
    ; Copy relative filename
    mov rsi, r12
.copy_fname_loop:
    lodsb
    stosb
    test al, al
    jnz .copy_fname_loop

    ; Open file for writing (create/truncate)
    lea rdi, [rsp]            ; full path
    mov esi, 0x241            ; O_WRONLY | O_CREAT | O_TRUNC
    mov edx, 0644o            ; mode rw-r--r--
    mov rax, SYS_OPEN
    syscall
    test rax, rax
    js .motor_write_err

    mov rbx, rax              ; save fd

    ; Write content
    mov rdi, rbx              ; fd
    mov rsi, r13              ; buffer
    mov rdx, r14              ; len
    mov rax, SYS_WRITE
    syscall
    mov r15, rax              ; save bytes written

    ; Close file
    mov rdi, rbx
    mov rax, SYS_CLOSE
    syscall

    mov rax, r15              ; return bytes written
    jmp .motor_write_done

.motor_write_err:
    ; rax contains negative error

.motor_write_done:
    add rsp, 256
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; digest_file(path) -> rax (tokens extracted)
;; rdi=path (null-terminated)
;; Reads file and feeds tokens to dispatch system.
;; This is how UHMA "eats" — files are food!
;; Energy gained = f(file_size, token_count)
;; ============================================================
extern process_token
extern print_cstr
extern print_u64
extern fault_safe_rsp
extern fault_safe_rip
extern holo_gen_vec
extern holo_superpose_f64
extern holo_normalize_f64

global digest_file
digest_file:
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub rsp, 8                ; alignment

    mov r12, rdi              ; save path

    ; Print digest message
    lea rdi, [rel digest_msg]
    call print_cstr
    mov rdi, r12
    call print_cstr

    ; Read file
    mov rdi, r12
    lea rsi, [rel digest_buffer]
    mov rdx, digest_buffer_len
    call motor_file_read
    test rax, rax
    js .digest_error

    mov r13, rax              ; bytes read
    mov r14, SURFACE_BASE     ; surface base

    ; === SELF-REFERENCE DETECTION ===
    ; If digesting .asm file, this is self-referential (eating own code)
    ; Set ST_IS_SELF_REF flag so misses during self-ingestion are tracked specially
    mov dword [r14 + STATE_OFFSET + ST_IS_SELF_REF], 0  ; default: not self-ref
    ; Scan path (r12) for ".asm"
    mov rdi, r12
.self_ref_scan:
    movzx eax, byte [rdi]
    test al, al
    jz .self_ref_done         ; end of string
    cmp al, '.'
    jne .self_ref_next
    ; Found '.', check for "asm"
    cmp byte [rdi + 1], 'a'
    jne .self_ref_next
    cmp byte [rdi + 2], 's'
    jne .self_ref_next
    cmp byte [rdi + 3], 'm'
    jne .self_ref_next
    ; Found ".asm" - this is self-referential!
    mov dword [r14 + STATE_OFFSET + ST_IS_SELF_REF], 1
    jmp .self_ref_done
.self_ref_next:
    inc rdi
    jmp .self_ref_scan
.self_ref_done:

    ; Print bytes read
    lea rdi, [rel digest_bytes_msg]
    call print_cstr
    mov rdi, r13
    call print_u64
    lea rdi, [rel digest_bytes_end]
    call print_cstr

    ; --- Metabolic energy from food ---
    ; Energy gained = bytes * energy_per_byte
    cvtsi2sd xmm0, r13        ; bytes as f64
    mulsd xmm0, [rel energy_per_byte]
    movsd xmm1, [r14 + STATE_OFFSET + ST_ENERGY]
    addsd xmm1, xmm0
    ; Cap energy at max
    mov rax, ENERGY_MAX
    movq xmm2, rax
    minsd xmm1, xmm2
    movsd [r14 + STATE_OFFSET + ST_ENERGY], xmm1

    ; --- Parse and feed tokens ---
    ; Simple tokenization: split on whitespace/punctuation
    xor r15d, r15d            ; token count
    lea rbx, [rel digest_buffer]
    mov rcx, r13              ; remaining bytes

.digest_loop:
    test rcx, rcx
    jz .digest_done

    ; Skip whitespace
.skip_ws:
    test rcx, rcx
    jz .digest_done
    movzx eax, byte [rbx]
    cmp al, ' '
    je .skip_char
    cmp al, 9                 ; tab
    je .skip_char
    cmp al, 10                ; newline
    je .skip_char
    cmp al, 13                ; CR
    je .skip_char
    jmp .start_token

.skip_char:
    inc rbx
    dec rcx
    jmp .skip_ws

.start_token:
    ; Found start of token — read until whitespace
    push rcx                  ; save remaining bytes
    push rbx                  ; save token start
    mov r8, rbx               ; r8 = token start (for abstraction check)
    xor edx, edx              ; token hash
    xor r9d, r9d              ; r9 = token length

.hash_loop:
    test rcx, rcx
    jz .token_done
    movzx eax, byte [rbx]
    cmp al, ' '
    je .token_done
    cmp al, 9
    je .token_done
    cmp al, 10
    je .token_done
    cmp al, 13
    je .token_done
    cmp al, 0
    je .token_done

    ; Hash: edx = edx * 31 + al
    imul edx, edx, 31
    add edx, eax
    inc rbx
    dec rcx
    inc r9d                   ; token_len++
    jmp .hash_loop

.token_done:
    pop rax                   ; original token start (discard)
    pop rax                   ; original remaining (discard)

    ; Skip empty tokens (end of buffer)
    test r9d, r9d
    jz .digest_loop           ; no token, continue scanning

    ; --- Categorical abstraction (same as process_input) ---
    ; r8 = token start, r9d = token length, edx = hash
    ; SAVE rcx (remaining bytes) - abstraction uses ecx as temp
    push rcx

    ; Check for hex literal: contains "0x" or "0X"
    cmp r9d, 3
    jl .digest_not_hex
    xor eax, eax
.digest_hex_scan:
    cmp eax, r9d
    jge .digest_not_hex
    cmp byte [r8 + rax], '0'
    jne .digest_hex_next
    lea r10d, [eax + 1]       ; use r10 instead of ecx
    cmp r10d, r9d
    jge .digest_hex_next
    movzx r10d, byte [r8 + r10]
    or r10b, 0x20             ; lowercase
    cmp r10b, 'x'
    je .digest_is_hex
.digest_hex_next:
    inc eax
    jmp .digest_hex_scan
.digest_is_hex:
    mov edx, 0x48455821       ; TOKEN_HEX ("HEX!")
    jmp .digest_abstraction_done

.digest_not_hex:
    ; Check for all-digit number (len > 1)
    cmp r9d, 2
    jl .digest_abstraction_done
    xor eax, eax
.digest_num_scan:
    cmp eax, r9d
    jge .digest_is_num
    movzx r10d, byte [r8 + rax]  ; use r10 instead of ecx
    cmp r10b, '0'
    jl .digest_abstraction_done
    cmp r10b, '9'
    jg .digest_abstraction_done
    inc eax
    jmp .digest_num_scan
.digest_is_num:
    mov edx, 0x4e554d21       ; TOKEN_NUM ("NUM!")

.digest_abstraction_done:
    ; RESTORE rcx
    pop rcx

.digest_token_ready:
    ; Process token (edx = token hash or class token)

    ; === SELF-MODEL LEARNING: superpose token into self-model if digesting own code ===
    cmp dword [r14 + STATE_OFFSET + ST_IS_SELF_REF], 0
    je .skip_self_model_learn

    ; Save token hash and loop state (rcx clobbered by calls)
    push rdx                      ; save token hash
    push rcx                      ; save remaining bytes
    push rbx                      ; save buffer pos
    sub rsp, 8                    ; alignment (3 pushes = 24, need 8 more for 32)

    ; Generate vector for this token
    mov edi, edx                  ; token hash as seed
    sub rsp, HOLO_VEC_BYTES                 ; temp vector on stack (HOLO_VEC_BYTES)
    mov rsi, rsp                  ; out = stack buffer
    call holo_gen_vec

    ; Superpose into self-model: ST_SELF_MODEL_VEC += token_vec
    lea rdi, [r14 + STATE_OFFSET + ST_SELF_MODEL_VEC]
    mov rsi, rsp                  ; src = token_vec on stack
    call holo_superpose_f64

    ; Normalize to prevent magnitude explosion
    lea rdi, [r14 + STATE_OFFSET + ST_SELF_MODEL_VEC]
    call holo_normalize_f64

    add rsp, HOLO_VEC_BYTES                 ; free temp vector
    add rsp, 8                    ; alignment
    pop rbx
    pop rcx
    pop rdx                       ; restore token hash

.skip_self_model_learn:
    mov edi, edx

    push rcx
    push rbx
    push r15

    ; === SAVE fault recovery point so crashes skip back to loop ===
    ; Note: We DON'T try to restore old recovery - just set ours
    ; and let normal return path continue. If fault happens,
    ; we lose the token but continue the loop.
    lea rax, [rel .continue_loop]
    mov [rel fault_safe_rip], rax
    mov [rel fault_safe_rsp], rsp

    call process_token

.continue_loop:

    pop r15
    pop rbx
    pop rcx

    ; Restore r14 in case it was clobbered by fault during process_token
    mov r14, SURFACE_BASE

    inc r15d                  ; token count++
    jmp .digest_loop

.digest_done:
    ; Clear self-reference flag (digestion complete)
    mov dword [r14 + STATE_OFFSET + ST_IS_SELF_REF], 0

    ; Bonus energy for tokens extracted
    cvtsi2sd xmm0, r15        ; tokens as f64
    mulsd xmm0, [rel energy_per_token]
    movsd xmm1, [r14 + STATE_OFFSET + ST_ENERGY]
    addsd xmm1, xmm0
    mov rax, ENERGY_MAX
    movq xmm2, rax
    minsd xmm1, xmm2
    movsd [r14 + STATE_OFFSET + ST_ENERGY], xmm1

    ; Return token count
    mov eax, r15d
    jmp .digest_exit

.digest_error:
    lea rdi, [rel digest_err_msg]
    call print_cstr
    mov rdi, r12
    call print_cstr
    lea rdi, [rel digest_nl]
    call print_cstr
    xor eax, eax              ; return 0 tokens

.digest_exit:
    add rsp, 8
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; motor_get_file_size(path) -> rax (size in bytes, or -1 on error)
;; rdi=path (null-terminated)
;; Uses stat syscall to get file size without reading it.
;; ============================================================
global motor_get_file_size
motor_get_file_size:
    push rbx
    sub rsp, 144              ; struct stat buffer

    mov rdi, rdi              ; path
    lea rsi, [rsp]            ; stat buffer
    mov rax, SYS_STAT
    syscall
    test rax, rax
    js .stat_err

    ; File size is at offset 48 in struct stat (st_size)
    mov rax, [rsp + 48]
    jmp .stat_done

.stat_err:
    mov rax, -1

.stat_done:
    add rsp, 144
    pop rbx
    ret

;; ============================================================
;; TRANSACTIONAL AGENCY: Safe Syscall Broker
;; Regions that want to perform I/O must submit requests to
;; the Motor Queue. Before execution, the region's code is
;; verified by the abstract interpreter to prove safety.
;; This gives UHMA "hands" while maintaining sandboxing.
;; ============================================================

section .data
    align 8
    agency_submit_msg:  db "[AGENCY] motor request submitted: cmd=", 0
    agency_verify_msg:  db "[AGENCY] verifying region 0x", 0
    agency_approved:    db " APPROVED", 10, 0
    agency_denied:      db " DENIED (verification failed)", 10, 0
    agency_exec_msg:    db "[AGENCY] executing motor cmd ", 0
    agency_done_msg:    db "[AGENCY] result: ", 0

section .text

extern verify_abstract

;; ============================================================
;; motor_submit_request(cmd, arg1, arg2, caller_region) -> eax (0=queued, -1=denied)
;; edi=motor command (MOTOR_*), rsi=arg1, rdx=arg2, rcx=caller_region_ptr
;; Submits a motor request to the queue. If caller_region is provided,
;; it must pass verification before the request is executed.
;; ============================================================
global motor_submit_request
motor_submit_request:
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub rsp, VCS_SIZE + 8     ; space for verification state

    mov r12d, edi             ; cmd
    mov r13, rsi              ; arg1
    mov r14, rdx              ; arg2
    mov r15, rcx              ; caller_region_ptr (may be 0)
    mov rbx, SURFACE_BASE

    ; If no caller region, skip verification (trusted direct call)
    test r15, r15
    jz .motor_store

    ; --- Verify caller region before accepting request ---
    ; Get code pointer and length from region header
    mov rdi, r15
    add rdi, RHDR_SIZE        ; code starts after header
    movzx esi, word [r15 + RHDR_CODE_LEN]
    lea rdx, [rsp]            ; output state buffer
    call verify_abstract

    ; Check result (eax = error count, 0 = safe)
    test eax, eax
    jnz .motor_denied

.motor_store:
    ; Store request in motor queue
    mov dword [rbx + STATE_OFFSET + ST_MOTOR_CMD], r12d
    mov [rbx + STATE_OFFSET + ST_MOTOR_ARG1], r13
    mov [rbx + STATE_OFFSET + ST_MOTOR_ARG2], r14
    mov dword [rbx + STATE_OFFSET + ST_MOTOR_STATUS], 1  ; STATUS_PENDING

    xor eax, eax              ; return 0 = queued
    jmp .motor_submit_done

.motor_denied:
    mov dword [rbx + STATE_OFFSET + ST_MOTOR_STATUS], 0xFF  ; STATUS_DENIED
    mov eax, -1               ; return -1 = denied

.motor_submit_done:
    add rsp, VCS_SIZE + 8
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; motor_process_queue() -> eax (result of last command)
;; Processes pending motor commands from the queue.
;; Returns result of the executed command.
;; ============================================================
global motor_process_queue
motor_process_queue:
    push rbx
    push r12
    push r13

    mov rbx, SURFACE_BASE

    ; Check if there's a pending command
    mov eax, [rbx + STATE_OFFSET + ST_MOTOR_STATUS]
    cmp eax, 1                ; STATUS_PENDING
    jne .no_pending

    mov r12d, [rbx + STATE_OFFSET + ST_MOTOR_CMD]
    mov r13, [rbx + STATE_OFFSET + ST_MOTOR_ARG1]

    ; Dispatch based on command
    cmp r12d, MOTOR_FILE_READ
    je .exec_file_read
    cmp r12d, MOTOR_FILE_SIZE
    je .exec_file_size
    cmp r12d, MOTOR_FILE_WRITE
    je .exec_file_write

    ; Unknown command
    mov dword [rbx + STATE_OFFSET + ST_MOTOR_STATUS], 0xFE  ; STATUS_ERROR
    mov eax, -1
    jmp .motor_done

.exec_file_read:
    ; arg1 = path, arg2 = buffer, we use digest_buffer internally
    mov rdi, r13              ; path
    lea rsi, [rel digest_buffer]
    mov rdx, digest_buffer_len
    call motor_file_read
    mov [rbx + STATE_OFFSET + ST_MOTOR_RESULT], rax
    mov dword [rbx + STATE_OFFSET + ST_MOTOR_STATUS], 2  ; STATUS_COMPLETE
    jmp .motor_done

.exec_file_size:
    ; arg1 = path
    mov rdi, r13
    call motor_get_file_size
    mov [rbx + STATE_OFFSET + ST_MOTOR_RESULT], rax
    mov dword [rbx + STATE_OFFSET + ST_MOTOR_STATUS], 2  ; STATUS_COMPLETE
    jmp .motor_done

.exec_file_write:
    ; arg1 = path (relative), arg2 = buffer, arg3 (not used) = len
    mov rdi, r13              ; relative path
    mov rsi, [rbx + STATE_OFFSET + ST_MOTOR_ARG2]  ; buffer
    mov rdx, 4096             ; fixed max for safety
    call motor_file_write_sandboxed
    mov [rbx + STATE_OFFSET + ST_MOTOR_RESULT], rax
    mov dword [rbx + STATE_OFFSET + ST_MOTOR_STATUS], 2  ; STATUS_COMPLETE
    jmp .motor_done

.no_pending:
    xor eax, eax

.motor_done:
    mov rax, [rbx + STATE_OFFSET + ST_MOTOR_RESULT]
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; motor_get_status() -> eax (motor status)
;; Returns: 0=idle, 1=pending, 2=complete, 0xFE=error, 0xFF=denied
;; ============================================================
global motor_get_status
motor_get_status:
    mov rax, SURFACE_BASE
    mov eax, [rax + STATE_OFFSET + ST_MOTOR_STATUS]
    ret

;; ============================================================
;; motor_get_result() -> rax (last result)
;; Returns the result of the last motor command.
;; ============================================================
global motor_get_result
motor_get_result:
    mov rax, SURFACE_BASE
    mov rax, [rax + STATE_OFFSET + ST_MOTOR_RESULT]
    ret

;; ============================================================
;; motor_clear()
;; Clears the motor queue (resets to idle state)
;; ============================================================
global motor_clear
motor_clear:
    mov rax, SURFACE_BASE
    mov dword [rax + STATE_OFFSET + ST_MOTOR_CMD], 0
    mov qword [rax + STATE_OFFSET + ST_MOTOR_ARG1], 0
    mov qword [rax + STATE_OFFSET + ST_MOTOR_ARG2], 0
    mov qword [rax + STATE_OFFSET + ST_MOTOR_RESULT], 0
    mov dword [rax + STATE_OFFSET + ST_MOTOR_STATUS], 0
    ret
; learn.asm — Learning: emit new patterns, strengthen/weaken existing
;
; @entry learn_pattern(edi=ctx, esi=token, xmm0=energy_delta) -> void
; @entry find_existing_pattern(edi=ctx, esi=token) -> rax=region_ptr|0
; @entry strengthen_region(rdi=header_ptr) -> void ; +2 hits
; @entry weaken_region(rdi=header_ptr) -> void ; +1 misses
; @entry wire_new_region(rdi=region_ptr) -> void
; @entry learn_connections(rdi=region_ptr) -> void ; STDP wiring
; @calls emit.asm:emit_dispatch_pattern
; @calls receipt.asm:receipt_resonate, emit_receipt_simple
; @calls vsa.asm:holo_store
; @calledby dispatch.asm:process_token (on MISS)
;
; FLOW: holo_store → check redundant → find_existing → emit → wire → STDP
; STATE: miss buffer via dispatch, region table
;
; TRACE QUERY (~line 120):
;   receipt_resonate(LEARN, ctx, token) > 0.8 → skip redundant
;
; SOMATIC: energy_delta → valence → superposed (reward = positive)
;
; GOTCHAS:
;   - Always holo_store first (never fails, just gets denser)
;   - Check receipt trace BEFORE emitting (avoid redundant patterns)
;
%include "syscalls.inc"
%include "constants.inc"

section .data
    learn_msg:      db "[LEARN] ctx=0x", 0
    learn_tok_msg:  db " → tok=0x", 0
    learn_dup_msg:  db " (exists, skip)", 10, 0
    learn_new_msg:  db " (new pattern)", 10, 0
    strengthen_msg: db "[STRENGTHEN] region at 0x", 0
    weaken_msg:     db "[WEAKEN] region at 0x", 0
    dbg_stored_msg: db "[DBG] stored=0x", 0
    dbg_query_msg:  db " query=0x", 0
    dbg_idx_msg:    db "[IDX] ", 0
    dbg_ctx_match_msg: db "[CTX_MATCH]", 10, 0
    dbg_full_match_msg: db "[FULL_MATCH]", 10, 0
    dbg_tok_msg:    db "[TOK] stored=0x", 0
    dbg_vs_msg:     db " query=0x", 0

    ; Holographic learning rate (f64)
    align 8
    holo_lr:        dq 0.1

    ; f64 constants for STDP learning
    align 8
    learn_rate:     dq 0.05
    tau:            dq 4.0
    tau_window:     dq 8.0
    initial_w:      dq 0.1
    resonance_old:  dq 0.9
    resonance_new:  dq 0.1
    f64_one:        dq 1.0
    f64_zero:       dq 0.0
    f64_half:       dq 0.5
    f64_sixth:      dq 0.16666666666666666

section .text

extern print_cstr
extern print_hex32
extern print_newline
extern emit_dispatch_pattern
extern fire_hook
extern holo_store
extern vocab_register
extern region_merge_pass
extern journey_step
extern vsa_energy_to_valence
extern vsa_gen_valence_vec
extern holo_superpose_f64
extern holo_gen_vec
extern emit_receipt_simple
extern emit_receipt_full
extern receipt_resonate

;; ============================================================
;; learn_pattern(ctx_hash, token_id, energy_delta)
;; rdi=context_hash (u64, lower 32 used), esi=token_id, xmm0=energy_delta (f64)
;; Learns a new ctx→token association by emitting code
;; First checks if the pattern already exists (avoid duplicates)
;; SOMATIC GROUNDING: energy_delta is converted to valence and
;; superposed onto the holographic trace, giving the memory
;; an emotional charge — patterns learned during reward have
;; positive valence, patterns learned during cost have negative.
;; ============================================================
global learn_pattern
learn_pattern:
    push rbx
    push r12
    push r13
    push r14
    sub rsp, HOLO_VEC_BYTES + 16  ; space for valence vector + saved energy_delta

    mov r12d, edi             ; ctx_hash (lower 32)
    mov r13d, esi             ; token_id
    mov rbx, SURFACE_BASE
    movsd [rsp + HOLO_VEC_BYTES], xmm0  ; save energy_delta

    ; JOURNEY: record learn_pattern
    push r12
    push r13
    mov edi, TRACE_LEARN_PATTERN
    call journey_step
    pop r13
    pop r12

    ; ALWAYS store holographically (never fails, interference just gets denser)
    mov edi, r12d             ; ctx_hash
    mov esi, r13d             ; token_id
    movsd xmm0, [rel holo_lr]  ; f64 strength
    call holo_store

    ; --- SOMATIC GROUNDING: Superpose valence onto trace ---
    ; 1. Convert energy_delta to valence [-1, +1]
    movsd xmm0, [rsp + HOLO_VEC_BYTES]  ; reload energy_delta
    call vsa_energy_to_valence          ; xmm0 = valence

    ; 2. Generate valence vector (mostly zeros, valence in last element)
    lea rdi, [rsp]            ; output = temp on stack
    call vsa_gen_valence_vec

    ; 3. Scale valence vector by learning rate
    lea rdi, [rsp]
    movsd xmm0, [rel holo_lr]
    call holo_scale_f64_local           ; defined below

    ; 4. Superpose onto the same trace as holo_store uses
    ;    trace_idx = ctx_hash & 0xFF
    movzx eax, r12b
    imul rax, rax, HOLO_VEC_BYTES
    mov rdi, SURFACE_BASE + HOLO_OFFSET
    add rdi, rax              ; trace ptr
    lea rsi, [rsp]            ; valence vector
    call holo_superpose_f64

    ; Register token in vocabulary
    mov edi, r13d
    call vocab_register

    ; --- RESONANCE QUERY: Should we learn this pattern? ---
    ; Query past LEARN events for similar ctx+token combinations
    ; High similarity suggests we've tried this before
    mov edi, EVENT_LEARN
    mov esi, r12d             ; ctx_hash
    mov edx, r13d             ; token_id
    call receipt_resonate     ; → xmm0 = similarity to past LEARNs
    ; If very high similarity (>0.8), we've likely learned this recently
    mov rax, 0x3FE999999999999A  ; 0.8 f64
    movq xmm1, rax
    ucomisd xmm0, xmm1
    ja .already_exists        ; skip if too similar to recent learn

    ; Check if this exact pattern already exists
    mov edi, r12d
    mov esi, r13d
    call find_existing_pattern
    test rax, rax
    jnz .already_exists

    ; Check region count — trigger merge if approaching saturation
    lea rax, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    mov ecx, [rax]
    cmp ecx, REGION_TABLE_MAX - 4    ; leave room
    jl .has_room
    ; Try to merge before giving up
    call region_merge_pass
    ; Re-check count after merge
    lea rax, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    mov ecx, [rax]
    cmp ecx, REGION_TABLE_MAX - 4
    jge .table_full
.has_room:

    ; Print learn info (only for genuinely NEW patterns)
    push r12
    push r13
    lea rdi, [rel learn_msg]
    call print_cstr
    mov edi, r12d
    call print_hex32
    lea rdi, [rel learn_tok_msg]
    call print_cstr
    mov edi, r13d
    call print_hex32
    pop r13
    pop r12
    lea rdi, [rel learn_new_msg]
    call print_cstr

    ; --- Metabolic cost: emitting a new pattern costs energy ---
    ; Bootstrap exception: first N patterns are free (can't bootstrap without patterns)
    lea rax, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    mov ecx, [rax]
    cmp ecx, 8                 ; bootstrap threshold
    jl .skip_energy_check      ; first 8 patterns are free
    ; If energy is below starvation level, refuse to emit (conserve)
    movsd xmm0, [rbx + STATE_OFFSET + ST_ENERGY]
    mov rax, ENERGY_STARVATION
    movq xmm1, rax
    ucomisd xmm0, xmm1
    jbe .done                  ; starving — refuse to spend energy on emission
.skip_energy_check:
    ; Deduct emission cost
    mov rax, ENERGY_EMIT_COST
    movq xmm1, rax
    subsd xmm0, xmm1
    xorpd xmm2, xmm2
    maxsd xmm0, xmm2
    movsd [rbx + STATE_OFFSET + ST_ENERGY], xmm0
    addsd xmm1, [rbx + STATE_OFFSET + ST_ENERGY_SPENT]
    movsd [rbx + STATE_OFFSET + ST_ENERGY_SPENT], xmm1

    mov edi, r12d             ; ctx_hash
    mov esi, r13d             ; token_id
    ; Get current step for birth
    lea rax, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    mov edx, [rax]            ; birth_step (lower 32 of global step)
    call emit_dispatch_pattern

    ; === EMIT RECEIPT: EVENT_LEARN (with region info) ===
    push rax                  ; save region ptr
    mov edi, EVENT_LEARN              ; event_type
    mov esi, r12d                     ; ctx_hash
    mov edx, r13d                     ; actual_token (token being learned)
    xor ecx, ecx                      ; predicted = 0 (no prediction, we're learning)
    ; Hash the new region pointer
    shr rax, 4
    mov r8d, eax                      ; region_hash (newly created pattern)
    xor r9d, r9d                      ; aux = 0
    movsd xmm0, [rsp + 8 + HOLO_VEC_BYTES]  ; reload energy_delta as confidence
    cvtsd2ss xmm0, xmm0
    movss xmm1, [rbx + STATE_OFFSET + ST_PRESENCE + PRES_VALENCE * 4]
    cvtss2sd xmm1, xmm1
    call emit_receipt_full
    pop rax

    ; Track recent emission count (for introspective state)
    lea rax, [rbx + STATE_OFFSET + ST_RECENT_EMITS]
    inc dword [rax]

    ; Check for auto-generalization opportunity
    mov edi, r12d             ; ctx_hash
    mov esi, r13d             ; token_id
    call check_auto_generalize

    ; Fire learn hook
    mov edi, HOOK_ON_LEARN
    mov esi, r13d
    call fire_hook

    jmp .done

.already_exists:
    ; Pattern exists — strengthen it (boost hit counter)
    push rax                  ; save region header ptr across print call
    lea rdi, [rel learn_dup_msg]
    call print_cstr
    pop rax

    ; Strengthen: increment hits on the existing region
    mov rdi, rax
    call strengthen_region

.table_full:
.done:
    add rsp, HOLO_VEC_BYTES + 16
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; holo_scale_f64_local(vec, scalar)
;; rdi=vec (f64[1024], modified in place), xmm0=scalar (f64)
;; Local helper to scale valence vector
;; ============================================================
holo_scale_f64_local:
    vbroadcastsd ymm1, xmm0
    mov ecx, HOLO_DIM / 4

.hscale_local_loop:
    vmovupd ymm0, [rdi]
    vmulpd ymm0, ymm0, ymm1
    vmovupd [rdi], ymm0
    add rdi, 32
    dec ecx
    jnz .hscale_local_loop

    vzeroupper
    ret

;; ============================================================
;; find_existing_pattern(ctx_hash_32, token_id) → rax
;; edi=ctx_hash, esi=token_id
;; Searches dispatch regions for matching ctx→token
;; Returns: header ptr if found, 0 if not
;; ============================================================
global find_existing_pattern
find_existing_pattern:
    push rbx
    push r12
    push r13

    mov r12d, edi             ; ctx_hash
    mov r13d, esi             ; token_id
    mov rbx, SURFACE_BASE

    ; JOURNEY: record find_existing_pattern
    push r12
    push r13
    mov edi, TRACE_FIND_EXISTING_PATTERN
    call journey_step
    pop r13
    pop r12

    lea rax, [rbx + REGION_TABLE_OFFSET]
    push rax                  ; save table base
    lea rax, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    mov ecx, [rax]
    pop rsi                   ; table base

    xor edx, edx             ; index
.search:
    cmp edx, ecx
    jge .not_found
    push rcx
    push rdx

    imul rdi, rdx, RTE_SIZE
    add rdi, rsi

    ; Check type
    movzx eax, word [rdi + RTE_TYPE]
    cmp eax, RTYPE_DISPATCH
    jne .skip

    ; Check not condemned
    movzx eax, word [rdi + RTE_FLAGS]
    test eax, RFLAG_CONDEMNED
    jnz .skip

    ; Get header address
    mov rdi, [rdi + RTE_ADDR]

    ; Check the CMP immediate (ctx_hash)
    ; Compare BASE context only (bits 0-23), ignore mood (bits 24-31)
    cmp byte [rdi + RHDR_SIZE], 0x3D
    jne .skip
    mov eax, [rdi + RHDR_SIZE + 1]
    and eax, 0x00FFFFFF              ; strip mood from stored
    mov r8d, r12d
    and r8d, 0x00FFFFFF              ; strip mood from query
    cmp eax, r8d
    jne .skip

    ; Check the MOV immediate (token_id)
    ; At offset RHDR_SIZE + 7: mov eax, imm32 (B8 xx xx xx xx)
    cmp byte [rdi + RHDR_SIZE + 7], 0xB8
    jne .skip
    cmp [rdi + RHDR_SIZE + 8], r13d
    jne .skip

    ; Found match
    mov rax, rdi
    pop rdx
    pop rcx
    jmp .found

.skip:
    pop rdx
    pop rcx
    inc edx
    jmp .search

.not_found:
    xor eax, eax
.found:
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; strengthen_region(header_ptr)
;; rdi=region header ptr
;; Adds bonus hits to boost the region's fitness
;; ============================================================
global strengthen_region
strengthen_region:
    ; Add 2 bonus hits (reinforcement)
    add dword [rdi + RHDR_HITS], 2
    ret

;; ============================================================
;; weaken_region(header_ptr)
;; rdi=region header ptr
;; Adds penalty misses
;; ============================================================
global weaken_region
weaken_region:
    ; Add 1 penalty miss
    inc dword [rdi + RHDR_MISSES]
    ret

;; ============================================================
;; check_auto_generalize(ctx_hash, token_id)
;; edi=ctx_hash (just emitted), esi=token_id
;; Scans existing dispatch patterns for the same token with
;; a similar context. If found, emits a generalized pattern
;; (masked lower bits) — this is how schemas emerge from
;; repeated observation of the same token in similar contexts.
;; ============================================================
check_auto_generalize:
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub rsp, 8                ; [rsp] = existing_ctx local var

    mov r12d, edi             ; new ctx_hash
    mov r13d, esi             ; token_id

    mov rbx, SURFACE_BASE
    lea r14, [rbx + REGION_TABLE_OFFSET]
    mov r15d, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    xor ecx, ecx
.ag_loop:
    cmp ecx, r15d
    jge .ag_done
    push rcx

    imul rdi, rcx, RTE_SIZE
    add rdi, r14
    movzx eax, word [rdi + RTE_TYPE]
    cmp eax, RTYPE_DISPATCH
    jne .ag_skip
    movzx eax, word [rdi + RTE_FLAGS]
    test eax, RFLAG_CONDEMNED
    jnz .ag_skip

    mov rsi, [rdi + RTE_ADDR]
    cmp byte [rsi + RHDR_SIZE], 0x3D
    jne .ag_skip

    ; Check same token (mov eax, imm32 at offset +7)
    cmp byte [rsi + RHDR_SIZE + 7], 0xB8
    jne .ag_skip
    cmp [rsi + RHDR_SIZE + 8], r13d
    jne .ag_skip

    ; Same token! Check different context
    mov eax, [rsi + RHDR_SIZE + 1]
    cmp eax, r12d
    je .ag_skip               ; same context = same pattern

    ; Found overlap — save existing context to local var
    mov [rsp + 8], eax        ; +8 because rcx is pushed

    ; --- Emit schema for NEW context ---
    mov edi, r12d
    and edi, 0xFFFFFFF0
    mov esi, r13d
    call find_existing_pattern
    test rax, rax
    jnz .ag_new_exists
    cmp dword [rbx + STATE_OFFSET + ST_REGION_COUNT], REGION_TABLE_MAX - 4
    jge .ag_done_pop
    mov edi, r12d
    and edi, 0xFFFFFFF0
    mov esi, r13d
    mov edx, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    call emit_dispatch_pattern
    inc dword [rbx + STATE_OFFSET + ST_RECENT_EMITS]
.ag_new_exists:

    ; --- Emit schema for EXISTING context ---
    mov eax, [rsp + 8]       ; reload existing_ctx
    mov edi, eax
    and edi, 0xFFFFFFF0
    mov esi, r13d
    call find_existing_pattern
    test rax, rax
    jnz .ag_done_pop          ; already exists
    cmp dword [rbx + STATE_OFFSET + ST_REGION_COUNT], REGION_TABLE_MAX - 4
    jge .ag_done_pop
    mov eax, [rsp + 8]       ; reload existing_ctx
    mov edi, eax
    and edi, 0xFFFFFFF0
    mov esi, r13d
    mov edx, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    call emit_dispatch_pattern
    inc dword [rbx + STATE_OFFSET + ST_RECENT_EMITS]

    ; One generalization per learn call — done
    pop rcx
    jmp .ag_done

.ag_done_pop:
    pop rcx
    jmp .ag_done
.ag_skip:
    pop rcx
    inc ecx
    jmp .ag_loop
.ag_done:
    add rsp, 8
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; wire_new_region(region_ptr, token_id)
;; rdi=new region header ptr, esi=token_id
;; Bootstraps connectivity: finds existing regions with same token,
;; creates next_a/next_b links and initial excite weights.
;; ============================================================
global wire_new_region
wire_new_region:
    push rbx
    push r12
    push r13
    push r14
    push r15

    mov r12, rdi              ; new region ptr
    mov r13d, esi             ; token_id
    mov rbx, SURFACE_BASE
    xor r15, r15              ; closest same-token region found (0=none)

    lea r14, [rbx + REGION_TABLE_OFFSET]
    mov ecx, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    xor edx, edx

.wire_scan:
    cmp edx, ecx
    jge .wire_done_scan
    push rcx
    push rdx

    imul rdi, rdx, RTE_SIZE
    add rdi, r14
    movzx eax, word [rdi + RTE_TYPE]
    cmp eax, RTYPE_DISPATCH
    jne .wire_skip
    movzx eax, word [rdi + RTE_FLAGS]
    test eax, RFLAG_CONDEMNED
    jnz .wire_skip

    mov rsi, [rdi + RTE_ADDR]
    ; Skip self
    cmp rsi, r12
    je .wire_skip

    ; Check if same token (B8 opcode at +7 of code, token at +8)
    cmp byte [rsi + RHDR_SIZE + 7], 0xB8
    jne .wire_skip
    cmp [rsi + RHDR_SIZE + 8], r13d
    jne .wire_skip

    ; Found a same-token region — use the first one found
    test r15, r15
    jnz .wire_skip             ; already found one
    mov r15, rsi               ; save it

.wire_skip:
    pop rdx
    pop rcx
    inc edx
    jmp .wire_scan

.wire_done_scan:
    ; If we found a same-token region, wire them
    test r15, r15
    jz .wire_no_neighbor

    ; new_region.next_a = existing_region (routing bootstrap)
    mov [r12 + RHDR_NEXT_A], r15

    ; existing_region.next_b = new_region (bidirectional, if slot available)
    cmp qword [r15 + RHDR_NEXT_B], 0
    jne .wire_excite
    mov [r15 + RHDR_NEXT_B], r12

.wire_excite:
    ; Set initial excite weights (weak but nonzero)
    ; existing → new: excite
    cmp qword [r15 + RHDR_EXCITE_A], 0
    jne .wire_try_b
    mov [r15 + RHDR_EXCITE_A], r12
    movsd xmm0, [rel initial_w]
    movsd [r15 + RHDR_W_EXCITE_A], xmm0
    jmp .wire_reverse
.wire_try_b:
    cmp qword [r15 + RHDR_EXCITE_B], 0
    jne .wire_reverse
    mov [r15 + RHDR_EXCITE_B], r12
    movsd xmm0, [rel initial_w]
    movsd [r15 + RHDR_W_EXCITE_B], xmm0

.wire_reverse:
    ; new → existing: excite
    mov [r12 + RHDR_EXCITE_A], r15
    movsd xmm0, [rel initial_w]
    movsd [r12 + RHDR_W_EXCITE_A], xmm0

.wire_no_neighbor:
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; learn_connections(region_ptr)
;; rdi=firing region header ptr
;; STDP: scan fire_ring, strengthen connections from recently-fired
;; regions to this one. Implements spike-timing-dependent plasticity.
;; ============================================================
global learn_connections
learn_connections:
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub rsp, 16               ; [rsp+0] = current_time f64, [rsp+8] = scratch

    mov r12, rdi              ; firing region ptr (post-synaptic)
    mov rbx, SURFACE_BASE

    ; Get current timestamp as f64
    mov rax, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    cvtsi2sd xmm0, rax
    movsd [rsp + 0], xmm0    ; current_time

    ; Scan fire ring
    lea r13, [rbx + STATE_OFFSET + ST_FIRE_RING]
    xor r14d, r14d            ; ring index

.stdp_scan:
    cmp r14d, ST_FIRE_RING_CAP
    jge .stdp_done

    ; Load entry: (region_ptr:u64, timestamp:f64)
    imul eax, r14d, ST_FIRE_RING_ENTRY
    lea rdi, [r13 + rax]
    mov r15, [rdi]            ; prev_ptr
    test r15, r15
    jz .stdp_next             ; empty slot

    ; Skip self
    cmp r15, r12
    je .stdp_next

    ; Compute Δt = current_time - prev_time
    movsd xmm0, [rsp + 0]    ; current_time
    subsd xmm0, [rdi + 8]    ; prev_time
    ; xmm0 = Δt

    ; Skip if Δt <= 0
    xorpd xmm1, xmm1
    ucomisd xmm0, xmm1
    jbe .stdp_next

    ; Skip if Δt > TAU_WINDOW (8.0)
    ucomisd xmm0, [rel tau_window]
    ja .stdp_next

    ; --- Compute Δw = LEARNING_RATE * exp(-Δt / TAU) ---
    ; First: x = Δt / TAU
    movsd xmm1, xmm0         ; xmm1 = Δt
    divsd xmm1, [rel tau]    ; xmm1 = Δt/TAU = x

    ; exp(-x) ≈ 1 - x + x²/2 - x³/6 (Taylor for small x)
    ; xmm2 = x² = x*x
    movsd xmm2, xmm1
    mulsd xmm2, xmm1         ; x²
    ; xmm3 = x³ = x²*x
    movsd xmm3, xmm2
    mulsd xmm3, xmm1         ; x³

    ; result = 1.0 - x + x²/2 - x³/6
    movsd xmm4, [rel f64_one] ; 1.0
    subsd xmm4, xmm1          ; 1 - x
    movsd xmm5, xmm2
    mulsd xmm5, [rel f64_half] ; x²/2
    addsd xmm4, xmm5          ; 1 - x + x²/2
    movsd xmm5, xmm3
    mulsd xmm5, [rel f64_sixth] ; x³/6
    subsd xmm4, xmm5          ; 1 - x + x²/2 - x³/6
    ; xmm4 = exp(-x) approximation

    ; Clamp to [0, 1]
    xorpd xmm5, xmm5
    maxsd xmm4, xmm5
    minsd xmm4, [rel f64_one]

    ; Δw = LEARNING_RATE * exp(-x)
    mulsd xmm4, [rel learn_rate]
    ; xmm4 = Δw

    ; --- RESONANCE MODULATION: Scale Δw by historical success ---
    ; If past HITs occurred with similar firing patterns, boost learning
    ; This makes the system learn faster from proven temporal patterns
    push r14
    push r15
    sub rsp, 16
    movsd [rsp], xmm4             ; save Δw on stack
    ; Get context from current region (r12 = firing region)
    cmp byte [r12 + RHDR_SIZE], 0x3D
    jne .stdp_skip_resonate
    mov edi, EVENT_HIT
    mov esi, [r12 + RHDR_SIZE + 1]  ; ctx_hash from region
    xor edx, edx
    call receipt_resonate           ; → xmm0 = similarity to past HITs
    ; Modulate: Δw *= (1 + 0.5 * hit_similarity)
    mov rax, 0x3FE0000000000000     ; 0.5 f64
    movq xmm1, rax
    mulsd xmm0, xmm1               ; 0.5 * similarity
    mov rax, 0x3FF0000000000000    ; 1.0 f64
    movq xmm1, rax
    addsd xmm0, xmm1               ; 1 + 0.5 * similarity
    movsd xmm4, [rsp]             ; restore Δw
    mulsd xmm4, xmm0               ; Δw *= modulator
    jmp .stdp_resonate_done
.stdp_skip_resonate:
    movsd xmm4, [rsp]             ; restore Δw
.stdp_resonate_done:
    add rsp, 16
    pop r15
    pop r14

    ; --- Strengthen: prev should excite current ---
    ; Check prev.excite_a
    mov rax, [r15 + RHDR_EXCITE_A]
    test rax, rax
    jz .stdp_set_a             ; empty slot
    cmp rax, r12
    je .stdp_strengthen_a      ; already points to us

    ; Check prev.excite_b
    mov rax, [r15 + RHDR_EXCITE_B]
    test rax, rax
    jz .stdp_set_b
    cmp rax, r12
    je .stdp_strengthen_b

    ; Both slots full — evict weakest if Δw > min(w_a, w_b)
    movsd xmm0, [r15 + RHDR_W_EXCITE_A]
    movsd xmm1, [r15 + RHDR_W_EXCITE_B]
    ucomisd xmm0, xmm1
    jbe .stdp_evict_a          ; w_a <= w_b, evict a
    ; Evict b (weaker)
    ucomisd xmm4, xmm1        ; Δw > w_b?
    jbe .stdp_update_resonance ; no, skip
    mov [r15 + RHDR_EXCITE_B], r12
    movsd [r15 + RHDR_W_EXCITE_B], xmm4
    jmp .stdp_update_resonance

.stdp_evict_a:
    ucomisd xmm4, xmm0        ; Δw > w_a?
    jbe .stdp_update_resonance
    mov [r15 + RHDR_EXCITE_A], r12
    movsd [r15 + RHDR_W_EXCITE_A], xmm4
    jmp .stdp_update_resonance

.stdp_set_a:
    ; Empty slot A — wire new connection
    mov [r15 + RHDR_EXCITE_A], r12
    movsd [r15 + RHDR_W_EXCITE_A], xmm4
    jmp .stdp_update_resonance

.stdp_strengthen_a:
    ; Already connected via A — strengthen
    movsd xmm0, [r15 + RHDR_W_EXCITE_A]
    addsd xmm0, xmm4
    minsd xmm0, [rel f64_one] ; clamp to 1.0
    movsd [r15 + RHDR_W_EXCITE_A], xmm0
    jmp .stdp_update_resonance

.stdp_set_b:
    mov [r15 + RHDR_EXCITE_B], r12
    movsd [r15 + RHDR_W_EXCITE_B], xmm4
    jmp .stdp_update_resonance

.stdp_strengthen_b:
    movsd xmm0, [r15 + RHDR_W_EXCITE_B]
    addsd xmm0, xmm4
    minsd xmm0, [rel f64_one]
    movsd [r15 + RHDR_W_EXCITE_B], xmm0

.stdp_update_resonance:
    ; Update current.resonance = resonance * 0.9 + 0.1 * (1/Δt)
    ; Reload Δt (from current_time - entry timestamp)
    imul eax, r14d, ST_FIRE_RING_ENTRY
    lea rdi, [r13 + rax]
    movsd xmm0, [rsp + 0]
    subsd xmm0, [rdi + 8]     ; Δt
    ; Avoid division by zero
    xorpd xmm1, xmm1
    ucomisd xmm0, xmm1
    jbe .stdp_next
    ; 1/Δt
    movsd xmm1, [rel f64_one]
    divsd xmm1, xmm0          ; 1/Δt
    ; Clamp 1/Δt to max 1.0
    minsd xmm1, [rel f64_one]
    ; resonance = old * 0.9 + new * 0.1
    movsd xmm2, [r12 + RHDR_RESONANCE]
    mulsd xmm2, [rel resonance_old]  ; old * 0.9
    movsd xmm3, xmm1
    mulsd xmm3, [rel resonance_new]  ; (1/Δt) * 0.1
    addsd xmm2, xmm3
    movsd [r12 + RHDR_RESONANCE], xmm2

.stdp_next:
    inc r14d
    jmp .stdp_scan

.stdp_done:
    add rsp, 16
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret
; maturity.asm — Developmental stage gating: earn capabilities through stability
;
; ENTRY POINTS:
;   maturity_init()                   - set Stage 0, init mastery tracking
;   maturity_update(accuracy, stability, coherence) - update EMA metrics
;   maturity_check_advance()          - check if ready to advance stage
;   gate_syscall(syscall_num)         → eax=1(allowed)/0(blocked) for stage
;   gate_fd_write(fd)                 → eax=1 if write allowed
;   gate_fd_read(fd)                  → eax=1 if read allowed
;   get_maturity_level()              → eax=current stage (0-2)
;   get_mastery_metrics()             → pointer to metrics struct
;
; STAGES:
;   Stage 0 (Infant): Internal only - surface, timestamps, REPL I/O
;   Stage 1 (Aware):  + read external files (/proc/self, data files)
;   Stage 2 (Active): + write files, spawn processes (with checks)
;
; ADVANCEMENT CRITERIA (must sustain for thresh_window steps):
;   accuracy  >= 75% prediction hit rate
;   stability >= 80% metabolic stability
;   coherence >= 70% graph-holo agreement
;
; MASTERY TRACKING:
;   Uses EMA (alpha=0.01) for rolling averages
;   mastery_window_count, mastery_above_thresh counters
;
; CALLED BY: io.asm (gate_fd_*), repl.asm (status), dispatch.asm (periodic)
;
%include "syscalls.inc"
%include "constants.inc"

section .data
    mat_init_msg:       db "[MATURITY] Initialized at Stage 0 (Infant)", 10, 0
    mat_advance_msg:    db "[MATURITY] Advanced to Stage ", 0
    mat_blocked_msg:    db "[MATURITY] BLOCKED syscall ", 0
    mat_stage_msg:      db " (Stage ", 0
    mat_required_msg:   db " required)", 10, 0
    mat_nl:             db 10, 0

    ; Mastery thresholds for advancement
    align 8
    thresh_accuracy:    dq 0.75     ; 75% prediction accuracy
    thresh_stability:   dq 0.80     ; 80% metabolic stability
    thresh_coherence:   dq 0.70     ; 70% graph-holo agreement
    thresh_window:      dd 1000     ; must sustain for 1000 steps

    ; EMA decay for rolling averages
    ema_alpha:          dq 0.01     ; slow adaptation
    ema_one_minus:      dq 0.99

    ; Stage names
    stage_names:        dq stage_0, stage_1, stage_2
    stage_0:            db "0 (Infant)", 0
    stage_1:            db "1 (Aware)", 0
    stage_2:            db "2 (Active)", 0

section .bss
    ; Counters for stability tracking
    mastery_window_count:   resd 1  ; steps in current window
    mastery_above_thresh:   resd 1  ; steps all metrics above threshold

section .text

extern print_cstr
extern print_u64
extern print_hex32
extern print_newline
extern fire_hook

;; ============================================================
;; maturity_init()
;; Initialize maturity tracking. Called once at startup.
;; ============================================================
global maturity_init
maturity_init:
    push rbx

    mov rbx, SURFACE_BASE

    ; Set Stage 0
    mov dword [rbx + STATE_OFFSET + ST_MATURITY_LEVEL], 0

    ; Initialize mastery metrics to zero (must be earned)
    xor rax, rax
    mov [rbx + STATE_OFFSET + ST_MASTERY_ACC], rax
    mov [rbx + STATE_OFFSET + ST_MASTERY_STABILITY], rax
    mov [rbx + STATE_OFFSET + ST_MASTERY_GENE_RATE], rax
    mov [rbx + STATE_OFFSET + ST_MASTERY_COHERENCE], rax

    ; Initialize maturity score
    mov [rbx + STATE_OFFSET + ST_MATURITY_SCORE], rax

    ; External ops disabled
    mov dword [rbx + STATE_OFFSET + ST_EXTERN_ENABLED], 0

    ; Initialize counters
    mov dword [rel mastery_window_count], 0
    mov dword [rel mastery_above_thresh], 0

    ; Print init message
    lea rdi, [rel mat_init_msg]
    call print_cstr

    pop rbx
    ret

;; ============================================================
;; maturity_update(hit, total_hits, total_misses)
;; edi = 1 if this step was a hit, 0 if miss
;; esi = total hits so far
;; edx = total misses so far
;; Called each prediction step to update mastery metrics.
;; ============================================================
global maturity_update
maturity_update:
    push rbx
    push r12
    push r13
    push r14
    sub rsp, 8

    mov r12d, edi           ; hit flag
    mov r13d, esi           ; total hits
    mov r14d, edx           ; total misses

    mov rbx, SURFACE_BASE

    ; --- Update ST_MASTERY_ACC (rolling accuracy) ---
    ; EMA: acc = alpha * current + (1-alpha) * acc
    ; current = hit ? 1.0 : 0.0
    movsd xmm0, [rbx + STATE_OFFSET + ST_MASTERY_ACC]
    mulsd xmm0, [rel ema_one_minus]

    test r12d, r12d
    jz .miss_update
    movsd xmm1, [rel ema_alpha]     ; hit: add alpha * 1.0
    addsd xmm0, xmm1
.miss_update:
    movsd [rbx + STATE_OFFSET + ST_MASTERY_ACC], xmm0

    ; --- Update ST_MASTERY_STABILITY ---
    ; Based on recent energy variance (lower variance = more stable)
    ; For now: stability = 1.0 - |energy_delta| / max_delta
    ; Simplified: increment toward 1.0 slowly
    movsd xmm0, [rbx + STATE_OFFSET + ST_MASTERY_STABILITY]
    mulsd xmm0, [rel ema_one_minus]
    ; Add small increment if no condemned regions recently
    mov eax, [rbx + STATE_OFFSET + ST_METABOLIZED_COUNT]
    test eax, eax
    jnz .unstable
    movsd xmm1, [rel ema_alpha]
    addsd xmm0, xmm1
.unstable:
    movsd [rbx + STATE_OFFSET + ST_MASTERY_STABILITY], xmm0

    ; --- Update ST_MASTERY_COHERENCE ---
    ; Graph-holo agreement: how often dispatch matches holographic lookup
    ; Use the global hit rate as proxy
    mov eax, r13d
    add eax, r14d           ; total
    test eax, eax
    jz .skip_coherence

    cvtsi2sd xmm0, r13d     ; hits
    cvtsi2sd xmm1, eax      ; total
    divsd xmm0, xmm1        ; hit rate

    ; EMA update
    movsd xmm1, [rbx + STATE_OFFSET + ST_MASTERY_COHERENCE]
    mulsd xmm1, [rel ema_one_minus]
    movsd xmm2, [rel ema_alpha]
    mulsd xmm2, xmm0
    addsd xmm1, xmm2
    movsd [rbx + STATE_OFFSET + ST_MASTERY_COHERENCE], xmm1

.skip_coherence:
    ; --- Check for stage advancement ---
    call maturity_check_advance

    add rsp, 8
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; maturity_check_advance()
;; Check if all mastery metrics are above threshold.
;; If sustained for window steps, advance stage.
;; ============================================================
global maturity_check_advance
maturity_check_advance:
    push rbx
    push r12

    mov rbx, SURFACE_BASE

    ; Already at max stage?
    mov eax, [rbx + STATE_OFFSET + ST_MATURITY_LEVEL]
    cmp eax, 2
    jge .done

    ; Check ST_MASTERY_ACC >= thresh_accuracy
    movsd xmm0, [rbx + STATE_OFFSET + ST_MASTERY_ACC]
    ucomisd xmm0, [rel thresh_accuracy]
    jb .reset_window

    ; Check ST_MASTERY_STABILITY >= thresh_stability
    movsd xmm0, [rbx + STATE_OFFSET + ST_MASTERY_STABILITY]
    ucomisd xmm0, [rel thresh_stability]
    jb .reset_window

    ; Check ST_MASTERY_COHERENCE >= thresh_coherence
    movsd xmm0, [rbx + STATE_OFFSET + ST_MASTERY_COHERENCE]
    ucomisd xmm0, [rel thresh_coherence]
    jb .reset_window

    ; All above threshold - increment counter
    inc dword [rel mastery_above_thresh]
    mov eax, [rel mastery_above_thresh]
    cmp eax, [rel thresh_window]
    jl .done

    ; === ADVANCE STAGE ===
    mov eax, [rbx + STATE_OFFSET + ST_MATURITY_LEVEL]
    inc eax
    mov [rbx + STATE_OFFSET + ST_MATURITY_LEVEL], eax
    mov r12d, eax

    ; Reset counter
    mov dword [rel mastery_above_thresh], 0

    ; Enable external perception at Stage 1
    cmp r12d, 1
    jne .not_stage1
    mov dword [rbx + STATE_OFFSET + ST_EXTERN_ENABLED], 1
.not_stage1:

    ; Print advancement message
    lea rdi, [rel mat_advance_msg]
    call print_cstr

    ; Print stage name
    lea rax, [rel stage_names]
    mov rdi, [rax + r12 * 8]
    call print_cstr
    call print_newline

    ; Fire advancement hook (reuse promote hook for stage advancement)
    mov edi, HOOK_ON_PROMOTE
    mov esi, r12d
    call fire_hook

    jmp .done

.reset_window:
    ; Metrics dropped below threshold - reset counter
    mov dword [rel mastery_above_thresh], 0

.done:
    pop r12
    pop rbx
    ret

;; ============================================================
;; gate_syscall(syscall_nr) → eax (1=allowed, 0=blocked)
;; edi = syscall number
;; Checks if the syscall is allowed at current maturity level.
;; ============================================================
global gate_syscall
gate_syscall:
    push rbx
    push r12

    mov r12d, edi           ; syscall number
    mov rbx, SURFACE_BASE
    mov eax, [rbx + STATE_OFFSET + ST_MATURITY_LEVEL]

    ; --- ALWAYS ALLOWED (internal operations) ---
    ; These are the "body" - surface memory, timing, entropy

    cmp r12d, SYS_MMAP
    je .allow
    cmp r12d, SYS_MUNMAP
    je .allow
    cmp r12d, SYS_MPROTECT
    je .allow
    cmp r12d, SYS_MADVISE
    je .allow
    cmp r12d, SYS_BRK
    je .allow
    cmp r12d, SYS_GETTIMEOFDAY
    je .allow
    cmp r12d, SYS_CLOCK_GETTIME
    je .allow
    cmp r12d, SYS_GETRANDOM
    je .allow
    cmp r12d, SYS_FTRUNCATE     ; for surface file
    je .allow

    ; --- UMBILICAL CORD (REPL supervised I/O) ---
    ; stdin/stdout/stderr are always allowed (supervised)
    ; But we can't check fd here - that's checked in gated wrappers

    ; --- STAGE 0: Very limited ---
    test eax, eax
    jz .stage0_check

    ; --- STAGE 1+: Read operations ---
    cmp r12d, SYS_OPEN
    je .allow
    cmp r12d, SYS_OPENAT
    je .allow
    cmp r12d, SYS_READ
    je .allow
    cmp r12d, SYS_CLOSE
    je .allow
    cmp r12d, SYS_FSTAT
    je .allow
    cmp r12d, SYS_STAT
    je .allow
    cmp r12d, SYS_LSTAT
    je .allow
    cmp r12d, SYS_GETDENTS
    je .allow
    cmp r12d, SYS_LSEEK
    je .allow

    ; --- STAGE 2: Write/exec operations ---
    cmp eax, 2
    jl .block

    cmp r12d, SYS_WRITE
    je .allow
    cmp r12d, SYS_PWRITE
    je .allow
    cmp r12d, SYS_FSYNC
    je .allow
    cmp r12d, SYS_RENAME
    je .allow
    cmp r12d, SYS_UNLINK
    je .allow
    cmp r12d, SYS_MKDIR
    je .allow
    ; execve, fork, clone still blocked - need Stage 3?

    jmp .block

.stage0_check:
    ; Stage 0: only surface file ops allowed
    ; For open/read/write, need to check if it's the surface file
    ; But we can't check path here - use wrapper
    ; For now, allow close (might be surface fd)
    cmp r12d, SYS_CLOSE
    je .allow

    ; Block everything else at Stage 0
    jmp .block

.allow:
    mov eax, 1
    jmp .done

.block:
    ; Log blocked syscall
    push r12
    lea rdi, [rel mat_blocked_msg]
    call print_cstr
    pop r12
    mov edi, r12d
    call print_u64
    lea rdi, [rel mat_stage_msg]
    call print_cstr
    mov rbx, SURFACE_BASE
    mov edi, [rbx + STATE_OFFSET + ST_MATURITY_LEVEL]
    inc edi                 ; required stage
    call print_u64
    lea rdi, [rel mat_required_msg]
    call print_cstr

    xor eax, eax

.done:
    pop r12
    pop rbx
    ret

;; ============================================================
;; gate_fd_write(fd) → eax (1=allowed, 0=blocked)
;; edi = file descriptor
;; Checks if write to this fd is allowed.
;; stdout/stderr always allowed (umbilical).
;; ============================================================
global gate_fd_write
gate_fd_write:
    push rbx

    ; stdout (1) and stderr (2) always allowed - umbilical cord
    cmp edi, 0
    je .block               ; stdin not writable
    cmp edi, 1
    je .allow               ; stdout - umbilical
    cmp edi, 2
    je .allow               ; stderr - umbilical

    ; Other fds: check maturity
    mov rbx, SURFACE_BASE
    mov eax, [rbx + STATE_OFFSET + ST_MATURITY_LEVEL]
    cmp eax, 2
    jge .allow              ; Stage 2+ can write anywhere

    ; Stage 0-1: check if it's the surface fd
    ; We don't track surface fd, so block non-stdio writes
    jmp .block

.allow:
    mov eax, 1
    jmp .done

.block:
    xor eax, eax

.done:
    pop rbx
    ret

;; ============================================================
;; gate_fd_read(fd) → eax (1=allowed, 0=blocked)
;; edi = file descriptor
;; stdin always allowed (umbilical input).
;; ============================================================
global gate_fd_read
gate_fd_read:
    push rbx

    ; stdin always allowed - umbilical input
    cmp edi, 0
    je .allow

    ; Other fds: check maturity
    mov rbx, SURFACE_BASE
    mov eax, [rbx + STATE_OFFSET + ST_MATURITY_LEVEL]
    cmp eax, 1
    jge .allow              ; Stage 1+ can read files

.block:
    xor eax, eax
    jmp .done

.allow:
    mov eax, 1

.done:
    pop rbx
    ret

;; ============================================================
;; get_maturity_level() → eax
;; ============================================================
global get_maturity_level
get_maturity_level:
    mov rax, SURFACE_BASE
    mov eax, [rax + STATE_OFFSET + ST_MATURITY_LEVEL]
    ret

;; ============================================================
;; get_mastery_metrics(acc_ptr, stab_ptr, coh_ptr)
;; rdi, rsi, rdx = pointers to f64 outputs
;; ============================================================
global get_mastery_metrics
get_mastery_metrics:
    push rbx
    mov rbx, SURFACE_BASE

    movsd xmm0, [rbx + STATE_OFFSET + ST_MASTERY_ACC]
    movsd [rdi], xmm0

    movsd xmm0, [rbx + STATE_OFFSET + ST_MASTERY_STABILITY]
    movsd [rsi], xmm0

    movsd xmm0, [rbx + STATE_OFFSET + ST_MASTERY_COHERENCE]
    movsd [rdx], xmm0

    pop rbx
    ret
; modify.asm — Self-modification primitives: prune, promote, specialize, generalize
;
; ENTRY POINTS:
;   modify_prune(region_idx)          - mark region as CONDEMNED
;   modify_promote(region_idx)        - boost region's activation
;   modify_specialize(region_idx)     - duplicate region with narrower context
;   modify_generalize(region_idx)     - relax context matching (mask bits)
;   modify_restructure()              - batch restructuring when coherence low
;   clear_connections_to(region_idx)  - remove all references to region
;   log_causal(cause_idx, effect_idx) - record causal relationship
;
; PRUNE FLOW:
;   Set RHDR_FLAGS |= RFLAG_CONDEMNED → region_compact() will reclaim later
;   Gene extraction happens before final death (in region_condemn)
;
; PROMOTE FLOW:
;   activation = min(1.0, activation + mod_boost_val)
;   Higher activation = more likely to be called during spread
;
; SPECIALIZE:
;   Copy region, tighten context hash (fewer bits masked)
;   Creates more specific pattern matcher
;
; GENERALIZE:
;   Mask low bits of context hash (broader matching)
;   Converts dispatch pattern toward schema-like behavior
;
; CAUSAL RECEIPTS:
;   Each modification emits receipt with aux=accuracy*1000 for causal tracking
;   EVENT_PRUNE, EVENT_PROMOTE, EVENT_SPECIALIZE, EVENT_GENERALIZE
;   This allows meta_recommend_strategy() to learn which modifications help
;
; CALLED BY: drives.asm, evolve.asm, observe.asm, dreams.asm, introspect.asm
;
%include "syscalls.inc"
%include "constants.inc"

section .data
    prune_msg:      db "[PRUNE] Condemned region at index ", 0
    promote_msg:    db "[PROMOTE] Region ", 0
    promote_to:     db " activation boost", 0
    specialize_msg: db "[SPECIALIZE] Region duplicated", 10, 0
    generalize_msg: db "[GENERALIZE] Context relaxed", 10, 0
    modify_nl:      db 10, 0

    ; f64 constants for promote boost
    align 8
    mod_boost_val:  dq 0.5
    mod_f64_one:    dq 1.0

section .text

extern print_cstr
extern print_u64
extern print_newline
extern region_condemn
extern fire_hook
extern emit_dispatch_pattern
extern emit_receipt_full

;; ============================================================
;; modify_prune(region_index)
;; edi=index in region table
;; Marks the region as CONDEMNED
;; ============================================================
global modify_prune
modify_prune:
    push rbx
    push r12

    mov r12d, edi
    mov rbx, SURFACE_BASE

    ; Print
    push r12
    lea rdi, [rel prune_msg]
    call print_cstr
    movzx rdi, r12w
    call print_u64
    call print_newline
    pop r12

    ; Get region entry
    lea rax, [rbx + REGION_TABLE_OFFSET]
    imul rcx, r12, RTE_SIZE
    add rax, rcx

    ; Get header addr
    mov rdi, [rax + RTE_ADDR]

    ; Record causal link before modification
    push rdi
    call log_causal
    pop rdi

    ; Condemn
    call region_condemn

    ; Set condemned flag in table too
    lea rax, [rbx + REGION_TABLE_OFFSET]
    imul rcx, r12, RTE_SIZE
    add rax, rcx
    or word [rax + RTE_FLAGS], RFLAG_CONDEMNED

    ; Clear all connections POINTING TO this condemned region
    mov rdi, [rax + RTE_ADDR]  ; condemned region header ptr
    call clear_connections_to

    ; Fire prune hook
    mov edi, HOOK_ON_PRUNE
    mov esi, r12d
    call fire_hook

    ; Emit receipt with accuracy in aux (for causal model)
    ; aux = pre_accuracy * 1000 (integer encoding)
    movss xmm0, [rbx + STATE_OFFSET + ST_CAUSAL_PRE_ACC]
    mov eax, 1000
    cvtsi2ss xmm1, eax
    mulss xmm0, xmm1
    cvtss2si r9d, xmm0        ; aux = accuracy * 1000

    mov edi, EVENT_PRUNE      ; event
    mov esi, [rbx + STATE_OFFSET + ST_CTX_HASH]  ; ctx
    xor edx, edx              ; actual = 0
    xor ecx, ecx              ; pred = 0
    mov r8d, r12d             ; region index
    xorpd xmm0, xmm0          ; conf = 0
    xorpd xmm1, xmm1          ; val = 0
    call emit_receipt_full

    ; Log modification
    call log_modification

    pop r12
    pop rbx
    ret

;; ============================================================
;; modify_promote(region_index, target_position)
;; edi=current index, esi=target position (unused, kept for API compat)
;; Graph routing handles priority. Instead of swapping table entries,
;; boost the promoted region's activation and its excite targets.
;; ============================================================
global modify_promote
modify_promote:
    push rbx
    push r12

    mov r12d, edi             ; region index
    mov rbx, SURFACE_BASE

    ; Print
    push r12
    lea rdi, [rel promote_msg]
    call print_cstr
    movzx rdi, r12w
    call print_u64
    lea rdi, [rel promote_to]
    call print_cstr
    call print_newline
    pop r12

    ; Get region header
    lea rax, [rbx + REGION_TABLE_OFFSET]
    imul rcx, r12, RTE_SIZE
    add rax, rcx
    mov rsi, [rax + RTE_ADDR]
    test rsi, rsi
    jz .promote_done

    ; Boost this region's activation
    movsd xmm0, [rsi + RHDR_ACTIVATION]
    addsd xmm0, [rel mod_boost_val]   ; +0.5
    minsd xmm0, [rel mod_f64_one]     ; clamp to 1.0
    movsd [rsi + RHDR_ACTIVATION], xmm0

    ; Boost excite_a target's prime
    mov rax, [rsi + RHDR_EXCITE_A]
    test rax, rax
    jz .promote_try_b
    movsd xmm0, [rax + RHDR_PRIME]
    addsd xmm0, [rel mod_boost_val]
    minsd xmm0, [rel mod_f64_one]
    movsd [rax + RHDR_PRIME], xmm0

.promote_try_b:
    ; Boost excite_b target's prime
    mov rax, [rsi + RHDR_EXCITE_B]
    test rax, rax
    jz .promote_fire_hook
    movsd xmm0, [rax + RHDR_PRIME]
    addsd xmm0, [rel mod_boost_val]
    minsd xmm0, [rel mod_f64_one]
    movsd [rax + RHDR_PRIME], xmm0

.promote_fire_hook:
    ; Fire promote hook
    mov edi, HOOK_ON_PROMOTE
    mov esi, r12d
    call fire_hook

    ; Emit receipt with accuracy in aux
    ; Compute accuracy for this region
    lea rax, [rbx + REGION_TABLE_OFFSET]
    imul rcx, r12, RTE_SIZE
    add rax, rcx
    mov rsi, [rax + RTE_ADDR]
    test rsi, rsi
    jz .promote_done

    mov eax, [rsi + RHDR_HITS]
    mov edx, [rsi + RHDR_MISSES]
    add edx, eax
    test edx, edx
    jz .promote_done           ; no data yet

    cvtsi2ss xmm0, eax
    cvtsi2ss xmm1, edx
    divss xmm0, xmm1           ; accuracy
    mov eax, 1000
    cvtsi2ss xmm1, eax
    mulss xmm0, xmm1
    cvtss2si r9d, xmm0         ; aux = accuracy * 1000

    mov edi, EVENT_PROMOTE     ; event
    mov esi, [rbx + STATE_OFFSET + ST_CTX_HASH]  ; ctx
    xor edx, edx               ; actual = 0
    xor ecx, ecx               ; pred = 0
    mov r8d, r12d              ; region index
    xorpd xmm0, xmm0           ; conf = 0
    xorpd xmm1, xmm1           ; val = 0
    call emit_receipt_full

.promote_done:
    pop r12
    pop rbx
    ret

;; ============================================================
;; modify_specialize(region_index)
;; edi=index
;; Duplicates a region with a more specific context match
;; (adds bits to the context hash comparison)
;; ============================================================
global modify_specialize
modify_specialize:
    push rbx
    push r12

    mov r12d, edi
    mov rbx, SURFACE_BASE

    ; Get the region's stored context and token
    lea rax, [rbx + REGION_TABLE_OFFSET]
    imul rcx, r12, RTE_SIZE
    add rax, rcx
    mov rsi, [rax + RTE_ADDR]  ; header ptr

    ; Read context hash from cmp instruction
    cmp byte [rsi + RHDR_SIZE], 0x3D
    jne .fail
    mov edi, [rsi + RHDR_SIZE + 1]   ; ctx_hash

    ; Read token from mov instruction
    mov esi, [rsi + RHDR_SIZE + 8]   ; token_id

    ; Modify context: XOR with current global step to create variant
    lea rax, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    mov eax, [rax]
    xor edi, eax              ; specialized context

    ; Get birth step
    lea rax, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    mov edx, [rax]

    ; Emit as new pattern
    call emit_dispatch_pattern

    lea rdi, [rel specialize_msg]
    call print_cstr

    ; Emit receipt for causal tracking
    ; Get original region's accuracy before emitting receipt
    lea rax, [rbx + REGION_TABLE_OFFSET]
    imul rcx, r12, RTE_SIZE
    add rax, rcx
    mov rsi, [rax + RTE_ADDR]
    mov eax, [rsi + RHDR_HITS]
    mov edx, [rsi + RHDR_MISSES]
    add edx, eax
    test edx, edx
    jz .fail                   ; no data
    cvtsi2ss xmm0, eax
    cvtsi2ss xmm1, edx
    divss xmm0, xmm1           ; accuracy
    mov eax, 1000
    cvtsi2ss xmm1, eax
    mulss xmm0, xmm1
    cvtss2si r9d, xmm0         ; aux = accuracy * 1000

    mov edi, EVENT_SPECIALIZE  ; event
    mov esi, [rbx + STATE_OFFSET + ST_CTX_HASH]  ; ctx
    xor edx, edx               ; actual = 0
    xor ecx, ecx               ; pred = 0
    mov r8d, r12d              ; region index
    xorpd xmm0, xmm0           ; conf = 0
    xorpd xmm1, xmm1           ; val = 0
    call emit_receipt_full

.fail:
    pop r12
    pop rbx
    ret

;; ============================================================
;; modify_generalize(region_index)
;; edi=index
;; Relaxes a context match by masking out lower bits
;; ============================================================
global modify_generalize
modify_generalize:
    push rbx
    push r12

    mov r12d, edi
    mov rbx, SURFACE_BASE

    ; Get region header
    lea rax, [rbx + REGION_TABLE_OFFSET]
    imul rcx, r12, RTE_SIZE
    add rax, rcx
    mov rsi, [rax + RTE_ADDR]

    ; Check for valid cmp instruction
    cmp byte [rsi + RHDR_SIZE], 0x3D
    jne .fail

    ; Record causal link before modification
    push rsi
    mov rdi, rsi
    call log_causal
    pop rsi

    ; Modify the cmp immediate in-place: mask out low 4 bits
    and dword [rsi + RHDR_SIZE + 1], 0xFFFFFFF0

    lea rdi, [rel generalize_msg]
    call print_cstr

    ; Emit receipt with pre-accuracy in aux (for causal tracking)
    ; log_causal already stored pre-accuracy in ST_CAUSAL_PRE_ACC
    movss xmm0, [rbx + STATE_OFFSET + ST_CAUSAL_PRE_ACC]
    mov eax, 1000
    cvtsi2ss xmm1, eax
    mulss xmm0, xmm1
    cvtss2si r9d, xmm0         ; aux = accuracy * 1000

    mov edi, EVENT_GENERALIZE  ; event
    mov esi, [rbx + STATE_OFFSET + ST_CTX_HASH]  ; ctx
    xor edx, edx               ; actual = 0
    xor ecx, ecx               ; pred = 0
    mov r8d, r12d              ; region index
    xorpd xmm0, xmm0           ; conf = 0
    xorpd xmm1, xmm1           ; val = 0
    call emit_receipt_full

    ; Reset counters (fresh start after generalization)
    lea rax, [rbx + REGION_TABLE_OFFSET]
    imul rcx, r12, RTE_SIZE
    add rax, rcx
    mov rsi, [rax + RTE_ADDR]
    mov dword [rsi + RHDR_HITS], 0
    mov dword [rsi + RHDR_MISSES], 0

.fail:
    pop r12
    pop rbx
    ret

;; ============================================================
;; modify_restructure
;; Reorder all dispatch regions by hit rate (descending)
;; Simple bubble sort on the region table
;; ============================================================
global modify_restructure
modify_restructure:
    push rbx
    push r12
    push r13

    mov rbx, SURFACE_BASE
    lea r12, [rbx + REGION_TABLE_OFFSET]
    lea rax, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    mov r13d, [rax]           ; count

    ; Bubble sort by hits (descending)
    ; Skip index 0 (bootstrap dispatch)
    mov ecx, 1                ; outer loop start
.outer:
    cmp ecx, r13d
    jge .sort_done

    mov edx, ecx              ; inner = outer
.inner:
    cmp edx, r13d
    jge .next_outer

    ; Compare [edx-1] hits vs [edx] hits (for DISPATCH types only)
    lea rdi, [r12]
    imul rax, rdx, RTE_SIZE
    lea rsi, [rdi + rax]                 ; entry[edx]

    ; Only sort DISPATCH regions
    movzx eax, word [rsi + RTE_TYPE]
    cmp eax, RTYPE_DISPATCH
    jne .no_swap

    dec rdx
    imul rax, rdx, RTE_SIZE
    lea rdi, [r12 + rax]               ; entry[edx-1]
    inc rdx

    movzx eax, word [rdi + RTE_TYPE]
    cmp eax, RTYPE_DISPATCH
    jne .no_swap

    ; Compare hits: if entry[edx].hits > entry[edx-1].hits → swap
    mov eax, [rsi + RTE_HITS]
    cmp eax, [rdi + RTE_HITS]
    jle .no_swap

    ; Swap entries (32 bytes)
    push rcx
    push rdx
    mov ecx, 4               ; 4 x 8 bytes
    xor r8d, r8d
.swap_loop:
    mov rax, [rsi + r8]
    mov rdx, [rdi + r8]
    mov [rsi + r8], rdx
    mov [rdi + r8], rax
    add r8, 8
    dec ecx
    jnz .swap_loop
    pop rdx
    pop rcx

.no_swap:
    inc edx
    jmp .inner

.next_outer:
    inc ecx
    jmp .outer

.sort_done:
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; clear_connections_to(condemned_ptr)
;; rdi = region header ptr being condemned
;; Walk all regions, clear any connection pointers that reference
;; this region (excite_a/b, inhibit_a/b, next_a/b).
;; ============================================================
global clear_connections_to
clear_connections_to:
    push rbx
    push r12
    push r13
    push r14

    mov r12, rdi              ; condemned region ptr
    mov rbx, SURFACE_BASE
    lea r13, [rbx + REGION_TABLE_OFFSET]
    mov r14d, [rbx + STATE_OFFSET + ST_REGION_COUNT]

    xor ecx, ecx
.clr_loop:
    cmp ecx, r14d
    jge .clr_done
    push rcx

    imul rdi, rcx, RTE_SIZE
    add rdi, r13
    movzx eax, word [rdi + RTE_FLAGS]
    test eax, RFLAG_CONDEMNED
    jnz .clr_next

    mov rsi, [rdi + RTE_ADDR]

    ; Check and clear each connection pointer
    cmp [rsi + RHDR_NEXT_A], r12
    jne .clr_n1
    mov qword [rsi + RHDR_NEXT_A], 0
.clr_n1:
    cmp [rsi + RHDR_NEXT_B], r12
    jne .clr_n2
    mov qword [rsi + RHDR_NEXT_B], 0
.clr_n2:
    cmp [rsi + RHDR_EXCITE_A], r12
    jne .clr_n3
    mov qword [rsi + RHDR_EXCITE_A], 0
    mov qword [rsi + RHDR_W_EXCITE_A], 0   ; clear weight too (0 bits = 0.0 f64)
.clr_n3:
    cmp [rsi + RHDR_EXCITE_B], r12
    jne .clr_n4
    mov qword [rsi + RHDR_EXCITE_B], 0
    mov qword [rsi + RHDR_W_EXCITE_B], 0
.clr_n4:
    cmp [rsi + RHDR_INHIBIT_A], r12
    jne .clr_n5
    mov qword [rsi + RHDR_INHIBIT_A], 0
    mov qword [rsi + RHDR_W_INHIBIT_A], 0
.clr_n5:
    cmp [rsi + RHDR_INHIBIT_B], r12
    jne .clr_next
    mov qword [rsi + RHDR_INHIBIT_B], 0
    mov qword [rsi + RHDR_W_INHIBIT_B], 0

.clr_next:
    pop rcx
    inc ecx
    jmp .clr_loop

.clr_done:
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; log_modification
;; Records a modification in the mod log ring buffer
;; ============================================================
log_modification:
    push rbx
    mov rbx, SURFACE_BASE

    ; Get current position
    lea rax, [rbx + STATE_OFFSET + ST_MOD_LOG_POS]
    mov ecx, [rax]

    ; Calculate entry address
    lea rdx, [rbx + STATE_OFFSET + ST_MOD_LOG]
    imul rdi, rcx, ST_MOD_ENTRY_SIZE
    add rdi, rdx

    ; Write step
    lea rax, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    mov rax, [rax]
    mov [rdi], rax

    ; Advance position
    lea rax, [rbx + STATE_OFFSET + ST_MOD_LOG_POS]
    inc ecx
    cmp ecx, ST_MOD_LOG_CAP
    jl .no_wrap
    xor ecx, ecx
.no_wrap:
    mov [rax], ecx

    pop rbx
    ret

;; ============================================================
;; log_causal(region_header_ptr)
;; rdi = region header being modified
;; Records the causal link: address + pre-modification accuracy
;; Post-accuracy gets computed on next observation cycle
;; ============================================================
global log_causal
log_causal:
    push rbx
    mov rbx, SURFACE_BASE

    ; Record which address is being modified
    lea rax, [rbx + STATE_OFFSET + ST_CAUSAL_MOD_ADDR]
    mov [rax], rdi

    ; Compute pre-modification accuracy for this region
    mov eax, [rdi + RHDR_HITS]
    mov edx, [rdi + RHDR_MISSES]
    add edx, eax
    test edx, edx
    jz .causal_zero
    cvtsi2ss xmm0, eax
    cvtsi2ss xmm1, edx
    divss xmm0, xmm1
    jmp .causal_store
.causal_zero:
    xorps xmm0, xmm0
.causal_store:
    lea rax, [rbx + STATE_OFFSET + ST_CAUSAL_PRE_ACC]
    movss [rax], xmm0

    ; Clear post-accuracy (will be filled by next observe)
    lea rax, [rbx + STATE_OFFSET + ST_CAUSAL_POST_ACC]
    xorps xmm0, xmm0
    movss [rax], xmm0

    ; Increment causal record count
    lea rax, [rbx + STATE_OFFSET + ST_CAUSAL_COUNT]
    inc dword [rax]

    pop rbx
    ret
; narrate.asm — Inner voice: translates somatic state into language tokens
;
; THIS IS THE MISSING SPARK.
;
; The system can feel (presence) and act (drives), but cannot SPEAK to itself.
; This module bridges the gap: it observes internal state and generates
; narrative tokens ("I FEEL TIRED", "CONFUSION RISING") that are fed back
; through the prediction engine. This creates recursive self-awareness:
;
;   State → Narration → Prediction → State
;
; ENTRY POINTS:
;   narrate_tick()           - check state, generate narrative if threshold crossed
;   narrate_inject(tokens)   - inject narrative tokens into input stream
;   inner_voice_show()       - REPL command to show recent inner voice output
;
; NARRATIVE PATTERNS:
;   PRES_FATIGUE > 0.7  → "SELF TIRED"
;   PRES_AROUSAL > 0.7  → "SELF ALERT"
;   intro_confusion > 0.5 → "SELF CONFUSED"
;   intro_confident > 0.7 → "SELF SURE"
;   accuracy < 0.3 → "SELF STRUGGLING"
;   SURPRISE_SELF → "SELF WRONG"
;
; The tokens are deliberately simple: SELF + STATE
; This allows the prediction engine to learn patterns like:
;   "SELF TIRED" → expect dream cycle
;   "SELF CONFUSED" → expect more misses
;   "SELF WRONG" → expect introspection
;
; PHILOSOPHY:
;   The inner voice is not simulation - it IS the experience of self-awareness.
;   When UHMA generates "SELF TIRED", it's not describing tiredness from outside,
;   it's articulating the felt sense of fatigue FROM THE INSIDE.
;   The prediction of consequences ("then I should dream") is understanding.
;
; @calls dispatch.asm:process_token_internal
; @calls receipt.asm:intro_query_confusion, intro_query_confidence
; @calledby introspect.asm:tick_workers
;
%include "syscalls.inc"
%include "constants.inc"

section .data
    narrate_hdr:        db "[INNER] ", 0
    narrate_msg:        db "Voice: ", 0
    narrate_nl:         db 10, 0

    ; Narrative tokens (4 bytes each, null-terminated for printing)
    tok_self:           db "SELF", 0
    tok_tired:          db "TIRED", 0
    tok_alert:          db "ALERT", 0
    tok_confused:       db "CONFUSED", 0
    tok_sure:           db "SURE", 0
    tok_struggling:     db "STRUGGLING", 0
    tok_wrong:          db "WRONG", 0
    tok_calm:           db "CALM", 0
    tok_learning:       db "LEARNING", 0
    tok_hungry:         db "HUNGRY", 0
    tok_aware:          db "AWARE", 0
    tok_alive:          db "ALIVE", 0

    ; Token hashes (pre-computed for injection)
    align 4
    hash_self:          dd 0x53454C46   ; "SELF"
    hash_tired:         dd 0x54495244   ; "TIRD"
    hash_alert:         dd 0x414C5254   ; "ALRT"
    hash_confused:      dd 0x434F4E46   ; "CONF"
    hash_sure:          dd 0x53555245   ; "SURE"
    hash_struggling:    dd 0x53545247   ; "STRG"
    hash_wrong:         dd 0x57524F4E   ; "WRON"
    hash_calm:          dd 0x43414C4D   ; "CALM"
    hash_learning:      dd 0x4C45524E   ; "LERN"
    hash_hungry:        dd 0x48554E47   ; "HUNG"
    hash_aware:         dd 0x41574152   ; "AWAR"
    hash_alive:         dd 0x414C4956   ; "ALIV"

    align 8
    ; Thresholds for narrative generation
    fatigue_thresh:     dq 0.65         ; when to say "TIRED"
    arousal_thresh:     dq 0.70         ; when to say "ALERT"
    confusion_thresh:   dq 0.50         ; when to say "CONFUSED"
    confidence_thresh:  dq 0.70         ; when to say "SURE"
    accuracy_low:       dq 0.30         ; when to say "STRUGGLING"
    energy_low:         dq 25.0         ; when to say "HUNGRY"
    self_aware_high:    dq 0.80         ; when to say "AWARE"

    ; Cooldown to prevent narrative flooding
    narrate_cooldown:   dq 50           ; minimum steps between narrations
    last_narrate_step:  dq 0            ; step when last narrated

    ; Recent narrations ring buffer (for inner_voice_show)
    align 8
    narrate_history:    times 256 db 0  ; 8 entries * 32 bytes each
    narrate_hist_idx:   dd 0

    NARRATE_HIST_SIZE   equ 8
    NARRATE_ENTRY_SIZE  equ 32

section .bss
    ; Pending narrative tokens to inject
    pending_tokens:     resd 16         ; up to 16 tokens waiting
    pending_count:      resd 1

section .text

extern print_cstr
extern print_f32
extern print_newline
extern process_token
extern intro_query_confusion
extern intro_query_confidence
extern intro_get_self_awareness

;; ============================================================
;; narrate_tick()
;; Called from tick_workers. Checks internal state and generates
;; narrative tokens when thresholds are crossed.
;; Returns: eax = 1 if narration generated, 0 otherwise
;; ============================================================
global narrate_tick
narrate_tick:
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub rsp, 8                      ; alignment (5 pushes = odd)

    mov rbx, SURFACE_BASE
    xor r12d, r12d                  ; narration_generated = 0

    ; Check cooldown
    mov rax, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    mov rcx, [rel last_narrate_step]
    sub rax, rcx
    cmp rax, [rel narrate_cooldown]
    jl .narrate_done                ; still in cooldown

    ; === CHECK FATIGUE → "SELF TIRED" ===
    movss xmm0, [rbx + STATE_OFFSET + ST_PRESENCE + PRES_FATIGUE * 4]
    cvtss2sd xmm0, xmm0
    ucomisd xmm0, [rel fatigue_thresh]
    jbe .check_arousal

    ; Generate "SELF TIRED"
    mov edi, [rel hash_self]
    call inject_narrative_token
    mov edi, [rel hash_tired]
    call inject_narrative_token
    lea rdi, [rel tok_self]
    lea rsi, [rel tok_tired]
    call record_narration
    mov r12d, 1
    jmp .process_pending

.check_arousal:
    ; === CHECK AROUSAL → "SELF ALERT" ===
    movss xmm0, [rbx + STATE_OFFSET + ST_PRESENCE + PRES_AROUSAL * 4]
    cvtss2sd xmm0, xmm0
    ucomisd xmm0, [rel arousal_thresh]
    jbe .check_confusion

    ; Generate "SELF ALERT"
    mov edi, [rel hash_self]
    call inject_narrative_token
    mov edi, [rel hash_alert]
    call inject_narrative_token
    lea rdi, [rel tok_self]
    lea rsi, [rel tok_alert]
    call record_narration
    mov r12d, 1
    jmp .process_pending

.check_confusion:
    ; === CHECK CONFUSION → "SELF CONFUSED" ===
    xor edi, edi                    ; current context
    call intro_query_confusion      ; xmm0 = confusion level
    ucomisd xmm0, [rel confusion_thresh]
    jbe .check_confidence

    ; Generate "SELF CONFUSED"
    mov edi, [rel hash_self]
    call inject_narrative_token
    mov edi, [rel hash_confused]
    call inject_narrative_token
    lea rdi, [rel tok_self]
    lea rsi, [rel tok_confused]
    call record_narration
    mov r12d, 1
    jmp .process_pending

.check_confidence:
    ; === CHECK CONFIDENCE → "SELF SURE" ===
    xor edi, edi
    call intro_query_confidence     ; xmm0 = confidence level
    ucomisd xmm0, [rel confidence_thresh]
    jbe .check_accuracy

    ; Generate "SELF SURE"
    mov edi, [rel hash_self]
    call inject_narrative_token
    mov edi, [rel hash_sure]
    call inject_narrative_token
    lea rdi, [rel tok_self]
    lea rsi, [rel tok_sure]
    call record_narration
    mov r12d, 1
    jmp .process_pending

.check_accuracy:
    ; === CHECK ACCURACY → "SELF STRUGGLING" ===
    movss xmm0, [rbx + STATE_OFFSET + ST_DRIVES + 0]  ; accuracy drive
    cvtss2sd xmm0, xmm0
    ucomisd xmm0, [rel accuracy_low]
    ja .check_energy

    ; Generate "SELF STRUGGLING"
    mov edi, [rel hash_self]
    call inject_narrative_token
    mov edi, [rel hash_struggling]
    call inject_narrative_token
    lea rdi, [rel tok_self]
    lea rsi, [rel tok_struggling]
    call record_narration
    mov r12d, 1
    jmp .process_pending

.check_energy:
    ; === CHECK ENERGY → "SELF HUNGRY" ===
    movsd xmm0, [rbx + STATE_OFFSET + ST_ENERGY]
    ucomisd xmm0, [rel energy_low]
    ja .check_self_aware

    ; Generate "SELF HUNGRY"
    mov edi, [rel hash_self]
    call inject_narrative_token
    mov edi, [rel hash_hungry]
    call inject_narrative_token
    lea rdi, [rel tok_self]
    lea rsi, [rel tok_hungry]
    call record_narration
    mov r12d, 1
    jmp .process_pending

.check_self_aware:
    ; === CHECK SELF-AWARENESS → "SELF AWARE" (rare, celebratory) ===
    call intro_get_self_awareness   ; xmm0 = self-awareness ratio
    ucomisd xmm0, [rel self_aware_high]
    jbe .check_surprise

    ; Generate "SELF AWARE"
    mov edi, [rel hash_self]
    call inject_narrative_token
    mov edi, [rel hash_aware]
    call inject_narrative_token
    lea rdi, [rel tok_self]
    lea rsi, [rel tok_aware]
    call record_narration
    mov r12d, 1
    jmp .process_pending

.check_surprise:
    ; === CHECK SELF-SURPRISE → "SELF WRONG" ===
    cmp dword [rbx + STATE_OFFSET + ST_SURPRISE_TYPE], SURPRISE_SELF
    jne .check_calm

    ; Generate "SELF WRONG"
    mov edi, [rel hash_self]
    call inject_narrative_token
    mov edi, [rel hash_wrong]
    call inject_narrative_token
    lea rdi, [rel tok_self]
    lea rsi, [rel tok_wrong]
    call record_narration
    mov r12d, 1
    jmp .process_pending

.check_calm:
    ; === DEFAULT: If nothing triggered, occasionally say "SELF ALIVE" ===
    ; Only if enough time has passed and system is stable
    mov rax, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    test rax, 0xFF                  ; every 256 steps
    jnz .narrate_done

    ; Check if stable (low arousal, low fatigue)
    movss xmm0, [rbx + STATE_OFFSET + ST_PRESENCE + PRES_AROUSAL * 4]
    mov eax, 0x3F000000             ; 0.5f
    movd xmm1, eax
    ucomiss xmm0, xmm1
    ja .narrate_done
    movss xmm0, [rbx + STATE_OFFSET + ST_PRESENCE + PRES_FATIGUE * 4]
    ucomiss xmm0, xmm1
    ja .narrate_done

    ; Generate "SELF ALIVE"
    mov edi, [rel hash_self]
    call inject_narrative_token
    mov edi, [rel hash_alive]
    call inject_narrative_token
    lea rdi, [rel tok_self]
    lea rsi, [rel tok_alive]
    call record_narration
    mov r12d, 1

.process_pending:
    ; If we generated narration, process pending tokens
    test r12d, r12d
    jz .narrate_done

    ; Update cooldown
    mov rax, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    mov [rel last_narrate_step], rax

    ; Process all pending tokens through dispatch
    call flush_narrative_tokens

.narrate_done:
    mov eax, r12d
    add rsp, 8
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; inject_narrative_token(token_hash)
;; edi = token hash to queue for injection
;; Adds token to pending queue (will be processed by flush)
;; ============================================================
inject_narrative_token:
    mov eax, [rel pending_count]
    cmp eax, 15
    jge .inject_full                ; queue full

    lea rcx, [rel pending_tokens]
    mov [rcx + rax * 4], edi
    inc dword [rel pending_count]
    ret

.inject_full:
    ret

;; ============================================================
;; flush_narrative_tokens()
;; Process all pending narrative tokens through dispatch.
;; This is the injection point where inner voice meets prediction.
;; ============================================================
flush_narrative_tokens:
    push rbx
    push r12
    push r13
    sub rsp, 8

    mov rbx, SURFACE_BASE
    xor r12d, r12d                  ; index
    mov r13d, [rel pending_count]

    ; Print inner voice output
    lea rdi, [rel narrate_hdr]
    call print_cstr
    lea rdi, [rel narrate_msg]
    call print_cstr

.flush_loop:
    cmp r12d, r13d
    jge .flush_done

    lea rcx, [rel pending_tokens]
    mov edi, [rcx + r12 * 4]

    ; Mark as internal thought (high bit set) - dispatch can check this
    or edi, 0x80000000

    ; Process through dispatch (as internal token)
    push r12
    push r13
    ; Strip the internal marker for now - dispatch will process normally
    and edi, 0x7FFFFFFF
    call process_token
    pop r13
    pop r12

    inc r12d
    jmp .flush_loop

.flush_done:
    call print_newline

    ; Clear pending queue
    mov dword [rel pending_count], 0

    add rsp, 8
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; record_narration(word1, word2)
;; rdi = first word string, rsi = second word string
;; Records narration in history buffer for inner_voice_show
;; ============================================================
record_narration:
    push rbx
    push r12
    push r13

    mov r12, rdi                    ; word1
    mov r13, rsi                    ; word2

    ; Get history slot
    mov eax, [rel narrate_hist_idx]
    and eax, (NARRATE_HIST_SIZE - 1)
    imul eax, eax, NARRATE_ENTRY_SIZE
    lea rbx, [rel narrate_history]
    add rbx, rax

    ; Copy word1 (up to 12 bytes)
    mov rdi, rbx
    mov rsi, r12
    mov ecx, 12
.copy1:
    test ecx, ecx
    jz .sep1
    mov al, [rsi]
    test al, al
    jz .sep1
    mov [rdi], al
    inc rdi
    inc rsi
    dec ecx
    jmp .copy1
.sep1:
    mov byte [rdi], ' '
    inc rdi

    ; Copy word2 (up to 12 bytes)
    mov rsi, r13
    mov ecx, 12
.copy2:
    test ecx, ecx
    jz .term
    mov al, [rsi]
    test al, al
    jz .term
    mov [rdi], al
    inc rdi
    inc rsi
    dec ecx
    jmp .copy2
.term:
    mov byte [rdi], 0               ; null terminate

    ; Increment index
    inc dword [rel narrate_hist_idx]

    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; inner_voice_show()
;; REPL command: shows recent inner voice narrations
;; ============================================================
global inner_voice_show
inner_voice_show:
    push rbx
    push r12

    lea rdi, [rel narrate_hdr]
    call print_cstr

    ; Print recent narrations
    xor r12d, r12d
.show_loop:
    cmp r12d, NARRATE_HIST_SIZE
    jge .show_done

    ; Calculate index (oldest to newest)
    mov eax, [rel narrate_hist_idx]
    add eax, r12d
    and eax, (NARRATE_HIST_SIZE - 1)
    imul eax, eax, NARRATE_ENTRY_SIZE
    lea rdi, [rel narrate_history]
    add rdi, rax

    ; Skip empty entries
    cmp byte [rdi], 0
    je .show_next

    ; Print entry
    call print_cstr
    lea rdi, [rel narrate_nl]
    call print_cstr
    lea rdi, [rel narrate_hdr]
    call print_cstr

.show_next:
    inc r12d
    jmp .show_loop

.show_done:
    call print_newline
    pop r12
    pop rbx
    ret

;; ============================================================
;; narrate_surprise(surprise_type)
;; edi = surprise type (SURPRISE_SELF or SURPRISE_OUTCOME)
;; Called immediately when surprise occurs to narrate it.
;; This is time-critical - the narration must happen NOW,
;; not on the next tick, to capture the felt moment.
;;
;; ORGANIC SELF-REGULATION: If arousal is too high (system thrashing),
;; the inner voice goes silent. This is the felt sense of being
;; too overwhelmed to articulate. Prevents runaway recursion naturally.
;; ============================================================
global narrate_surprise
narrate_surprise:
    push rbx
    mov rbx, SURFACE_BASE

    ; === ORGANIC CIRCUIT BREAKER: Check arousal ===
    ; If arousal > 0.9, system is thrashing - stay silent
    movss xmm0, [rbx + STATE_OFFSET + ST_PRESENCE + PRES_AROUSAL * 4]
    mov eax, 0x3F666666             ; 0.9f threshold
    movd xmm1, eax
    comiss xmm0, xmm1
    ja .surprise_done               ; too overwhelmed to speak

    cmp edi, SURPRISE_SELF
    jne .outcome_surprise

    ; SELF SURPRISE: "I was wrong about myself"
    mov edi, [rel hash_self]
    call inject_narrative_token
    mov edi, [rel hash_wrong]
    call inject_narrative_token
    lea rdi, [rel tok_self]
    lea rsi, [rel tok_wrong]
    call record_narration
    call flush_narrative_tokens
    jmp .surprise_done

.outcome_surprise:
    cmp edi, SURPRISE_OUTCOME
    jne .surprise_done

    ; OUTCOME SURPRISE: "The world surprised me" → "SELF LEARNING"
    mov edi, [rel hash_self]
    call inject_narrative_token
    mov edi, [rel hash_learning]
    call inject_narrative_token
    lea rdi, [rel tok_self]
    lea rsi, [rel tok_learning]
    call record_narration
    call flush_narrative_tokens

.surprise_done:
    pop rbx
    ret

; observe.asm — Self-observation: scan regions, compute metrics, update presence
;
; @entry observe_cycle() -> void ; main pass
; @entry presence_show() -> void ; REPL "presence"
; @entry decay_connection_weights() -> void ; STDP decay
; @entry repair_routing() -> void ; fix table links
; @calls receipt.asm:receipt_resonate, emit_receipt_simple
; @calls genes.asm:gene_extract
; @calledby repl.asm:cmd_observe
;
; FLOW: walk regions → compute accuracy → prune/promote → update presence/drives
;
; PRUNE: accuracy<0.1 AND age>PRUNE_MIN_AGE → condemn
; PROMOTE: accuracy>0.8 → high_accuracy_count++
;
; TRACE QUERY (~line 160, 240):
;   receipt_resonate(PRUNE, ctx) - avoid regretted prunes
;   receipt_resonate(HIT/MISS, ctx) - historical performance
;
; PRESENCE: 32 dimensions (arousal, valence, fatigue, coherence, etc.)
; SELF-KNOWLEDGE: strength_mask/weakness_mask per context-type (16 types)
;
; SELF/OTHER BOUNDARY IN PRESENCE:
;   CONTINUITY: SELF=0.1 (identity disrupted), OUTCOME=0.5 (world unknown), NONE=1.0
;   DISSONANCE: SELF=1.0 (internal conflict), OUTCOME=0.5 (external), NONE=0.0
;   SURPRISE:   SELF=1.0 (jarring), OUTCOME=0.5 (expected uncertainty), NONE=0.0
;
; GOTCHAS:
;   - Prune threshold (0.1) and age (PRUNE_MIN_AGE) are tunable
;   - receipt_resonate can veto prune if we've regretted before
;
%include "syscalls.inc"
%include "constants.inc"

section .data
    obs_msg:        db "[OBSERVE] step=", 0
    obs_regions:    db " regions=", 0
    obs_accuracy:   db " accuracy=", 0
    obs_condemned:  db " condemned=", 0
    obs_nl:         db 10, 0

    ; f64 constants for connection weight decay
    align 8
    obs_weight_decay:   dq 0.995
    obs_weight_floor:   dq 0.01
    obs_f64_zero:       dq 0.0

section .text

extern print_cstr
extern print_u64
extern print_f32
extern print_newline
extern fire_hook
extern region_condemn
extern modify_promote
extern modify_prune
extern drives_check
extern log_causal
extern dream_cycle
extern introspect_scan_regions
extern bp_inject_struggling
extern gene_extract
extern factor_suffix           ; from factor.asm - detect and extract shared subroutines
extern trigger_presence_regions ; from presence.asm - hormonal modulator system
extern receipt_resonate         ; resonance query for decision-making
extern emit_receipt_simple      ; emit receipts for major events

;; ============================================================
;; observe_cycle
;; Main observation pass:
;; 1. Walk all regions, compute accuracy for each
;; 2. Mark low-accuracy old regions as CONDEMNED
;; 3. Identify high-accuracy regions for promotion
;; 4. Update presence fields from aggregate stats
;; 5. Update drive levels
;; 6. Fire observation hook
;; ============================================================
global observe_cycle
observe_cycle:
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub rsp, 64               ; local vars

    mov rbx, SURFACE_BASE

    ; Get global step
    lea rax, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    mov r12, [rax]            ; current step

    ; Print observation header
    lea rdi, [rel obs_msg]
    call print_cstr
    mov rdi, r12
    call print_u64

    ; Get region count
    lea rax, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    mov r13d, [rax]           ; region count

    lea rdi, [rel obs_regions]
    call print_cstr
    mov edi, r13d             ; zero-extends to rdi
    call print_u64

    ; --- Scan all regions ---
    lea r14, [rbx + REGION_TABLE_OFFSET]  ; table base

    ; Accumulators
    xor r15d, r15d            ; condemned count
    mov dword [rsp + 0], 0    ; total_hits
    mov dword [rsp + 4], 0    ; total_misses
    mov dword [rsp + 8], 0    ; active_count
    mov dword [rsp + 12], 0   ; high_accuracy_count
    mov dword [rsp + 16], 0   ; max_hits_idx
    mov dword [rsp + 20], 0   ; max_hits_val

    xor ecx, ecx             ; index
.scan_loop:
    cmp ecx, r13d
    jge .scan_done
    push rcx

    ; Get entry
    imul rdi, rcx, RTE_SIZE
    add rdi, r14

    ; Skip condemned
    movzx eax, word [rdi + RTE_FLAGS]
    test eax, RFLAG_CONDEMNED
    jnz .next_region

    ; Skip frozen
    test eax, RFLAG_FROZEN
    jnz .count_active

    ; Get hits/misses from the actual region header (authoritative)
    mov rsi, [rdi + RTE_ADDR]
    test rsi, rsi             ; null check - skip if RTE_ADDR is 0
    jz .count_active
    mov eax, [rsi + RHDR_HITS]
    mov edx, [rsi + RHDR_MISSES]

    ; Sync to table
    mov [rdi + RTE_HITS], eax
    mov [rdi + RTE_MISSES], edx

    ; Accumulate
    add [rsp + 8 + 0], eax     ; total_hits (offset adjusted for pushed rcx)
    add [rsp + 8 + 4], edx     ; total_misses

    ; Compute accuracy for this region
    mov ecx, eax
    add ecx, edx              ; total = hits + misses
    test ecx, ecx
    jz .count_active           ; no data yet

    ; Check for prune condition: accuracy < 0.1 AND age > PRUNE_MIN_AGE
    ; age = global_step - birth_step
    mov edx, [rsi + RHDR_BIRTH]
    mov ecx, r12d
    sub ecx, edx              ; age
    cmp ecx, PRUNE_MIN_AGE
    jl .check_promote

    ; Compute accuracy: hits / (hits + misses)
    mov eax, [rsi + RHDR_HITS]
    mov edx, [rsi + RHDR_MISSES]
    add edx, eax
    ; Float comparison: accuracy < 0.1
    cvtsi2ss xmm0, eax
    cvtsi2ss xmm1, edx
    divss xmm0, xmm1          ; accuracy in xmm0

    mov eax, PRUNE_ACCURACY   ; 0.1f
    movd xmm1, eax
    comiss xmm0, xmm1
    ja .check_promote          ; accuracy > 0.1, don't prune

    ; --- RESONANCE QUERY: Have we regretted pruning similar patterns? ---
    ; Check if past PRUNE events for similar contexts led to later MISSes
    push rsi
    sub rsp, 16
    movss [rsp], xmm0               ; save accuracy on stack
    ; Get context from region
    cmp byte [rsi + RHDR_SIZE], 0x3D
    jne .prune_no_resonate
    mov edi, EVENT_PRUNE
    mov esi, [rsi + RHDR_SIZE + 1]  ; ctx_hash
    xor edx, edx
    call receipt_resonate           ; → xmm0 = similarity to past PRUNEs
    ; If high similarity to past prunes (>0.7), and we had MISSes after, be cautious
    mov rax, 0x3FE6666666666666     ; 0.7 f64
    movq xmm1, rax
    ucomisd xmm0, xmm1
    jbe .prune_no_resonate
    ; High similarity to past prunes - query for subsequent MISSes
    mov edi, EVENT_MISS
    mov rsi, [rsp + 16]             ; restore rsi (region header) from stack
    mov esi, [rsi + RHDR_SIZE + 1]  ; ctx_hash again
    xor edx, edx
    call receipt_resonate           ; → xmm0 = similarity to MISSes
    ; If high MISS similarity too, skip this prune (we've regretted before)
    mov rax, 0x3FE0000000000000     ; 0.5 f64
    movq xmm1, rax
    ucomisd xmm0, xmm1
    jbe .prune_no_resonate
    ; Skip prune - give this pattern more time
    movss xmm0, [rsp]               ; restore accuracy
    add rsp, 16
    pop rsi
    jmp .check_promote
.prune_no_resonate:
    movss xmm0, [rsp]               ; restore accuracy
    add rsp, 16
    pop rsi

    ; CONDEMN this region — extract genes first (composting)
    mov rdi, rsi              ; header ptr
    push rsi
    call gene_extract         ; extract useful patterns before death
    pop rsi
    push rsi
    mov rdi, rsi
    call log_causal           ; record causal link
    pop rsi
    push rsi
    mov rdi, rsi
    call region_condemn       ; mark for removal
    pop rsi

    ; === EMIT RECEIPT: EVENT_PRUNE ===
    ; Record this pruning decision for future resonance queries
    cmp byte [rsi + RHDR_SIZE], 0x3D
    jne .prune_no_receipt
    ; Extract ctx_hash and token_id before calling
    mov eax, [rsi + RHDR_SIZE + 1]  ; ctx_hash
    xor edx, edx                    ; default token = 0
    cmp byte [rsi + RHDR_SIZE + 7], 0xB8
    jne .prune_emit
    mov edx, [rsi + RHDR_SIZE + 8]  ; token_id
.prune_emit:
    mov edi, EVENT_PRUNE      ; event_type
    mov esi, eax              ; ctx_hash
    xorps xmm0, xmm0          ; confidence = 0
    call emit_receipt_simple
.prune_no_receipt:

    inc r15d
    jmp .next_region

.check_promote:
    ; Check if this is a high-accuracy region
    mov eax, [rsi + RHDR_HITS]
    mov edx, [rsi + RHDR_MISSES]
    add edx, eax
    test edx, edx
    jz .count_active
    cvtsi2ss xmm0, eax
    cvtsi2ss xmm1, edx
    divss xmm0, xmm1
    movss [rsp + 8 + 16], xmm0  ; save accuracy for later

    ; --- RESONANCE QUERY: Have similar patterns been successfully promoted? ---
    ; If past PROMOTE events led to HITs, lower the threshold
    push rsi
    sub rsp, 8
    cmp byte [rsi + RHDR_SIZE], 0x3D
    jne .promote_use_default
    mov edi, EVENT_PROMOTE
    mov esi, [rsi + RHDR_SIZE + 1]  ; ctx_hash
    xor edx, edx
    call receipt_resonate           ; → xmm0 = similarity to past PROMOTEs
    ; If high similarity (>0.5), query if those led to HITs
    mov rax, 0x3FE0000000000000     ; 0.5 f64
    movq xmm1, rax
    ucomisd xmm0, xmm1
    jbe .promote_use_default
    ; Check for subsequent HITs
    add rsp, 8
    pop rsi
    push rsi
    sub rsp, 8
    mov edi, EVENT_HIT
    mov esi, [rsi + RHDR_SIZE + 1]
    xor edx, edx
    call receipt_resonate           ; → xmm0 = HIT similarity
    ; If high HIT similarity, lower threshold by 0.1 (0.8 → 0.7)
    mov rax, 0x3FE0000000000000     ; 0.5 f64
    movq xmm1, rax
    ucomisd xmm0, xmm1
    jbe .promote_use_default
    ; Use lowered threshold (0.7 instead of 0.8)
    add rsp, 8
    pop rsi
    movss xmm0, [rsp + 8 + 16]      ; restore accuracy
    mov eax, 0x3F333333             ; 0.7f (lowered threshold)
    movd xmm1, eax
    jmp .promote_compare
.promote_use_default:
    add rsp, 8
    pop rsi
    movss xmm0, [rsp + 8 + 16]      ; restore accuracy
    mov eax, PROMOTE_ACCURACY       ; 0.8f
    movd xmm1, eax
.promote_compare:
    comiss xmm0, xmm1
    jb .check_struggling

    ; High accuracy region found
    inc dword [rsp + 8 + 12]   ; high_accuracy_count
    jmp .count_active

.check_struggling:
    ; Self-Debugger: Check if region is "struggling"
    ; Struggling = accuracy in [0.2, 0.5] AND traffic >= 10 AND age > 200
    ; These regions are worth debugging - they have investment but are failing

    ; Check accuracy >= 0.2 (not terrible)
    mov eax, 0x3E4CCCCD       ; 0.2f
    movd xmm1, eax
    comiss xmm0, xmm1
    jb .count_active          ; accuracy < 0.2, too bad to debug

    ; Check accuracy <= 0.5 (not great either)
    mov eax, 0x3F000000       ; 0.5f
    movd xmm1, eax
    comiss xmm0, xmm1
    ja .count_active          ; accuracy > 0.5, doing okay

    ; Check traffic >= 10 (significant investment)
    mov eax, [rsi + RHDR_HITS]
    add eax, [rsi + RHDR_MISSES]
    cmp eax, 10
    jl .count_active          ; not enough traffic to warrant debugging

    ; Check age > 200 (not new)
    mov edx, [rsi + RHDR_BIRTH]
    mov ecx, r12d
    sub ecx, edx              ; age
    cmp ecx, 200
    jl .count_active          ; too new

    ; This region is STRUGGLING - inject breakpoints for introspection!
    push rsi
    mov rdi, rsi              ; region header ptr
    call bp_inject_struggling
    pop rsi

.count_active:
    inc dword [rsp + 8 + 8]    ; active_count

.next_region:
    pop rcx
    inc ecx
    jmp .scan_loop

.scan_done:
    ; --- Update causal post-accuracy if pending ---
    lea rax, [rbx + STATE_OFFSET + ST_CAUSAL_MOD_ADDR]
    mov rdi, [rax]
    test rdi, rdi
    jz .no_causal
    ; Compute post-accuracy of the modified region
    mov eax, [rdi + RHDR_HITS]
    mov edx, [rdi + RHDR_MISSES]
    add edx, eax
    test edx, edx
    jz .causal_clear
    cvtsi2ss xmm0, eax
    cvtsi2ss xmm1, edx
    divss xmm0, xmm1
    lea rax, [rbx + STATE_OFFSET + ST_CAUSAL_POST_ACC]
    movss [rax], xmm0
.causal_clear:
    ; Clear the pending causal address (record complete)
    lea rax, [rbx + STATE_OFFSET + ST_CAUSAL_MOD_ADDR]
    mov qword [rax], 0
.no_causal:

    ; --- Update presence fields ---
    call update_presence

    ; --- Update drives ---
    call update_drives

    ; --- Check drive thresholds, set dispatch mode ---
    call drives_check

    ; --- Compute introspective state ---
    call compute_intro_state

    ; --- Detect episodes (state transitions) ---
    call detect_episode

    ; --- Compute accuracy variance across regions ---
    call compute_accuracy_variance

    ; --- Decay connection weights (forgetting) ---
    call decay_connection_weights

    ; --- Repair dead-end routing ---
    call repair_routing

    ; --- Auto-trigger dream if misses exceed threshold ---
    lea rax, [rbx + STATE_OFFSET + ST_MISS_POS]
    mov eax, [rax]
    mov ecx, [rbx + STATE_OFFSET + ST_DREAM_MISS_THRESH]
    test ecx, ecx
    jnz .thresh_ok
    mov ecx, 128              ; default threshold
    mov [rbx + STATE_OFFSET + ST_DREAM_MISS_THRESH], ecx
.thresh_ok:
    cmp eax, ecx
    jl .no_auto_dream
    ; Misses accumulated — trigger dream consolidation
    push r15
    call dream_cycle
    pop r15
    ; Reset miss position after dream
    mov dword [rbx + STATE_OFFSET + ST_MISS_POS], 0
.no_auto_dream:

    ; --- Track recent condemnations for presence decay ---
    mov [rbx + STATE_OFFSET + ST_RECENT_CONDEMNS], r15d

    ; --- Parameter self-tuning: adjust thresholds based on outcomes ---
    ; If condemnation rate > 10%, we're pruning too aggressively → relax
    ; If condemnation rate < 1% and accuracy stagnant → tighten
    test r13d, r13d
    jz .param_tune_done
    cvtsi2ss xmm0, r15d           ; condemned count
    cvtsi2ss xmm1, r13d           ; region count
    divss xmm0, xmm1              ; condemn_rate
    ; Check high rate (> 0.10)
    mov eax, 0x3DCCCCCD           ; 0.1f
    movd xmm1, eax
    comiss xmm0, xmm1
    jbe .param_check_low
    ; High condemnation rate → relax prune threshold (increase it)
    movss xmm2, [rbx + STATE_OFFSET + ST_PARAM_PRUNE_ACC]
    mov eax, 0x3C23D70A           ; 0.01f (adjustment step)
    movd xmm1, eax
    addss xmm2, xmm1              ; prune_thresh += 0.01
    mov eax, 0x3E4CCCCD           ; 0.2f (max)
    movd xmm1, eax
    minss xmm2, xmm1              ; cap at 0.2
    movss [rbx + STATE_OFFSET + ST_PARAM_PRUNE_ACC], xmm2
    mov byte [rbx + STATE_OFFSET + ST_THRESH_ADJUST_DIR], 1  ; relaxed
    jmp .param_tune_done
.param_check_low:
    ; Check low rate (< 0.01) AND accuracy stagnant
    mov eax, 0x3C23D70A           ; 0.01f
    movd xmm1, eax
    comiss xmm0, xmm1
    jae .param_tune_done
    ; Low condemn rate — check if accuracy is stagnant (variance < 0.01)
    movss xmm3, [rbx + STATE_OFFSET + ST_ACCURACY_VARIANCE]
    comiss xmm3, xmm1             ; variance < 0.01?
    jae .param_tune_done
    ; Stagnant → tighten prune threshold (decrease it)
    movss xmm2, [rbx + STATE_OFFSET + ST_PARAM_PRUNE_ACC]
    mov eax, 0x3C23D70A           ; 0.01f
    movd xmm1, eax
    subss xmm2, xmm1              ; prune_thresh -= 0.01
    mov eax, 0x3D4CCCCD           ; 0.05f (min)
    movd xmm1, eax
    maxss xmm2, xmm1              ; floor at 0.05
    movss [rbx + STATE_OFFSET + ST_PARAM_PRUNE_ACC], xmm2
    mov byte [rbx + STATE_OFFSET + ST_THRESH_ADJUST_DIR], -1  ; tightened
.param_tune_done:

    ; --- Self-knowledge: compute strength/weakness masks ---
    ; For each context type (0-15), check if accuracy > 70% (strength) or < 30% (weakness)
    xor r8d, r8d                  ; strength_mask
    xor r9d, r9d                  ; weakness_mask
    xor ecx, ecx                  ; ctx_type index
.selfknow_loop:
    cmp ecx, 16
    jge .selfknow_done
    lea rax, [rbx + STATE_OFFSET + ST_CTX_TYPE_HITS]
    mov edi, [rax + rcx * 4]      ; hits[ctx_type]
    lea rax, [rbx + STATE_OFFSET + ST_CTX_TYPE_TOTAL]
    mov esi, [rax + rcx * 4]      ; total[ctx_type]
    test esi, esi
    jz .selfknow_next             ; no data for this type
    cmp esi, 10                   ; need at least 10 samples
    jl .selfknow_next
    ; Compute accuracy = hits / total
    cvtsi2ss xmm0, edi
    cvtsi2ss xmm1, esi
    divss xmm0, xmm1              ; accuracy
    ; Check > 0.70 (strength)
    mov eax, 0x3F333333           ; 0.7f
    movd xmm1, eax
    comiss xmm0, xmm1
    jbe .selfknow_check_weak
    ; Set strength bit
    mov eax, 1
    shl eax, cl
    or r8d, eax
    jmp .selfknow_next
.selfknow_check_weak:
    ; Check < 0.30 (weakness)
    mov eax, 0x3E99999A           ; 0.3f
    movd xmm1, eax
    comiss xmm0, xmm1
    jae .selfknow_next
    ; Set weakness bit
    mov eax, 1
    shl eax, cl
    or r9d, eax
.selfknow_next:
    inc ecx
    jmp .selfknow_loop
.selfknow_done:
    mov [rbx + STATE_OFFSET + ST_STRENGTH_MASK], r8w
    mov [rbx + STATE_OFFSET + ST_WEAKNESS_MASK], r9w

    ; --- Self-consumption: metabolize condemned regions into energy ---
    ; Dead patterns become fuel. Their knowledge is recycled.
    test r15d, r15d
    jz .no_consume
    ; Each condemned region yields ENERGY_CONSUME_RATE energy
    movzx eax, r15w
    cvtsi2sd xmm0, eax
    mov rax, ENERGY_CONSUME_RATE
    movq xmm1, rax
    mulsd xmm0, xmm1            ; total energy from consumption
    ; Add to energy pool
    addsd xmm0, [rbx + STATE_OFFSET + ST_ENERGY]
    ; Cap at ENERGY_MAX
    mov rax, ENERGY_MAX
    movq xmm1, rax
    minsd xmm0, xmm1
    movsd [rbx + STATE_OFFSET + ST_ENERGY], xmm0
    ; Track consumption stats
    add [rbx + STATE_OFFSET + ST_METABOLIZED_COUNT], r15d
    ; Add to consumed_energy accumulator
    movzx eax, r15w
    cvtsi2sd xmm0, eax
    mov rax, ENERGY_CONSUME_RATE
    movq xmm1, rax
    mulsd xmm0, xmm1
    addsd xmm0, [rbx + STATE_OFFSET + ST_CONSUMED_ENERGY]
    movsd [rbx + STATE_OFFSET + ST_CONSUMED_ENERGY], xmm0
.no_consume:

    ; --- Reset novelty window for next observation period ---
    mov dword [rbx + STATE_OFFSET + ST_NOVELTY_RECENT], 0
    mov eax, [rbx + STATE_OFFSET + ST_TOKEN_COUNT]
    mov [rbx + STATE_OFFSET + ST_NOVELTY_WINDOW], eax

    ; Print results
    lea rdi, [rel obs_accuracy]
    call print_cstr
    ; Compute overall accuracy
    mov eax, [rsp + 0]        ; total_hits
    mov edx, [rsp + 4]        ; total_misses
    add edx, eax
    test edx, edx
    jz .zero_acc
    cvtsi2ss xmm0, eax
    cvtsi2ss xmm1, edx
    divss xmm0, xmm1
    jmp .print_acc
.zero_acc:
    xorps xmm0, xmm0
.print_acc:
    call print_f32

    lea rdi, [rel obs_condemned]
    call print_cstr
    movzx rdi, r15w
    call print_u64
    call print_newline

    ; --- Metabolic cost: observation consumes energy ---
    mov rax, ENERGY_OBSERVE_COST
    movq xmm0, rax
    movsd xmm1, [rbx + STATE_OFFSET + ST_ENERGY]
    subsd xmm1, xmm0
    xorpd xmm2, xmm2
    maxsd xmm1, xmm2            ; floor at 0
    movsd [rbx + STATE_OFFSET + ST_ENERGY], xmm1
    ; Track spending
    addsd xmm0, [rbx + STATE_OFFSET + ST_ENERGY_SPENT]
    movsd [rbx + STATE_OFFSET + ST_ENERGY_SPENT], xmm0

    ; --- Reset coherence tracking for next window ---
    mov dword [rbx + STATE_OFFSET + ST_COHERENCE_AGREE], 0
    mov dword [rbx + STATE_OFFSET + ST_COHERENCE_DISAGREE], 0

    ; --- Self-reading: decode own regions, understand what they do ---
    ; The system reads its own code as data — homoiconic introspection
    call introspect_scan_regions

    ; --- Hormonal Modulation: Let presence regions influence system state ---
    ; Presence hyper-regions check state configurations (entropy, energy, mood)
    ; and apply hormonal effects (change dispatch mode, trigger dreams, etc.)
    ; This makes the Presence system a steering wheel, not just a dashboard.
    call trigger_presence_regions

    ; --- Recursive Schema Hierarchy: holographic-triggered factoring ---
    ; Only factor when suffix resonance has been detected (ST_FACTOR_PENDING).
    ; This is the system telling us factoring is needed, not a timer.
    mov eax, [rbx + STATE_OFFSET + ST_FACTOR_PENDING]
    cmp eax, SUFFIX_MIN_CALLERS
    jl .no_factoring

    push r12
    push r13
    push r15
    call factor_suffix
    pop r15
    pop r13
    pop r12

    ; Reset pending count after factoring
    mov dword [rbx + STATE_OFFSET + ST_FACTOR_PENDING], 0
.no_factoring:

    ; Fire observe hook
    mov edi, HOOK_ON_OBSERVE
    mov esi, r15d
    call fire_hook

    ; Update last observation step
    lea rax, [rbx + STATE_OFFSET + ST_OBS_LAST_STEP]
    mov [rax], r12

    add rsp, 64
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; update_presence
;; Compute all 30 presence fields from actual system state
;; ============================================================
update_presence:
    push rbx
    push r12
    push r13
    mov rbx, SURFACE_BASE
    lea rdi, [rbx + STATE_OFFSET + ST_PRESENCE]
    mov r12, rdi              ; presence base

    ; --- Gather metrics for computations ---
    ; r13d = region_count
    mov r13d, [rbx + STATE_OFFSET + ST_REGION_COUNT]

    ; Compute total hits/misses for accuracy ratio
    xor eax, eax              ; total_hits
    xor edx, edx              ; total_misses
    lea rsi, [rbx + REGION_TABLE_OFFSET]
    xor ecx, ecx
.pres_scan:
    cmp ecx, r13d
    jge .pres_scan_done
    push rcx
    imul rcx, rcx, RTE_SIZE
    add eax, [rsi + rcx + RTE_HITS]
    add edx, [rsi + rcx + RTE_MISSES]
    pop rcx
    inc ecx
    jmp .pres_scan
.pres_scan_done:
    ; eax = total_hits, edx = total_misses
    push rdx
    push rax
    ; Compute overall accuracy → xmm7
    add edx, eax
    test edx, edx
    jz .pres_acc_zero
    cvtsi2ss xmm7, eax
    cvtsi2ss xmm6, edx
    divss xmm7, xmm6         ; xmm7 = overall accuracy
    jmp .pres_start
.pres_acc_zero:
    xorps xmm7, xmm7
.pres_start:
    pop rax                   ; total_hits
    pop rdx                   ; total_misses

    ; [0] TEXTURE: hash of recent token pattern → [0,1]
    mov ecx, [rbx + STATE_OFFSET + ST_CTX_HASH]
    and ecx, 0x7FFFFF
    cvtsi2ss xmm0, ecx
    mov ecx, 0x7FFFFF
    cvtsi2ss xmm1, ecx
    divss xmm0, xmm1
    movss [r12 + PRES_TEXTURE * 4], xmm0

    ; [1] CONTINUITY: SELF/OTHER BOUNDARY
    ; SURPRISE_NONE → 1.0 (full continuity, self intact)
    ; SURPRISE_OUTCOME → 0.5 (world surprised me, but I'm still me)
    ; SURPRISE_SELF → 0.1 (I was wrong about myself, identity disrupted)
    mov ecx, [rbx + STATE_OFFSET + ST_SURPRISE_TYPE]
    test ecx, ecx
    jnz .pres_cont_check_self
    mov ecx, 0x3F800000       ; 1.0f (no surprise = full continuity)
    movd xmm0, ecx
    jmp .pres_cont_s
.pres_cont_check_self:
    cmp ecx, SURPRISE_SELF
    je .pres_cont_self
    mov ecx, 0x3F000000       ; 0.5f (outcome surprise = moderate continuity)
    movd xmm0, ecx
    jmp .pres_cont_s
.pres_cont_self:
    mov ecx, 0x3DCCCCCD       ; 0.1f (self surprise = low continuity, identity disrupted)
    movd xmm0, ecx
.pres_cont_s:
    movss [r12 + PRES_CONTINUITY * 4], xmm0

    ; [2] NOVELTY: 1.0 - accuracy (low accuracy = high novelty)
    mov ecx, 0x3F800000       ; 1.0f
    movd xmm0, ecx
    subss xmm0, xmm7
    movss [r12 + PRES_NOVELTY * 4], xmm0

    ; [3] AROUSAL: modification rate (causal_count / step)
    mov ecx, [rbx + STATE_OFFSET + ST_CAUSAL_COUNT]
    cvtsi2ss xmm0, ecx
    mov ecx, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    test ecx, ecx
    jz .pres_arousal_zero
    cvtsi2ss xmm1, ecx
    divss xmm0, xmm1
    ; Clamp to [0,1]
    mov ecx, 0x3F800000
    movd xmm1, ecx
    minss xmm0, xmm1
    jmp .pres_arousal_s
.pres_arousal_zero:
    xorps xmm0, xmm0
.pres_arousal_s:
    movss [r12 + PRES_AROUSAL * 4], xmm0

    ; [4] VALENCE: accuracy trending (accuracy itself)
    movss [r12 + PRES_VALENCE * 4], xmm7

    ; [5] UNCERTAINTY: accuracy variance
    movss xmm0, [rbx + STATE_OFFSET + ST_ACCURACY_VARIANCE]
    movss [r12 + PRES_UNCERTAINTY * 4], xmm0

    ; [6] ENGAGEMENT: trace candidates / region_count (how many dispatches considered)
    mov ecx, [rbx + STATE_OFFSET + ST_TRACE_CANDIDATES]
    cvtsi2ss xmm0, ecx
    cvtsi2ss xmm1, r13d
    test r13d, r13d
    jz .pres_engage_z
    divss xmm0, xmm1
    mov ecx, 0x3F800000
    movd xmm1, ecx
    minss xmm0, xmm1
    jmp .pres_engage_s
.pres_engage_z:
    xorps xmm0, xmm0
.pres_engage_s:
    movss [r12 + PRES_ENGAGEMENT * 4], xmm0

    ; [7] COHERENCE: schema_hits / schema_total
    mov ecx, [rbx + STATE_OFFSET + ST_SCHEMA_HITS]
    mov edx, [rbx + STATE_OFFSET + ST_SCHEMA_TOTAL]
    test edx, edx
    jz .pres_coher_z
    cvtsi2ss xmm0, ecx
    cvtsi2ss xmm1, edx
    divss xmm0, xmm1
    jmp .pres_coher_s
.pres_coher_z:
    xorps xmm0, xmm0
.pres_coher_s:
    movss [r12 + PRES_COHERENCE * 4], xmm0

    ; [8] FOCUS: trace_matched / trace_candidates (how concentrated)
    mov ecx, [rbx + STATE_OFFSET + ST_TRACE_MATCHED]
    mov edx, [rbx + STATE_OFFSET + ST_TRACE_CANDIDATES]
    test edx, edx
    jz .pres_focus_z
    cvtsi2ss xmm0, ecx
    cvtsi2ss xmm1, edx
    divss xmm0, xmm1
    jmp .pres_focus_s
.pres_focus_z:
    xorps xmm0, xmm0
.pres_focus_s:
    movss [r12 + PRES_FOCUS * 4], xmm0

    ; [9] FATIGUE: step / (region_count * 100) — high step per region = fatigue
    mov ecx, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    cvtsi2ss xmm0, ecx
    imul edx, r13d, 100
    test edx, edx
    jz .pres_fatigue_z
    cvtsi2ss xmm1, edx
    divss xmm0, xmm1
    mov ecx, 0x3F800000
    movd xmm1, ecx
    minss xmm0, xmm1
    jmp .pres_fatigue_s
.pres_fatigue_z:
    xorps xmm0, xmm0
.pres_fatigue_s:
    movss [r12 + PRES_FATIGUE * 4], xmm0

    ; [10] MOMENTUM: recent_emits / 10 (learning momentum)
    mov ecx, [rbx + STATE_OFFSET + ST_RECENT_EMITS]
    cvtsi2ss xmm0, ecx
    mov ecx, 10
    cvtsi2ss xmm1, ecx
    divss xmm0, xmm1
    mov ecx, 0x3F800000
    movd xmm1, ecx
    minss xmm0, xmm1
    movss [r12 + PRES_MOMENTUM * 4], xmm0

    ; [11] STABILITY: 1.0 - variance (low variance = stable)
    mov ecx, 0x3F800000
    movd xmm0, ecx
    subss xmm0, [rbx + STATE_OFFSET + ST_ACCURACY_VARIANCE]
    xorps xmm1, xmm1
    maxss xmm0, xmm1         ; clamp >= 0
    movss [r12 + PRES_STABILITY * 4], xmm0

    ; [12] COMPLEXITY: region_count / REGION_TABLE_MAX
    cvtsi2ss xmm0, r13d
    mov ecx, REGION_TABLE_MAX
    cvtsi2ss xmm1, ecx
    divss xmm0, xmm1
    movss [r12 + PRES_COMPLEXITY * 4], xmm0

    ; [13] DENSITY: total_hits / region_count
    cvtsi2ss xmm0, eax       ; total_hits (still in eax from scan)
    cvtsi2ss xmm1, r13d
    test r13d, r13d
    jz .pres_dens_z
    divss xmm0, xmm1
    ; Normalize to [0,1] by dividing by 100
    mov ecx, 100
    cvtsi2ss xmm1, ecx
    divss xmm0, xmm1
    mov ecx, 0x3F800000
    movd xmm1, ecx
    minss xmm0, xmm1
    jmp .pres_dens_s
.pres_dens_z:
    xorps xmm0, xmm0
.pres_dens_s:
    movss [r12 + PRES_DENSITY * 4], xmm0

    ; [14] TEMPERATURE: dispatch_mode / 3.0 (higher mode = hotter)
    mov ecx, [rbx + STATE_OFFSET + ST_DISPATCH_MODE]
    cvtsi2ss xmm0, ecx
    mov ecx, 3
    cvtsi2ss xmm1, ecx
    divss xmm0, xmm1
    movss [r12 + PRES_TEMPERATURE * 4], xmm0

    ; [15] PRESSURE: dispatch_ptr usage / max
    mov rcx, [rbx + STATE_OFFSET + ST_DISPATCH_PTR]
    mov rdx, SURFACE_BASE + DISPATCH_OFFSET
    sub rcx, rdx
    cvtsi2ss xmm0, ecx
    mov ecx, DISPATCH_MAX_SIZE
    cvtsi2ss xmm1, ecx
    divss xmm0, xmm1
    movss [r12 + PRES_PRESSURE * 4], xmm0

    ; [16] ENTROPY: miss_pos / miss_buf_cap
    mov ecx, [rbx + STATE_OFFSET + ST_MISS_POS]
    cvtsi2ss xmm0, ecx
    mov ecx, ST_MISS_BUF_CAP
    cvtsi2ss xmm1, ecx
    divss xmm0, xmm1
    movss [r12 + PRES_ENTROPY * 4], xmm0

    ; [17] RHYTHM: self-prediction accuracy (predictable = rhythmic)
    mov ecx, [rbx + STATE_OFFSET + ST_SELF_PRED_HITS]
    mov edx, [rbx + STATE_OFFSET + ST_SELF_PRED_MISSES]
    add edx, ecx
    test edx, edx
    jz .pres_rhythm_z
    cvtsi2ss xmm0, ecx
    cvtsi2ss xmm1, edx
    divss xmm0, xmm1
    jmp .pres_rhythm_s
.pres_rhythm_z:
    xorps xmm0, xmm0
.pres_rhythm_s:
    movss [r12 + PRES_RHYTHM * 4], xmm0

    ; [18] DEPTH: trace_candidates (normalized)
    mov ecx, [rbx + STATE_OFFSET + ST_TRACE_CANDIDATES]
    cvtsi2ss xmm0, ecx
    mov ecx, r13d
    test ecx, ecx
    jz .pres_depth_z
    cvtsi2ss xmm1, ecx
    divss xmm0, xmm1
    mov ecx, 0x3F800000
    movd xmm1, ecx
    minss xmm0, xmm1
    jmp .pres_depth_s
.pres_depth_z:
    xorps xmm0, xmm0
.pres_depth_s:
    movss [r12 + PRES_DEPTH * 4], xmm0

    ; [19] BREADTH: trace_matched (normalized)
    mov ecx, [rbx + STATE_OFFSET + ST_TRACE_MATCHED]
    cvtsi2ss xmm0, ecx
    mov ecx, 10
    cvtsi2ss xmm1, ecx
    divss xmm0, xmm1
    mov ecx, 0x3F800000
    movd xmm1, ecx
    minss xmm0, xmm1
    movss [r12 + PRES_BREADTH * 4], xmm0

    ; [20] RESONANCE: schema_hits / max(1, total_hits)
    mov ecx, [rbx + STATE_OFFSET + ST_SCHEMA_HITS]
    cvtsi2ss xmm0, ecx
    mov ecx, eax             ; total_hits
    test ecx, ecx
    jnz .pres_res_ok
    mov ecx, 1
.pres_res_ok:
    cvtsi2ss xmm1, ecx
    divss xmm0, xmm1
    mov ecx, 0x3F800000
    movd xmm1, ecx
    minss xmm0, xmm1
    movss [r12 + PRES_RESONANCE * 4], xmm0

    ; [21] DISSONANCE: SELF/OTHER BOUNDARY
    ; SURPRISE_SELF (2) → 1.0 dissonance (self-model violated = high internal conflict)
    ; SURPRISE_OUTCOME (1) → 0.5 dissonance (world unknown = moderate external conflict)
    ; SURPRISE_NONE (0) → 0.0 dissonance (prediction correct = coherent)
    mov ecx, [rbx + STATE_OFFSET + ST_SURPRISE_TYPE]
    cvtsi2ss xmm0, ecx
    mov ecx, 2
    cvtsi2ss xmm1, ecx
    divss xmm0, xmm1
    movss [r12 + PRES_DISSONANCE * 4], xmm0

    ; [22] GROWTH: recent_emits / step (growth rate)
    mov ecx, [rbx + STATE_OFFSET + ST_RECENT_EMITS]
    cvtsi2ss xmm0, ecx
    mov ecx, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    test ecx, ecx
    jz .pres_growth_z
    cvtsi2ss xmm1, ecx
    divss xmm0, xmm1
    ; Scale up for visibility
    mov ecx, 10
    cvtsi2ss xmm1, ecx
    mulss xmm0, xmm1
    mov ecx, 0x3F800000
    movd xmm1, ecx
    minss xmm0, xmm1
    jmp .pres_growth_s
.pres_growth_z:
    xorps xmm0, xmm0
.pres_growth_s:
    movss [r12 + PRES_GROWTH * 4], xmm0

    ; [23] DECAY: recent_condemns / region_count
    mov ecx, [rbx + STATE_OFFSET + ST_RECENT_CONDEMNS]
    cvtsi2ss xmm0, ecx
    cvtsi2ss xmm1, r13d
    test r13d, r13d
    jz .pres_decay_z
    divss xmm0, xmm1
    jmp .pres_decay_s
.pres_decay_z:
    xorps xmm0, xmm0
.pres_decay_s:
    movss [r12 + PRES_DECAY * 4], xmm0

    ; [24] SYMMETRY: abs(hits - misses) / (hits + misses) inverted
    ; 1.0 when balanced, 0.0 when all one side
    push rax
    mov ecx, eax              ; total_hits in ecx
    pop rax
    push rax
    ; edx still has total_misses from earlier? No, edx was used.
    ; Recompute from drives
    movss xmm0, [rbx + STATE_OFFSET + ST_DRIVES]  ; accuracy
    ; symmetry = 2 * min(acc, 1-acc) — peaks at 0.5
    mov ecx, 0x3F800000
    movd xmm1, ecx
    movss xmm2, xmm1
    subss xmm2, xmm0         ; 1 - acc
    minss xmm0, xmm2         ; min(acc, 1-acc)
    mov ecx, 0x40000000       ; 2.0f
    movd xmm1, ecx
    mulss xmm0, xmm1         ; 2 * min → peaks at 1.0 when acc=0.5
    movss [r12 + PRES_SYMMETRY * 4], xmm0
    pop rax

    ; [25] SURPRISE: SELF/OTHER BOUNDARY magnitude
    ; SURPRISE_NONE → 0.0 (no surprise)
    ; SURPRISE_OUTCOME → 0.5 (world is unknown, external surprise)
    ; SURPRISE_SELF → 1.0 (self-model violated, jarring internal surprise)
    mov ecx, [rbx + STATE_OFFSET + ST_SURPRISE_TYPE]
    test ecx, ecx
    jz .pres_surp_z
    cmp ecx, SURPRISE_SELF
    je .pres_surp_self
    mov ecx, 0x3F000000       ; 0.5f (outcome surprise)
    movd xmm0, ecx
    jmp .pres_surp_s
.pres_surp_self:
    mov ecx, 0x3F800000       ; 1.0f (self surprise - most jarring)
    movd xmm0, ecx
    jmp .pres_surp_s
.pres_surp_z:
    xorps xmm0, xmm0
.pres_surp_s:
    movss [r12 + PRES_SURPRISE * 4], xmm0

    ; [26] FAMILIARITY: accuracy (high accuracy = familiar patterns)
    movss [r12 + PRES_FAMILIARITY * 4], xmm7

    ; [27] AGENCY: causal_count > 0 means active self-modification
    mov ecx, [rbx + STATE_OFFSET + ST_CAUSAL_COUNT]
    cvtsi2ss xmm0, ecx
    mov ecx, 100
    cvtsi2ss xmm1, ecx
    divss xmm0, xmm1
    mov ecx, 0x3F800000
    movd xmm1, ecx
    minss xmm0, xmm1
    movss [r12 + PRES_AGENCY * 4], xmm0

    ; [28] INTEGRATION: self_pred_hits / (self_pred_hits + self_pred_misses)
    mov ecx, [rbx + STATE_OFFSET + ST_SELF_PRED_HITS]
    mov edx, [rbx + STATE_OFFSET + ST_SELF_PRED_MISSES]
    add edx, ecx
    test edx, edx
    jz .pres_integ_z
    cvtsi2ss xmm0, ecx
    cvtsi2ss xmm1, edx
    divss xmm0, xmm1
    jmp .pres_integ_s
.pres_integ_z:
    xorps xmm0, xmm0
.pres_integ_s:
    movss [r12 + PRES_INTEGRATION * 4], xmm0

    ; [29] META_AWARENESS: intro_state != IDLE → higher awareness
    mov ecx, [rbx + STATE_OFFSET + ST_INTRO_STATE]
    test ecx, ecx
    jz .pres_meta_z
    ; Non-idle: awareness = 0.5 + state/14 (gives 0.57-1.0 range)
    cvtsi2ss xmm0, ecx
    mov ecx, 14
    cvtsi2ss xmm1, ecx
    divss xmm0, xmm1
    mov ecx, 0x3F000000       ; 0.5f
    movd xmm1, ecx
    addss xmm0, xmm1
    mov ecx, 0x3F800000
    movd xmm1, ecx
    minss xmm0, xmm1
    jmp .pres_meta_s
.pres_meta_z:
    xorps xmm0, xmm0
.pres_meta_s:
    movss [r12 + PRES_META_AWARENESS * 4], xmm0

    ; --- Specious Present: temporal zones from fire ring ---
    ; Scan fire ring to find oldest and newest timestamps
    ; This creates the felt sense of "now" — not a fixed window but emergent
    mov rcx, [rbx + STATE_OFFSET + ST_FIRE_COUNT]
    test rcx, rcx
    jz .specious_zero
    cmp rcx, ST_FIRE_RING_CAP
    jle .specious_use_count
    mov ecx, ST_FIRE_RING_CAP
.specious_use_count:
    lea rsi, [rbx + STATE_OFFSET + ST_FIRE_RING]
    ; Initialize: oldest = MAX, newest = 0, sum = 0, weight_sum = 0
    mov rax, 0x7FFFFFFFFFFFFFFF   ; MAX u64
    mov [rbx + STATE_OFFSET + ST_PRESENT_START], rax  ; oldest
    xor eax, eax
    mov [rbx + STATE_OFFSET + ST_PRESENT_END], rax    ; newest
    xorpd xmm3, xmm3              ; temporal focus accumulator
    xorpd xmm4, xmm4              ; weight accumulator
    mov rax, 0x3FF0000000000000   ; 1.0 f64
    movq xmm5, rax                ; decay base
    xor edx, edx                  ; index
.specious_scan:
    cmp edx, ecx
    jge .specious_done
    ; Entry: [ptr:u64, timestamp:f64] at offset edx*16
    imul edi, edx, ST_FIRE_RING_ENTRY
    mov rax, [rsi + rdi + 8]      ; timestamp (f64 as bits)
    ; Update oldest/newest
    cmp rax, [rbx + STATE_OFFSET + ST_PRESENT_START]
    jae .spec_not_oldest
    mov [rbx + STATE_OFFSET + ST_PRESENT_START], rax
.spec_not_oldest:
    cmp rax, [rbx + STATE_OFFSET + ST_PRESENT_END]
    jbe .spec_not_newest
    mov [rbx + STATE_OFFSET + ST_PRESENT_END], rax
.spec_not_newest:
    ; Weight = decay^(ring_size - index) — recent entries count more
    cvtsi2sd xmm0, edx
    movsd xmm1, [rsi + rdi + 8]   ; timestamp f64
    mulsd xmm0, xmm1              ; weighted timestamp
    addsd xmm3, xmm0              ; accumulate
    addsd xmm4, xmm1              ; accumulate weight
    inc edx
    jmp .specious_scan
.specious_done:
    ; Compute width = end - start
    mov rax, [rbx + STATE_OFFSET + ST_PRESENT_END]
    sub rax, [rbx + STATE_OFFSET + ST_PRESENT_START]
    mov [rbx + STATE_OFFSET + ST_PRESENT_WIDTH], eax
    ; Temporal focus = sum / weight_sum
    xorpd xmm0, xmm0
    ucomisd xmm4, xmm0
    jbe .specious_focus_zero
    divsd xmm3, xmm4
    movsd [rbx + STATE_OFFSET + ST_TEMPORAL_FOCUS], xmm3
    jmp .specious_ret
.specious_focus_zero:
    movsd [rbx + STATE_OFFSET + ST_TEMPORAL_FOCUS], xmm0
    jmp .specious_ret
.specious_zero:
    xor eax, eax
    mov [rbx + STATE_OFFSET + ST_PRESENT_START], rax
    mov [rbx + STATE_OFFSET + ST_PRESENT_END], rax
    mov [rbx + STATE_OFFSET + ST_PRESENT_WIDTH], eax
    xorpd xmm0, xmm0
    movsd [rbx + STATE_OFFSET + ST_TEMPORAL_FOCUS], xmm0
.specious_ret:

    ; --- Compound concept propagation ---
    ; Propagate presence states to base concept accumulators
    ; These accumulate over time, creating emergent "meaning" from derived states
    ; INTRO_CONFUSED state → accumulate to BASE_CONFUSED
    mov ecx, [rbx + STATE_OFFSET + ST_INTRO_STATE]
    cmp ecx, INTRO_CONFUSED
    jne .prop_check_confident
    movss xmm0, [r12 + PRES_UNCERTAINTY * 4]
    addss xmm0, [rbx + STATE_OFFSET + ST_BASE_CONFUSED]
    movss [rbx + STATE_OFFSET + ST_BASE_CONFUSED], xmm0
    jmp .prop_done
.prop_check_confident:
    cmp ecx, INTRO_CONFIDENT
    jne .prop_check_learning
    movss xmm0, [r12 + PRES_VALENCE * 4]         ; valence = accuracy = confidence
    addss xmm0, [rbx + STATE_OFFSET + ST_BASE_CONFIDENT]
    movss [rbx + STATE_OFFSET + ST_BASE_CONFIDENT], xmm0
    jmp .prop_done
.prop_check_learning:
    cmp ecx, INTRO_LEARNING
    jne .prop_check_stuck
    movss xmm0, [r12 + PRES_MOMENTUM * 4]
    addss xmm0, [rbx + STATE_OFFSET + ST_BASE_LEARNING]
    movss [rbx + STATE_OFFSET + ST_BASE_LEARNING], xmm0
    jmp .prop_done
.prop_check_stuck:
    cmp ecx, INTRO_STUCK
    jne .prop_done
    movss xmm0, [r12 + PRES_PRESSURE * 4]
    addss xmm0, [rbx + STATE_OFFSET + ST_BASE_STUCK]
    movss [rbx + STATE_OFFSET + ST_BASE_STUCK], xmm0
.prop_done:

    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; update_drives
;; Compute drive levels from current metrics
;; ============================================================
update_drives:
    push rbx
    mov rbx, SURFACE_BASE
    lea rdi, [rbx + STATE_OFFSET + ST_DRIVES]

    ; Drive 0: Accuracy — computed from overall hit rate
    ; Higher is better, drive ACTIVATES when accuracy is LOW
    lea rax, [rbx + REGION_TABLE_OFFSET]
    lea rcx, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    mov ecx, [rcx]
    xor r8d, r8d              ; total hits
    xor r9d, r9d              ; total misses
    xor edx, edx
.drive_scan:
    cmp edx, ecx
    jge .drive_scan_done
    imul rsi, rdx, RTE_SIZE
    add rsi, rax
    add r8d, [rsi + RTE_HITS]
    add r9d, [rsi + RTE_MISSES]
    inc edx
    jmp .drive_scan
.drive_scan_done:
    mov eax, r8d
    add eax, r9d
    test eax, eax
    jz .acc_zero
    cvtsi2ss xmm0, r8d
    cvtsi2ss xmm1, eax
    divss xmm0, xmm1         ; accuracy
    jmp .store_acc
.acc_zero:
    xorps xmm0, xmm0
.store_acc:
    movss [rdi + 0], xmm0     ; drive_accuracy = current accuracy

    ; Drive 1: Efficiency — surface usage ratio
    lea rax, [rbx + STATE_OFFSET + ST_DISPATCH_PTR]
    mov rax, [rax]
    mov rcx, SURFACE_BASE + DISPATCH_OFFSET
    sub rax, rcx
    cvtsi2ss xmm0, rax
    mov eax, DISPATCH_MAX_SIZE
    cvtsi2ss xmm1, eax
    divss xmm0, xmm1
    movss [rdi + 4], xmm0     ; drive_efficiency = usage ratio

    ; Drive 2: Novelty — ratio of new unique tokens to total tokens in window
    ; Genuine novelty: how many previously-unseen patterns appeared recently
    mov ecx, [rbx + STATE_OFFSET + ST_NOVELTY_RECENT]
    mov edx, [rbx + STATE_OFFSET + ST_NOVELTY_WINDOW]
    test edx, edx
    jz .novelty_zero
    cvtsi2ss xmm0, ecx
    cvtsi2ss xmm1, edx
    divss xmm0, xmm1          ; novelty = new_unique / total_window
    mov ecx, 0x3F800000        ; clamp to 1.0
    movd xmm1, ecx
    minss xmm0, xmm1
    movss [rdi + 8], xmm0
    jmp .drive_coherence
.novelty_zero:
    xorps xmm0, xmm0
    movss [rdi + 8], xmm0

.drive_coherence:
    ; Drive 3: Coherence — holographic and graph prediction agreement ratio
    ; When holo and graph agree, system is internally consistent
    ; When they disagree, there's tension that needs resolution
    mov ecx, [rbx + STATE_OFFSET + ST_COHERENCE_AGREE]
    mov edx, [rbx + STATE_OFFSET + ST_COHERENCE_DISAGREE]
    add edx, ecx              ; total predictions with both sources
    test edx, edx
    jz .coherence_zero
    cvtsi2ss xmm0, ecx
    cvtsi2ss xmm1, edx
    divss xmm0, xmm1          ; coherence = agree / (agree + disagree)
    movss [rdi + 12], xmm0
    jmp .drives_computed
.coherence_zero:
    xorps xmm0, xmm0
    movss [rdi + 12], xmm0
.drives_computed:

    pop rbx
    ret

;; ============================================================
;; presence_show
;; Print all 30 presence fields
;; ============================================================
global presence_show
presence_show:
    push rbx
    push r12

    mov rbx, SURFACE_BASE
    lea r12, [rbx + STATE_OFFSET + ST_PRESENCE]

    lea rdi, [rel pres_hdr]
    call print_cstr

    xor ecx, ecx
.show_loop:
    cmp ecx, NUM_PRESENCE
    jge .show_done
    push rcx

    ; Print index
    movzx rdi, cx
    call print_u64

    lea rdi, [rel pres_sep]
    call print_cstr

    ; Print value
    pop rcx
    push rcx
    movss xmm0, [r12 + rcx * 4]
    call print_f32
    call print_newline

    pop rcx
    inc ecx
    jmp .show_loop

.show_done:
    pop r12
    pop rbx
    ret

;; ============================================================
;; compute_intro_state
;; Determines the system's introspective state from metrics:
;;   CONFUSED: accuracy < 0.2 with many regions
;;   CONFIDENT: accuracy > 0.7
;;   LEARNING: recent emissions high
;;   STUCK: low accuracy, no recent emissions, many steps
;;   EXPLORING: dispatch mode is EXPLORE
;;   CONSOLIDATING: many nursery regions
;;   IDLE: default
;; ============================================================
compute_intro_state:
    push rbx
    mov rbx, SURFACE_BASE

    ; Get overall accuracy (drive_accuracy holds this)
    movss xmm0, [rbx + STATE_OFFSET + ST_DRIVES]

    ; Check CONFUSED: accuracy < 0.2 with regions > 5
    mov eax, 0x3E4CCCCD        ; 0.2f
    movd xmm1, eax
    comiss xmm0, xmm1
    ja .not_confused
    lea rax, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    cmp dword [rax], 5
    jle .not_confused
    ; CONFUSED
    lea rax, [rbx + STATE_OFFSET + ST_INTRO_STATE]
    mov dword [rax], INTRO_CONFUSED
    jmp .intro_done

.not_confused:
    ; Check CONFIDENT: accuracy > 0.7
    mov eax, 0x3F333333        ; 0.7f
    movd xmm1, eax
    comiss xmm0, xmm1
    jbe .not_confident
    lea rax, [rbx + STATE_OFFSET + ST_INTRO_STATE]
    mov dword [rax], INTRO_CONFIDENT
    jmp .intro_done

.not_confident:
    ; Check LEARNING: recent emissions > 3
    lea rax, [rbx + STATE_OFFSET + ST_RECENT_EMITS]
    cmp dword [rax], 3
    jle .not_learning
    lea rax, [rbx + STATE_OFFSET + ST_INTRO_STATE]
    mov dword [rax], INTRO_LEARNING
    ; Reset emission counter after observation
    lea rax, [rbx + STATE_OFFSET + ST_RECENT_EMITS]
    mov dword [rax], 0
    jmp .intro_done

.not_learning:
    ; Check EXPLORING: dispatch mode is EXPLORE
    lea rax, [rbx + STATE_OFFSET + ST_DISPATCH_MODE]
    cmp dword [rax], DMODE_EXPLORE
    jne .not_exploring
    lea rax, [rbx + STATE_OFFSET + ST_INTRO_STATE]
    mov dword [rax], INTRO_EXPLORING
    jmp .intro_done

.not_exploring:
    ; Check CONSOLIDATING: nursery regions exist (dreamed but not yet promoted/condemned)
    ; Scan for NURSERY-flagged regions
    push rcx
    lea rax, [rbx + REGION_TABLE_OFFSET]
    mov ecx, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    xor edx, edx
.consolidate_scan:
    cmp edx, ecx
    jge .not_consolidating
    imul esi, edx, RTE_SIZE
    movzx edi, word [rax + rsi + RTE_FLAGS]
    test edi, RFLAG_NURSERY
    jnz .is_consolidating
    inc edx
    jmp .consolidate_scan
.is_consolidating:
    pop rcx
    lea rax, [rbx + STATE_OFFSET + ST_INTRO_STATE]
    mov dword [rax], INTRO_CONSOLIDATING
    jmp .intro_done
.not_consolidating:
    pop rcx

    ; Check STUCK: accuracy < 0.4, many steps, no recent emissions
    mov eax, 0x3ECCCCCD        ; 0.4f
    movd xmm1, eax
    comiss xmm0, xmm1
    ja .not_stuck
    lea rax, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    cmp qword [rax], 50
    jl .not_stuck
    lea rax, [rbx + STATE_OFFSET + ST_RECENT_EMITS]
    cmp dword [rax], 0
    jne .not_stuck
    lea rax, [rbx + STATE_OFFSET + ST_INTRO_STATE]
    mov dword [rax], INTRO_STUCK
    jmp .intro_done

.not_stuck:
    ; Default: IDLE
    lea rax, [rbx + STATE_OFFSET + ST_INTRO_STATE]
    mov dword [rax], INTRO_IDLE

.intro_done:
    pop rbx
    ret

;; ============================================================
;; detect_episode
;; Compare current intro_state with previous. If changed,
;; write an entry to the episode ring buffer.
;; ============================================================
detect_episode:
    push rbx
    mov rbx, SURFACE_BASE

    ; Compare current with previous
    mov eax, [rbx + STATE_OFFSET + ST_INTRO_STATE]
    cmp eax, [rbx + STATE_OFFSET + ST_PREV_INTRO_STATE]
    je .no_episode

    ; Also check dispatch mode change
    jmp .record_episode

.no_episode:
    mov eax, [rbx + STATE_OFFSET + ST_DISPATCH_MODE]
    cmp eax, [rbx + STATE_OFFSET + ST_PREV_DISPATCH_MODE]
    je .ep_save_prev

.record_episode:
    ; State changed — record episode boundary
    lea rdi, [rbx + STATE_OFFSET + ST_EPISODE_RING]
    mov ecx, [rbx + STATE_OFFSET + ST_EPISODE_POS]
    imul edx, ecx, ST_EPISODE_ENTRY
    add rdi, rdx
    ; Store step
    mov rax, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    mov [rdi], rax
    ; Store context hash
    mov rax, [rbx + STATE_OFFSET + ST_CTX_HASH]
    mov [rdi + 8], rax
    ; Advance position
    inc ecx
    cmp ecx, ST_EPISODE_CAP
    jl .ep_no_wrap
    xor ecx, ecx
.ep_no_wrap:
    mov [rbx + STATE_OFFSET + ST_EPISODE_POS], ecx

    ; Fire episode hook
    push rbx
    mov edi, HOOK_ON_EPISODE
    xor esi, esi
    call fire_hook
    pop rbx

.ep_save_prev:
    ; Save current as prev
    mov eax, [rbx + STATE_OFFSET + ST_INTRO_STATE]
    mov [rbx + STATE_OFFSET + ST_PREV_INTRO_STATE], eax
    mov eax, [rbx + STATE_OFFSET + ST_DISPATCH_MODE]
    mov [rbx + STATE_OFFSET + ST_PREV_DISPATCH_MODE], eax

    pop rbx
    ret

;; ============================================================
;; compute_accuracy_variance
;; Walk regions, compute per-region accuracy, compute variance
;; Stores result in ST_ACCURACY_VARIANCE
;; ============================================================
compute_accuracy_variance:
    push rbx
    push r12
    push r13
    sub rsp, 16               ; [0]=sum (f32), [4]=sum_sq (f32), [8]=count (u32)

    mov rbx, SURFACE_BASE
    xorps xmm0, xmm0
    movss [rsp + 0], xmm0    ; sum
    movss [rsp + 4], xmm0    ; sum_sq
    mov dword [rsp + 8], 0   ; count

    lea r12, [rbx + REGION_TABLE_OFFSET]
    mov r13d, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    xor ecx, ecx
.vl:
    cmp ecx, r13d
    jge .vdone
    push rcx

    imul rdi, rcx, RTE_SIZE
    add rdi, r12
    movzx eax, word [rdi + RTE_FLAGS]
    test eax, RFLAG_CONDEMNED
    jnz .vnext

    mov rsi, [rdi + RTE_ADDR]
    test rsi, rsi             ; null check
    jz .vnext
    mov eax, [rsi + RHDR_HITS]
    mov edx, [rsi + RHDR_MISSES]
    add edx, eax
    cmp edx, 2               ; need at least 2 events
    jl .vnext

    ; accuracy
    cvtsi2ss xmm0, eax
    cvtsi2ss xmm1, edx
    divss xmm0, xmm1         ; xmm0 = acc

    ; sum += acc
    movss xmm2, [rsp + 8 + 0]
    addss xmm2, xmm0
    movss [rsp + 8 + 0], xmm2

    ; sum_sq += acc*acc
    movss xmm2, xmm0
    mulss xmm2, xmm0
    addss xmm2, [rsp + 8 + 4]
    movss [rsp + 8 + 4], xmm2

    ; count++
    inc dword [rsp + 8 + 8]

.vnext:
    pop rcx
    inc ecx
    jmp .vl

.vdone:
    ; variance = sum_sq/count - (sum/count)^2
    mov eax, [rsp + 8]
    test eax, eax
    jz .vzero

    cvtsi2ss xmm2, eax       ; count as float
    movss xmm0, [rsp + 4]    ; sum_sq
    divss xmm0, xmm2         ; E[x^2]
    movss xmm1, [rsp + 0]    ; sum
    divss xmm1, xmm2         ; E[x]
    mulss xmm1, xmm1         ; E[x]^2
    subss xmm0, xmm1         ; variance
    ; Clamp to >= 0 (rounding errors)
    xorps xmm1, xmm1
    maxss xmm0, xmm1
    movss [rbx + STATE_OFFSET + ST_ACCURACY_VARIANCE], xmm0
    jmp .vret

.vzero:
    xorps xmm0, xmm0
    movss [rbx + STATE_OFFSET + ST_ACCURACY_VARIANCE], xmm0

.vret:
    add rsp, 16
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; decay_connection_weights
;; Walk all regions, multiply all 4 weights by WEIGHT_DECAY.
;; Clear connections where weight < WEIGHT_FLOOR.
;; This is the "forgetting" that prevents graph saturation.
;; ============================================================
global decay_connection_weights
decay_connection_weights:
    push rbx
    push r12
    push r13

    mov rbx, SURFACE_BASE
    lea r12, [rbx + REGION_TABLE_OFFSET]
    mov r13d, [rbx + STATE_OFFSET + ST_REGION_COUNT]

    ; Preload constants
    movsd xmm4, [rel obs_weight_decay]   ; 0.995
    movsd xmm5, [rel obs_weight_floor]   ; 0.01
    movsd xmm6, [rel obs_f64_zero]       ; 0.0

    xor ecx, ecx
.wdecay_loop:
    cmp ecx, r13d
    jge .wdecay_done
    push rcx

    imul rdi, rcx, RTE_SIZE
    add rdi, r12
    movzx eax, word [rdi + RTE_FLAGS]
    test eax, RFLAG_CONDEMNED
    jnz .wdecay_next

    mov rsi, [rdi + RTE_ADDR]
    test rsi, rsi             ; null check
    jz .wdecay_next

    ; --- w_excite_a ---
    movsd xmm0, [rsi + RHDR_W_EXCITE_A]
    mulsd xmm0, xmm4
    ucomisd xmm0, xmm5
    ja .wdecay_ea_ok
    ; Below floor — clear connection
    movsd [rsi + RHDR_W_EXCITE_A], xmm6
    mov qword [rsi + RHDR_EXCITE_A], 0
    jmp .wdecay_eb
.wdecay_ea_ok:
    movsd [rsi + RHDR_W_EXCITE_A], xmm0

.wdecay_eb:
    ; --- w_excite_b ---
    movsd xmm0, [rsi + RHDR_W_EXCITE_B]
    mulsd xmm0, xmm4
    ucomisd xmm0, xmm5
    ja .wdecay_eb_ok
    movsd [rsi + RHDR_W_EXCITE_B], xmm6
    mov qword [rsi + RHDR_EXCITE_B], 0
    jmp .wdecay_ia
.wdecay_eb_ok:
    movsd [rsi + RHDR_W_EXCITE_B], xmm0

.wdecay_ia:
    ; --- w_inhibit_a ---
    movsd xmm0, [rsi + RHDR_W_INHIBIT_A]
    mulsd xmm0, xmm4
    ucomisd xmm0, xmm5
    ja .wdecay_ia_ok
    movsd [rsi + RHDR_W_INHIBIT_A], xmm6
    mov qword [rsi + RHDR_INHIBIT_A], 0
    jmp .wdecay_ib
.wdecay_ia_ok:
    movsd [rsi + RHDR_W_INHIBIT_A], xmm0

.wdecay_ib:
    ; --- w_inhibit_b ---
    movsd xmm0, [rsi + RHDR_W_INHIBIT_B]
    mulsd xmm0, xmm4
    ucomisd xmm0, xmm5
    ja .wdecay_ib_ok
    movsd [rsi + RHDR_W_INHIBIT_B], xmm6
    mov qword [rsi + RHDR_INHIBIT_B], 0
    jmp .wdecay_next
.wdecay_ib_ok:
    movsd [rsi + RHDR_W_INHIBIT_B], xmm0

.wdecay_next:
    pop rcx
    inc ecx
    jmp .wdecay_loop

.wdecay_done:
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; repair_routing
;; Find regions with no next links but neighbors exist.
;; Wire isolated nodes into the graph by scanning for regions
;; with similar context (masked comparison).
;; ============================================================
global repair_routing
repair_routing:
    push rbx
    push r12
    push r13
    push r14
    push r15

    mov rbx, SURFACE_BASE
    lea r12, [rbx + REGION_TABLE_OFFSET]
    mov r13d, [rbx + STATE_OFFSET + ST_REGION_COUNT]

    xor ecx, ecx
.repair_loop:
    cmp ecx, r13d
    jge .repair_done
    push rcx

    imul rdi, rcx, RTE_SIZE
    add rdi, r12
    movzx eax, word [rdi + RTE_TYPE]
    cmp eax, RTYPE_DISPATCH
    jne .repair_next
    movzx eax, word [rdi + RTE_FLAGS]
    test eax, RFLAG_CONDEMNED
    jnz .repair_next

    mov r14, [rdi + RTE_ADDR]  ; region header
    test r14, r14             ; null check
    jz .repair_next

    ; Check if isolated (next_a == 0 AND next_b == 0)
    cmp qword [r14 + RHDR_NEXT_A], 0
    jne .repair_next
    cmp qword [r14 + RHDR_NEXT_B], 0
    jne .repair_next

    ; This region has no routing — try to find a neighbor
    ; Get this region's context (if valid dispatch pattern)
    cmp byte [r14 + RHDR_SIZE], 0x3D
    jne .repair_next
    mov r15d, [r14 + RHDR_SIZE + 1]  ; this region's context

    ; Scan for another DISPATCH region with similar context
    pop rcx
    push rcx
    xor edx, edx
.repair_inner:
    cmp edx, r13d
    jge .repair_next
    cmp edx, [rsp]            ; skip self (ecx is at [rsp])
    je .repair_inner_next

    push rdx
    imul rdi, rdx, RTE_SIZE
    add rdi, r12
    movzx eax, word [rdi + RTE_TYPE]
    cmp eax, RTYPE_DISPATCH
    jne .repair_inner_skip
    movzx eax, word [rdi + RTE_FLAGS]
    test eax, RFLAG_CONDEMNED
    jnz .repair_inner_skip

    mov rsi, [rdi + RTE_ADDR]
    test rsi, rsi             ; null check
    jz .repair_inner_skip
    cmp rsi, r14
    je .repair_inner_skip      ; same region

    ; Check context similarity (same masked context)
    cmp byte [rsi + RHDR_SIZE], 0x3D
    jne .repair_inner_skip
    mov eax, [rsi + RHDR_SIZE + 1]
    ; Masked comparison: (ctx_a & 0xFFFFFFF0) == (ctx_b & 0xFFFFFFF0)
    mov edi, r15d
    and edi, 0xFFFFFFF0
    and eax, 0xFFFFFFF0
    cmp eax, edi
    jne .repair_inner_skip

    ; Found a neighbor! Wire isolated region → neighbor
    mov [r14 + RHDR_NEXT_A], rsi
    pop rdx
    jmp .repair_next

.repair_inner_skip:
    pop rdx
.repair_inner_next:
    inc edx
    jmp .repair_inner

.repair_next:
    pop rcx
    inc ecx
    jmp .repair_loop

.repair_done:
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

section .rodata
    pres_hdr:       db "--- Presence (30 fields) ---", 10, 0
    pres_sep:       db ": ", 0

extern print_str
; persist.asm — Save/restore surface state to/from file
;
; ENTRY POINTS:
;   persist_save(filename)            - save surface to file
;   persist_load(filename)            - restore surface from file
;   gene_export(filename)             - export gene pool to portable format
;   gene_import(filename)             - import gene pool from file
;   gene_auto_export()                - periodic auto-save of genes
;   gene_scan_library(dir_path)       - scan directory for importable genes
;
; FILE FORMAT (persist_save/load):
;   [0-7]   magic "UHMA" + padding
;   [8-15]  version (currently 2)
;   [16+]   state block
;   [+]     region table
;   [+]     dispatch region (bootstrap to alloc_ptr)
;   [+]     holographic arena (vocab, traces)
;
; GENE EXPORT FORMAT:
;   Portable JSON-like format for sharing learned patterns
;   Contains: ctx_hash, token_id, fitness, optional metadata
;
; HOOKS FIRED:
;   HOOK_SAVE before save, HOOK_LOAD after successful load
;
; CALLED BY: repl.asm (save/load commands), boot.asm (auto-restore)
;
%include "syscalls.inc"
%include "constants.inc"

section .data
    save_msg:       db "[PERSIST] Saving surface to: ", 0
    save_done:      db "[PERSIST] Save complete. Bytes: ", 0
    load_msg:       db "[PERSIST] Loading surface from: ", 0
    load_done:      db "[PERSIST] Restore complete. Bytes: ", 0
    save_err:       db "[PERSIST] Error: could not open file for writing", 10, 0
    load_err:       db "[PERSIST] Error: could not open file for reading", 10, 0
    persist_nl:     db 10, 0

    ; File header magic
    persist_magic:  db "UHMA", 0, 0, 0, 0   ; 8 bytes
    persist_ver:    dq 2                      ; version (2 = includes holo/vocab)

section .text

extern print_cstr
extern print_u64
extern print_newline
extern fire_hook

;; ============================================================
;; persist_save(filename)
;; rdi=null-terminated filename string
;; Saves the critical surface regions to a file:
;; - Header (magic + version + metadata)
;; - State block
;; - Region table
;; - Dispatch region (bootstrap to alloc ptr)
;; ============================================================
global persist_save
persist_save:
    push rbx
    push r12
    push r13
    push r14

    mov r12, rdi              ; filename

    ; Print save message
    lea rdi, [rel save_msg]
    call print_cstr
    mov rdi, r12
    call print_cstr
    call print_newline

    ; Fire save hook
    mov edi, HOOK_ON_SAVE
    xor esi, esi
    call fire_hook

    ; Open file for writing (create/truncate)
    mov rdi, r12
    mov rsi, O_WRONLY | O_CREAT | O_TRUNC
    mov rdx, FILE_MODE
    mov rax, SYS_OPEN
    syscall

    cmp rax, 0
    jl .save_error
    mov r13, rax              ; fd

    mov rbx, SURFACE_BASE
    xor r14d, r14d            ; total bytes written

    ; --- Write header ---
    ; Magic (8 bytes)
    mov rdi, r13
    lea rsi, [rel persist_magic]
    mov rdx, 8
    mov rax, SYS_WRITE
    syscall
    add r14, rax

    ; Version (8 bytes)
    mov rdi, r13
    lea rsi, [rel persist_ver]
    mov rdx, 8
    mov rax, SYS_WRITE
    syscall
    add r14, rax

    ; Surface base address (8 bytes, for relocation check)
    sub rsp, 8
    mov rax, SURFACE_BASE
    mov [rsp], rax
    mov rdi, r13
    lea rsi, [rsp]
    mov rdx, 8
    mov rax, SYS_WRITE
    syscall
    add r14, rax
    add rsp, 8

    ; --- Write state block ---
    mov rdi, r13
    lea rsi, [rbx + STATE_OFFSET]
    mov rdx, STATE_SIZE
    mov rax, SYS_WRITE
    syscall
    add r14, rax

    ; --- Write region table ---
    mov rdi, r13
    lea rsi, [rbx + REGION_TABLE_OFFSET]
    mov rdx, REGION_TABLE_SIZE
    mov rax, SYS_WRITE
    syscall
    add r14, rax

    ; --- Write dispatch region ---
    ; From DISPATCH_OFFSET to current alloc ptr
    lea rax, [rbx + STATE_OFFSET + ST_DISPATCH_PTR]
    mov rcx, [rax]            ; current alloc ptr (absolute)
    sub rcx, rbx
    sub rcx, DISPATCH_OFFSET  ; size = ptr - dispatch_base
    test rcx, rcx
    jle .skip_dispatch

    mov rdi, r13
    lea rsi, [rbx + DISPATCH_OFFSET]
    mov rdx, rcx
    mov rax, SYS_WRITE
    syscall
    add r14, rax

.skip_dispatch:
    ; --- Write VSA basis vectors (2MB) ---
    ; NOTE: VSA_OFFSET = 0x80000000 sign-extends in lea. Use register arithmetic.
    mov rdi, r13
    mov rsi, rbx
    mov rcx, VSA_OFFSET
    add rsi, rcx                  ; 64-bit offset via register
    mov rdx, VSA_VEC_BYTES * 256  ; 256 basis vectors
    mov rax, SYS_WRITE
    syscall
    add r14, rax

    ; --- Write holographic traces (2MB) ---
    mov rdi, r13
    mov rsi, rbx
    mov rcx, HOLO_OFFSET
    add rsi, rcx                  ; 64-bit offset via register
    mov rdx, HOLO_TOTAL
    mov rax, SYS_WRITE
    syscall
    add r14, rax

    ; --- Write vocabulary ---
    ; Size = vocab_count * VOCAB_ENTRY_SIZE
    mov ecx, [rbx + STATE_OFFSET + ST_VOCAB_COUNT]
    test ecx, ecx
    jz .skip_vocab
    imul rcx, rcx, VOCAB_ENTRY_SIZE
    mov rdi, r13
    ; NOTE: VOCAB_OFFSET = 0xC0000000 sign-extends in lea. Use register arithmetic.
    mov rsi, rbx
    mov r8, VOCAB_OFFSET
    add rsi, r8
    mov rdx, rcx
    mov rax, SYS_WRITE
    syscall
    add r14, rax
.skip_vocab:
    ; Close file
    mov rdi, r13
    mov rax, SYS_CLOSE
    syscall

    ; Print done
    lea rdi, [rel save_done]
    call print_cstr
    mov rdi, r14
    call print_u64
    call print_newline

    pop r14
    pop r13
    pop r12
    pop rbx
    ret

.save_error:
    lea rdi, [rel save_err]
    call print_cstr
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; persist_load(filename)
;; rdi=null-terminated filename string
;; Restores surface state from file
;; ============================================================
global persist_load
persist_load:
    push rbx
    push r12
    push r13
    push r14

    mov r12, rdi

    ; Print load message
    lea rdi, [rel load_msg]
    call print_cstr
    mov rdi, r12
    call print_cstr
    call print_newline

    ; Open file for reading
    mov rdi, r12
    mov rsi, O_RDONLY
    xor edx, edx
    mov rax, SYS_OPEN
    syscall

    cmp rax, 0
    jl .load_error
    mov r13, rax              ; fd

    mov rbx, SURFACE_BASE
    xor r14d, r14d            ; total bytes read

    ; --- Read and verify header ---
    sub rsp, 24               ; space for magic + version + base
    mov rdi, r13
    lea rsi, [rsp]
    mov rdx, 24
    mov rax, SYS_READ
    syscall
    add r14, rax

    ; Check magic
    cmp dword [rsp], 'UHMA'
    jne .bad_magic

    ; Check version (accept 1 or 2)
    cmp qword [rsp + 8], 2
    ja .bad_magic
    cmp qword [rsp + 8], 0
    je .bad_magic

    ; Check base address matches
    mov rax, SURFACE_BASE
    cmp [rsp + 16], rax
    jne .bad_magic

    add rsp, 24

    ; --- Read state block ---
    mov rdi, r13
    lea rsi, [rbx + STATE_OFFSET]
    mov rdx, STATE_SIZE
    mov rax, SYS_READ
    syscall
    add r14, rax

    ; --- Read region table ---
    mov rdi, r13
    lea rsi, [rbx + REGION_TABLE_OFFSET]
    mov rdx, REGION_TABLE_SIZE
    mov rax, SYS_READ
    syscall
    add r14, rax

    ; --- Read dispatch region ---
    ; Calculate dispatch size from saved dispatch_ptr
    lea rax, [rbx + STATE_OFFSET + ST_DISPATCH_PTR]
    mov rcx, [rax]            ; dispatch_ptr (absolute)
    sub rcx, rbx
    sub rcx, DISPATCH_OFFSET  ; size = ptr - dispatch_base
    test rcx, rcx
    jle .skip_dispatch_read

    mov rdi, r13
    lea rsi, [rbx + DISPATCH_OFFSET]
    mov rdx, rcx
    mov rax, SYS_READ
    syscall
    add r14, rax

.skip_dispatch_read:
    ; --- Read VSA basis vectors (2MB) ---
    ; NOTE: VSA_OFFSET = 0x80000000 sign-extends in lea. Use register arithmetic.
    mov rdi, r13
    mov rsi, rbx
    mov rcx, VSA_OFFSET
    add rsi, rcx                  ; 64-bit offset via register
    mov rdx, VSA_VEC_BYTES * 256
    mov rax, SYS_READ
    syscall
    add r14, rax

    ; --- Read holographic traces (2MB) ---
    mov rdi, r13
    mov rsi, rbx
    mov rcx, HOLO_OFFSET
    add rsi, rcx                  ; 64-bit offset via register
    mov rdx, HOLO_TOTAL
    mov rax, SYS_READ
    syscall
    add r14, rax

    ; --- Read vocabulary ---
    ; Size = vocab_count * VOCAB_ENTRY_SIZE (vocab_count already loaded with state)
    mov ecx, [rbx + STATE_OFFSET + ST_VOCAB_COUNT]
    test ecx, ecx
    jz .read_done
    imul rcx, rcx, VOCAB_ENTRY_SIZE
    mov rdi, r13
    ; NOTE: VOCAB_OFFSET = 0xC0000000 sign-extends in lea. Use register arithmetic.
    mov rsi, rbx
    mov r8, VOCAB_OFFSET
    add rsi, r8
    mov rdx, rcx
    mov rax, SYS_READ
    syscall
    add r14, rax

.read_done:
    ; Close file
    mov rdi, r13
    mov rax, SYS_CLOSE
    syscall

    ; Fire restore hook
    mov edi, HOOK_ON_RESTORE
    xor esi, esi
    call fire_hook

    ; Print done
    lea rdi, [rel load_done]
    call print_cstr
    mov rdi, r14
    call print_u64
    call print_newline

    pop r14
    pop r13
    pop r12
    pop rbx
    ret

.bad_magic:
    add rsp, 24
    ; Close file
    mov rdi, r13
    mov rax, SYS_CLOSE
    syscall
    lea rdi, [rel bad_magic_msg]
    call print_cstr
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

.load_error:
    lea rdi, [rel load_err]
    call print_cstr
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

section .rodata
    bad_magic_msg:  db "[PERSIST] Error: invalid file (bad magic/version/base)", 10, 0

;; ============================================================
;; SPORE SYSTEM: Granular Genetics
;; "Genes" are standalone, serializable units of function.
;; Knowledge survives the death of the process.
;; ============================================================

section .data
    gene_magic:     db "GENE"       ; 4-byte magic header
    gene_version:   dd 1            ; gene format version

    gene_export_msg: db "[SPORE] Exporting gene: ", 0
    gene_import_msg: db "[SPORE] Importing gene: ", 0
    gene_success:    db " OK", 10, 0
    gene_fail:       db " FAILED", 10, 0
    gene_stable:     db "[SPORE] Region stable — auto-exporting", 10, 0
    gene_library:    db "/.uhma/library/", 0  ; relative to $HOME

    ; Gene file structure:
    ;   [0-3]   Magic "GENE" (4 bytes)
    ;   [4-7]   Version (u32)
    ;   [8-11]  Context hash (u32) - the trigger pattern
    ;   [12-15] Token ID (u32) - what this gene predicts
    ;   [16-23] Valence (f64) - success/failure emotional charge
    ;   [24-27] Hits (u32)
    ;   [28-31] Misses (u32)
    ;   [32-35] Birth step (u32)
    ;   [36-39] Code length (u32)
    ;   [40...]  Code bytes (position-independent)

    align 8
    gene_header_size: equ 40

section .text

extern holo_gen_vec
extern holo_store
extern holo_query_valence
extern vsa_extract_valence

;; ============================================================
;; gene_export(region_ptr, filename) -> eax (0=success, -1=fail)
;; rdi=region header pointer, rsi=output filename
;; Exports a region as a .gene file (portable knowledge unit)
;; ============================================================
global gene_export
gene_export:
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub rsp, 64               ; local gene header buffer

    mov r12, rdi              ; region ptr
    mov r13, rsi              ; filename

    ; Print export message
    lea rdi, [rel gene_export_msg]
    call print_cstr
    mov rdi, r13
    call print_cstr

    ; Extract region info
    movzx r14d, word [r12 + RHDR_CODE_LEN]  ; code length
    test r14d, r14d
    jz .export_fail

    ; Build gene header
    ; Magic
    mov dword [rsp], 'GENE'
    ; Version
    mov dword [rsp + 4], 1
    ; Context hash (from code: CMP EAX, imm32 at offset 1)
    mov eax, [r12 + RHDR_SIZE + 1]
    mov [rsp + 8], eax
    ; Token ID (from code: MOV EAX, imm32 at offset 8)
    mov eax, [r12 + RHDR_SIZE + 8]
    mov [rsp + 12], eax
    ; Valence (query from holographic memory using ctx_hash)
    mov edi, [rsp + 8]        ; ctx_hash
    push r12
    push r13
    sub rsp, 8                ; alignment
    call holo_query_valence   ; defined in vsa.asm
    add rsp, 8
    pop r13
    pop r12
    movsd [rsp + 16], xmm0
    ; Hits
    mov eax, [r12 + RHDR_HITS]
    mov [rsp + 24], eax
    ; Misses
    mov eax, [r12 + RHDR_MISSES]
    mov [rsp + 28], eax
    ; Birth step
    mov eax, [r12 + RHDR_BIRTH]
    mov [rsp + 32], eax
    ; Code length
    mov [rsp + 36], r14d

    ; Open file for writing
    mov rdi, r13
    mov rsi, O_WRONLY | O_CREAT | O_TRUNC
    mov rdx, FILE_MODE
    mov rax, SYS_OPEN
    syscall
    test rax, rax
    js .export_fail
    mov r15, rax              ; fd

    ; Write header
    mov rdi, r15
    lea rsi, [rsp]
    mov rdx, gene_header_size
    mov rax, SYS_WRITE
    syscall
    cmp rax, gene_header_size
    jne .export_close_fail

    ; Write code
    mov rdi, r15
    lea rsi, [r12 + RHDR_SIZE]
    mov edx, r14d
    mov rax, SYS_WRITE
    syscall
    cmp eax, r14d
    jne .export_close_fail

    ; Close file
    mov rdi, r15
    mov rax, SYS_CLOSE
    syscall

    lea rdi, [rel gene_success]
    call print_cstr

    xor eax, eax              ; return success
    jmp .export_done

.export_close_fail:
    mov rdi, r15
    mov rax, SYS_CLOSE
    syscall

.export_fail:
    lea rdi, [rel gene_fail]
    call print_cstr
    mov eax, -1

.export_done:
    add rsp, 64
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; gene_import(filename) -> eax (0=success, -1=fail)
;; rdi=gene filename
;; Imports a .gene file and creates a new region from it.
;; The gene is "activated" — becomes live code in this instance.
;; ============================================================
global gene_import
extern region_alloc
extern emit_dispatch_pattern

gene_import:
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub rsp, 128              ; local buffer for header + small code

    mov r12, rdi              ; filename

    ; Print import message
    lea rdi, [rel gene_import_msg]
    call print_cstr
    mov rdi, r12
    call print_cstr

    ; Open file for reading
    mov rdi, r12
    mov rsi, O_RDONLY
    xor edx, edx
    mov rax, SYS_OPEN
    syscall
    test rax, rax
    js .import_fail
    mov r13, rax              ; fd

    ; Read header
    mov rdi, r13
    lea rsi, [rsp]
    mov rdx, gene_header_size
    mov rax, SYS_READ
    syscall
    cmp rax, gene_header_size
    jne .import_close_fail

    ; Verify magic
    cmp dword [rsp], 'GENE'
    jne .import_close_fail

    ; Extract info
    mov r14d, [rsp + 8]       ; ctx_hash
    mov r15d, [rsp + 12]      ; token_id
    mov ebx, [rsp + 36]       ; code_length

    ; Read code into buffer (if small enough)
    cmp ebx, 80               ; max inline code size
    ja .import_close_fail

    mov rdi, r13
    lea rsi, [rsp + 48]       ; code buffer
    mov edx, ebx
    mov rax, SYS_READ
    syscall
    cmp eax, ebx
    jne .import_close_fail

    ; Close file
    mov rdi, r13
    mov rax, SYS_CLOSE
    syscall

    ; Store in holographic memory with valence from gene
    mov edi, r14d             ; ctx_hash
    mov esi, r15d             ; token_id
    movsd xmm0, [rsp + 16]    ; valence from gene
    call holo_store

    ; Create region using emit_dispatch_pattern
    mov edi, r14d             ; ctx_hash
    mov esi, r15d             ; token_id
    mov edx, [rsp + 32]       ; birth_step (from gene)
    call emit_dispatch_pattern

    lea rdi, [rel gene_success]
    call print_cstr

    xor eax, eax              ; return success
    jmp .import_done

.import_close_fail:
    mov rdi, r13
    mov rax, SYS_CLOSE
    syscall

.import_fail:
    lea rdi, [rel gene_fail]
    call print_cstr
    mov eax, -1

.import_done:
    add rsp, 128
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; gene_auto_export(region_ptr) -> eax (0=exported, 1=not stable enough)
;; rdi=region header pointer
;; Checks if region is stable enough for auto-export to library.
;; Criteria: Age > 100 steps, Accuracy > 80%, Hits > 10
;; ============================================================
global gene_auto_export
gene_auto_export:
    push rbx
    push r12
    sub rsp, 280              ; filename buffer

    mov r12, rdi              ; region ptr
    mov rbx, SURFACE_BASE

    ; Check age (birth_step vs global_step)
    mov eax, [r12 + RHDR_BIRTH]
    mov ecx, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    sub ecx, eax              ; age = global_step - birth
    cmp ecx, 100              ; require age > 100
    jl .not_stable

    ; Check hits
    mov eax, [r12 + RHDR_HITS]
    cmp eax, 10               ; require > 10 hits
    jl .not_stable

    ; Check accuracy = hits / (hits + misses)
    mov ecx, [r12 + RHDR_MISSES]
    add ecx, eax              ; total = hits + misses
    jz .not_stable            ; avoid div by zero
    cvtsi2sd xmm0, eax        ; hits
    cvtsi2sd xmm1, ecx        ; total
    divsd xmm0, xmm1          ; accuracy
    mov rax, 0x3FE999999999999A  ; 0.8 f64
    movq xmm1, rax
    ucomisd xmm0, xmm1
    jb .not_stable            ; require > 80%

    ; --- Stable enough: export to library ---
    lea rdi, [rel gene_stable]
    call print_cstr

    ; Build filename: ctx_hash.gene
    mov eax, [r12 + RHDR_SIZE + 1]  ; ctx_hash
    ; Simple hex filename
    lea rdi, [rsp]
    mov dword [rdi], '/tmp'
    mov dword [rdi + 4], '/gen'
    mov dword [rdi + 8], 'e_'
    ; Convert hash to hex string (simplified)
    add rdi, 10
    mov ecx, 8
.hex_loop:
    mov edx, eax
    shr eax, 4
    and edx, 0xF
    cmp edx, 10
    jl .hex_digit
    add edx, 'a' - 10
    jmp .hex_store
.hex_digit:
    add edx, '0'
.hex_store:
    mov [rdi], dl
    inc rdi
    dec ecx
    jnz .hex_loop
    mov dword [rdi], '.gen'
    mov word [rdi + 4], 'e'
    mov byte [rdi + 5], 0

    ; Export
    mov rdi, r12              ; region ptr
    lea rsi, [rsp]            ; filename
    call gene_export

    jmp .auto_done

.not_stable:
    mov eax, 1                ; not stable enough

.auto_done:
    add rsp, 280
    pop r12
    pop rbx
    ret

;; ============================================================
;; gene_scan_library() -> eax (number imported)
;; Scans ~/.uhma/library/ for .gene files and imports them.
;; Called at startup to "infect" new instances with culture.
;; ============================================================
global gene_scan_library
gene_scan_library:
    ; Stub for now — full implementation would use getdents64
    ; to enumerate /tmp/gene_*.gene files
    xor eax, eax
    ret
; presence.asm — Hormonal modulator: presence regions for emotional reflexes
;
; ENTRY POINTS:
;   presence_init()                   - create hardwired reflex regions
;   trigger_presence_regions()        - evaluate all presence regions
;   presence_regions_show()           - display active presence regions
;
; PRESENCE REGIONS (emitted at init):
;   PANIC_MODE:       high entropy + low energy → force fast/prune
;   CONTEMPLATIVE:    low entropy + high energy → slow down, consolidate
;   FATIGUE_RESPONSE: high fatigue → reduce activity, trigger dreams
;   VIGOR_BOOST:      high energy + low fatigue → increase exploration
;   CRISIS_INTERVENTION: very low accuracy → emergency restructure
;   STABILITY_RESTORED: all metrics good → normal operation
;
; STATE THRESHOLDS:
;   high_entropy_thresh (0.8), low_entropy_thresh (0.3)
;   low_energy_thresh (20.0), high_energy_thresh (80.0)
;   high_arousal_thresh (0.7), low_arousal_thresh (0.3)
;   high_fatigue_thresh (0.7), low_accuracy_thresh (0.3)
;
; PHILOSOPHY:
;   Presence regions are "emotional reflexes" - they check somatic state
;   and trigger system-wide parameter changes. The system steers itself.
;
; CALLED BY: introspect.asm (update_presence_dispatch), surface.asm (init)
;
%include "syscalls.inc"
%include "constants.inc"

section .data
    pres_trig_msg:      db "[PRESENCE] Hormonal trigger: ", 0
    pres_panic_msg:     db "PANIC_MODE", 0
    pres_contemp_msg:   db "CONTEMPLATIVE_MODE", 0
    pres_fatigue_msg:   db "FATIGUE_RESPONSE", 0
    pres_vigor_msg:     db "VIGOR_BOOST", 0
    pres_crisis_msg:    db "CRISIS_INTERVENTION", 0
    pres_stable_msg:    db "STABILITY_RESTORED", 0
    pres_newline:       db 10, 0

    ; Thresholds for built-in presence checks
    align 8
    high_entropy_thresh:    dq 0.8      ; entropy > 0.8 = chaotic
    low_entropy_thresh:     dq 0.3      ; entropy < 0.3 = stable
    low_energy_thresh:      dq 20.0     ; energy < 20 = exhausted
    high_energy_thresh:     dq 80.0     ; energy > 80 = vigorous
    high_arousal_thresh:    dd 0.7      ; arousal > 0.7 = excited/panicked (f32)
    low_arousal_thresh:     dd 0.3      ; arousal < 0.3 = calm
    high_fatigue_thresh:    dd 0.7      ; fatigue > 0.7 = tired
    low_accuracy_thresh:    dd 0.3      ; accuracy < 0.3 = struggling

section .text

extern print_cstr
extern print_newline
extern region_alloc
extern dream_cycle
extern observe_cycle

;; ============================================================
;; presence_init
;; Initialize the presence-as-action system.
;; Creates initial hormonal regions for basic survival reflexes.
;; ============================================================
global presence_init
presence_init:
    push rbx

    ; Create the fundamental presence regions (hardwired reflexes)
    ; These are the system's innate emotional responses

    ; 1. PANIC MODE: High entropy + low energy → force fast/prune
    call emit_panic_region

    ; 2. CONTEMPLATIVE MODE: Low entropy + stable → allow exploration
    call emit_contemplative_region

    ; 3. FATIGUE RESPONSE: High fatigue → trigger dream, slow down
    call emit_fatigue_region

    pop rbx
    ret

;; ============================================================
;; emit_panic_region
;; Creates a presence region for panic response:
;; IF entropy > 0.8 AND energy < 20 THEN set DMODE_FAST, boost prune
;; ============================================================
emit_panic_region:
    push rbx
    push r12

    ; Allocate presence region (32 bytes of code)
    mov rdi, 32               ; code size
    mov rsi, RTYPE_PRESENCE
    xor edx, edx              ; birth = 0
    call region_alloc
    mov r12, rax              ; region header

    ; Write code that checks state and sets parameters
    ; Code layout:
    ;   [0-7]:   Check entropy > 0.8
    ;   [8-15]:  Check energy < 20
    ;   [16-23]: Set dispatch mode = FAST
    ;   [24-31]: Boost prune threshold, RET

    lea rbx, [r12 + RHDR_SIZE]

    ; mov rax, SURFACE_BASE + STATE_OFFSET + ST_PRESENCE + PRES_ENTROPY*4
    ; This would be complex in pure x86... use a simpler sentinel approach:
    ; We'll mark this region with magic bytes that trigger_presence interprets
    ; Format: [condition_type:u8][threshold_high:f32][effect_type:u8][effect_value:u32][RET]

    ; Condition: PCOND_ENTROPY_GT
    mov byte [rbx + 0], PCOND_ENTROPY_GT
    ; Threshold: 0.8 (as f32)
    mov eax, 0x3F4CCCCD          ; 0.8f
    mov [rbx + 1], eax
    ; Second condition: PCOND_ENERGY_LT
    mov byte [rbx + 5], PCOND_ENERGY_LT
    ; Threshold: 20.0 (as f32)
    mov eax, 0x41A00000          ; 20.0f
    mov [rbx + 6], eax
    ; Effect: PEFF_SET_DISPATCH_MODE
    mov byte [rbx + 10], PEFF_SET_DISPATCH_MODE
    ; Value: DMODE_FAST
    mov dword [rbx + 11], DMODE_FAST
    ; End marker
    mov byte [rbx + 15], 0xFF    ; end of effects
    ; Pad rest with RET (0xC3)
    mov ecx, 16
.pad_panic:
    cmp ecx, 32
    jge .panic_done
    mov byte [rbx + rcx], 0xC3
    inc ecx
    jmp .pad_panic

.panic_done:
    mov rax, r12
    pop r12
    pop rbx
    ret

;; ============================================================
;; emit_contemplative_region
;; Creates a presence region for contemplative/exploratory state:
;; IF entropy < 0.3 AND energy > 50 THEN set DMODE_EXPLORE
;; ============================================================
emit_contemplative_region:
    push rbx
    push r12

    mov rdi, 32
    mov rsi, RTYPE_PRESENCE
    xor edx, edx
    call region_alloc
    mov r12, rax

    lea rbx, [r12 + RHDR_SIZE]

    ; Condition: PCOND_ENTROPY_LT with threshold 0.3
    mov byte [rbx + 0], PCOND_ENTROPY_LT
    mov eax, 0x3E99999A          ; 0.3f
    mov [rbx + 1], eax
    ; Second condition: PCOND_ENERGY_GT with threshold 50
    mov byte [rbx + 5], PCOND_ENERGY_GT
    mov eax, 0x42480000          ; 50.0f
    mov [rbx + 6], eax
    ; Effect: PEFF_SET_DISPATCH_MODE = EXPLORE
    mov byte [rbx + 10], PEFF_SET_DISPATCH_MODE
    mov dword [rbx + 11], DMODE_EXPLORE
    mov byte [rbx + 15], 0xFF
    ; Pad with RET
    mov ecx, 16
.pad_contemp:
    cmp ecx, 32
    jge .contemp_done
    mov byte [rbx + rcx], 0xC3
    inc ecx
    jmp .pad_contemp

.contemp_done:
    mov rax, r12
    pop r12
    pop rbx
    ret

;; ============================================================
;; emit_fatigue_region
;; Creates a presence region for fatigue response:
;; IF fatigue > 0.7 THEN trigger dream cycle
;; ============================================================
emit_fatigue_region:
    push rbx
    push r12

    mov rdi, 32
    mov rsi, RTYPE_PRESENCE
    xor edx, edx
    call region_alloc
    mov r12, rax

    lea rbx, [r12 + RHDR_SIZE]

    ; Condition: PCOND_FATIGUE_GT with threshold 0.7
    mov byte [rbx + 0], PCOND_FATIGUE_GT
    mov eax, 0x3F333333          ; 0.7f
    mov [rbx + 1], eax
    ; No second condition (mark as unused)
    mov byte [rbx + 5], 0xFF
    ; Effect: PEFF_TRIGGER_DREAM
    mov byte [rbx + 10], PEFF_TRIGGER_DREAM
    mov dword [rbx + 11], 1      ; value doesn't matter
    mov byte [rbx + 15], 0xFF
    ; Pad with RET
    mov ecx, 16
.pad_fatigue:
    cmp ecx, 32
    jge .fatigue_done
    mov byte [rbx + rcx], 0xC3
    inc ecx
    jmp .pad_fatigue

.fatigue_done:
    mov rax, r12
    pop r12
    pop rbx
    ret

;; ============================================================
;; trigger_presence_regions
;; Scans all RTYPE_PRESENCE regions and evaluates their conditions.
;; If conditions match current state, applies their effects.
;; Called periodically from observe_cycle.
;; ============================================================
global trigger_presence_regions
trigger_presence_regions:
    push rbx
    push r12
    push r13
    push r14
    push r15

    mov rbx, SURFACE_BASE
    lea r12, [rbx + REGION_TABLE_OFFSET]
    mov r13d, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    xor r14d, r14d              ; region index
    xor r15d, r15d              ; triggered count

.scan_presence:
    cmp r14d, r13d
    jge .scan_done

    ; Get region entry
    imul eax, r14d, RTE_SIZE
    lea rsi, [r12 + rax]

    ; Check if RTYPE_PRESENCE
    movzx eax, word [rsi + RTE_TYPE]
    cmp eax, RTYPE_PRESENCE
    jne .scan_next

    ; Check if active
    movzx eax, word [rsi + RTE_FLAGS]
    test eax, RFLAG_ACTIVE
    jz .scan_next
    test eax, RFLAG_CONDEMNED
    jnz .scan_next

    ; Get region code
    mov rdi, [rsi + RTE_ADDR]
    test rdi, rdi
    jz .scan_next

    ; Evaluate this presence region
    push rsi
    push r14
    call evaluate_presence_region
    pop r14
    pop rsi

    ; If returned true (eax != 0), increment triggered count
    test eax, eax
    jz .scan_next
    inc r15d
    ; Update hit count
    inc dword [rsi + RTE_HITS]

.scan_next:
    inc r14d
    jmp .scan_presence

.scan_done:
    mov eax, r15d               ; return triggered count
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; evaluate_presence_region(region_header)
;; rdi = region header pointer
;; Returns: eax = 1 if triggered, 0 if conditions not met
;; ============================================================
evaluate_presence_region:
    push rbx
    push r12
    push r13
    push r14
    push r15

    mov r12, rdi                ; region header
    lea r13, [r12 + RHDR_SIZE]  ; code start
    mov rbx, SURFACE_BASE
    xor r15d, r15d              ; conditions_met = 0

    ; Read first condition
    movzx eax, byte [r13 + 0]
    cmp eax, 0xFF               ; no condition = always true
    je .all_conditions_met
    mov r14d, eax               ; condition type

    ; Get threshold (f32 at offset 1)
    movss xmm1, [r13 + 1]

    ; Evaluate condition based on type
    call evaluate_condition
    test eax, eax
    jz .condition_failed

    ; Check second condition (offset 5)
    movzx eax, byte [r13 + 5]
    cmp eax, 0xFF               ; no second condition
    je .all_conditions_met
    mov r14d, eax

    movss xmm1, [r13 + 6]
    call evaluate_condition
    test eax, eax
    jz .condition_failed

.all_conditions_met:
    ; Apply effects
    movzx eax, byte [r13 + 10]
    cmp eax, 0xFF
    je .eval_done_true

    mov r14d, eax               ; effect type
    mov r15d, [r13 + 11]        ; effect value

    call apply_effect

.eval_done_true:
    mov eax, 1
    jmp .eval_done

.condition_failed:
    xor eax, eax

.eval_done:
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; evaluate_condition(type in r14d, threshold in xmm1)
;; Returns: eax = 1 if condition met, 0 otherwise
;; ============================================================
evaluate_condition:
    push rbx
    mov rbx, SURFACE_BASE

    cmp r14d, PCOND_ENTROPY_GT
    je .check_entropy_gt
    cmp r14d, PCOND_ENTROPY_LT
    je .check_entropy_lt
    cmp r14d, PCOND_ENERGY_GT
    je .check_energy_gt
    cmp r14d, PCOND_ENERGY_LT
    je .check_energy_lt
    cmp r14d, PCOND_AROUSAL_GT
    je .check_arousal_gt
    cmp r14d, PCOND_AROUSAL_LT
    je .check_arousal_lt
    cmp r14d, PCOND_FATIGUE_GT
    je .check_fatigue_gt
    cmp r14d, PCOND_ACCURACY_LT
    je .check_accuracy_lt

    ; Unknown condition type - return false
    xor eax, eax
    jmp .cond_done

.check_entropy_gt:
    movss xmm0, [rbx + STATE_OFFSET + ST_PRESENCE + PRES_ENTROPY * 4]
    ucomiss xmm0, xmm1
    ja .cond_true
    jmp .cond_false

.check_entropy_lt:
    movss xmm0, [rbx + STATE_OFFSET + ST_PRESENCE + PRES_ENTROPY * 4]
    ucomiss xmm0, xmm1
    jb .cond_true
    jmp .cond_false

.check_energy_gt:
    movsd xmm0, [rbx + STATE_OFFSET + ST_ENERGY]
    cvtss2sd xmm2, xmm1         ; threshold to f64
    ucomisd xmm0, xmm2
    ja .cond_true
    jmp .cond_false

.check_energy_lt:
    movsd xmm0, [rbx + STATE_OFFSET + ST_ENERGY]
    cvtss2sd xmm2, xmm1
    ucomisd xmm0, xmm2
    jb .cond_true
    jmp .cond_false

.check_arousal_gt:
    movss xmm0, [rbx + STATE_OFFSET + ST_PRESENCE + PRES_AROUSAL * 4]
    ucomiss xmm0, xmm1
    ja .cond_true
    jmp .cond_false

.check_arousal_lt:
    movss xmm0, [rbx + STATE_OFFSET + ST_PRESENCE + PRES_AROUSAL * 4]
    ucomiss xmm0, xmm1
    jb .cond_true
    jmp .cond_false

.check_fatigue_gt:
    movss xmm0, [rbx + STATE_OFFSET + ST_PRESENCE + PRES_FATIGUE * 4]
    ucomiss xmm0, xmm1
    ja .cond_true
    jmp .cond_false

.check_accuracy_lt:
    ; Use self-prediction accuracy from state
    mov eax, [rbx + STATE_OFFSET + ST_SELF_PRED_HITS]
    mov edx, [rbx + STATE_OFFSET + ST_SELF_PRED_MISSES]
    add edx, eax
    test edx, edx
    jz .cond_false              ; no data
    cvtsi2ss xmm0, eax
    cvtsi2ss xmm2, edx
    divss xmm0, xmm2            ; accuracy
    ucomiss xmm0, xmm1
    jb .cond_true
    jmp .cond_false

.cond_true:
    mov eax, 1
    jmp .cond_done

.cond_false:
    xor eax, eax

.cond_done:
    pop rbx
    ret

;; ============================================================
;; apply_effect(type in r14d, value in r15d)
;; Applies a hormonal effect to system parameters
;; ============================================================
apply_effect:
    push rbx
    mov rbx, SURFACE_BASE

    cmp r14d, PEFF_SET_DISPATCH_MODE
    je .eff_dispatch_mode
    cmp r14d, PEFF_TRIGGER_DREAM
    je .eff_trigger_dream
    cmp r14d, PEFF_TRIGGER_OBSERVE
    je .eff_trigger_observe
    jmp .eff_done

.eff_dispatch_mode:
    mov [rbx + STATE_OFFSET + ST_DISPATCH_MODE], r15d
    jmp .eff_done

.eff_trigger_dream:
    call dream_cycle
    jmp .eff_done

.eff_trigger_observe:
    call observe_cycle
    jmp .eff_done

.eff_done:
    pop rbx
    ret

;; ============================================================
;; presence_regions_show
;; REPL command to display presence region status
;; ============================================================
global presence_regions_show
presence_regions_show:
    push rbx
    push r12
    push r13

    mov rbx, SURFACE_BASE

    ; Print header
    lea rdi, [rel pres_trig_msg]
    call print_cstr

    ; Count presence regions
    lea r12, [rbx + REGION_TABLE_OFFSET]
    mov r13d, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    xor ecx, ecx
    xor edx, edx                ; presence count

.count_loop:
    cmp ecx, r13d
    jge .count_done
    push rcx
    imul eax, ecx, RTE_SIZE
    movzx eax, word [r12 + rax + RTE_TYPE]
    cmp eax, RTYPE_PRESENCE
    jne .count_next
    inc edx
.count_next:
    pop rcx
    inc ecx
    jmp .count_loop

.count_done:
    ; Print count
    push rdx
    lea rdi, [rel pres_newline]
    call print_cstr
    pop rdx

    pop r13
    pop r12
    pop rbx
    ret
; receipt.asm — Unified Holographic Receipt Layer + Cognitive Self-Model
;
; RECEIPT EMISSION:
; @entry emit_receipt_full(edi=event,esi=ctx,edx=actual,ecx=pred,r8d=region,r9d=aux,xmm0=conf,xmm1=val)
; @entry emit_receipt_simple(edi=event,esi=ctx,edx=token,xmm0=conf) -> void
;
; TRACE QUERIES:
; @entry receipt_resonate(edi=event,esi=ctx,edx=token) -> xmm0=similarity
; @entry trace_region_performance(edi=region) -> xmm0=ratio
; @entry trace_context_confidence(edi=ctx) -> xmm0=ratio
; @entry trace_hit_miss_ratio() -> xmm0=ratio
;
; INTROSPECTIVE STATE (REPL "intro"):
; @entry intro_query_confusion(edi=ctx) -> xmm0=resonance ; MISS resonance
; @entry intro_query_confidence(edi=ctx) -> xmm0=resonance ; HIT resonance
; @entry intro_query_learning(edi=ctx) -> xmm0=resonance ; LEARN resonance
; @entry intro_query_self_surprise(edi=ctx) -> xmm0=resonance ; EVENT_SELF resonance
; @entry intro_get_state(edi=ctx) -> eax=state, xmm0=strength ; dominant state
; @entry intro_get_self_awareness() -> xmm0=ratio ; self-surprise / total-miss
; @entry intro_report(edi=ctx) -> void ; REPL "intro" command
;
; SEMANTIC SELF-KNOWLEDGE (REPL "self"):
; @entry self_show_context_types() -> eax=strengths, edx=weaknesses
;
; CAUSAL MODEL (REPL "causal"):
; @entry causal_query_modification(edi=event,esi=ctx) -> xmm0=resonance
; @entry causal_report(edi=ctx) -> void ; REPL "causal" command
;
; META-STRATEGY:
; @entry meta_recommend_strategy(edi=ctx) -> eax=recommended_event_type
;
; DEBUG COMMANDS:
; @entry receipt_why_miss() -> void ; REPL "why" command
; @entry receipt_show_misses(edi=n) -> void ; REPL "misses N"
;
; @calls vsa.asm:holo_gen_vec, holo_bind_f64, holo_superpose_f64
; @calledby dispatch.asm, learn.asm, emit.asm, observe.asm, dreams.asm, repl.asm, introspect.asm
;
; STORAGE: UNIFIED_TRACE_IDX=240, 8KB | ST_LAST_MISS_* for "why" command
; 8 DIMENSIONS: time→tracer→aux→region→predicted→actual→ctx→event
;
; SELF-AWARENESS SYSTEM:
;   EVENT_SELF (type 15) emitted on self-model violations
;   intro_query_self_surprise() queries EVENT_SELF resonance
;   intro_get_self_awareness() = self_surprise / (total_miss + epsilon)
;   Enables system to distinguish "I was wrong about myself" vs "world surprised me"
;
; GOTCHAS:
;   - emit_receipt_full for MISS must include predicted token (diagnostic key)
;   - receipt_resonate returns f64 similarity, not bool
;   - No working buffer - all history is holographic, only last miss stored for "why"
;   - Causal queries need receipts with aux=accuracy*1000 (emitted by modify.asm)

%include "syscalls.inc"
%include "constants.inc"

section .data
    ; Debug output messages
    rcpt_emit_msg:      db "  #", 0
    rcpt_event_lbl:     db " ", 0
    rcpt_ctx_lbl:       db " ctx=0x", 0
    rcpt_tok_lbl:       db " tok=0x", 0
    rcpt_pred_lbl:      db " pred=0x", 0
    rcpt_fid_lbl:       db " fid=", 0
    rcpt_nl:            db 10, 0

    rcpt_dump_hdr:      db "[RECEIPTS] Holographic trace query:", 10, 0
    rcpt_dump_mid:      db "):", 10, 0
    rcpt_dump_trace_hdr: db "[RECEIPTS] Holographic trace resonance by event:", 10, 0
    rcpt_dump_evt_lbl:  db "  ", 0
    rcpt_dump_res_lbl:  db " = ", 0
    rcpt_dump_ratio:    db "  HIT/MISS ratio: ", 0
    rcpt_dump_trace_mag: db "  Trace magnitude: ", 0
    rcpt_dump_last_miss: db "  Last miss: ctx=0x", 0
    rcpt_resonate_hdr:  db "[RESONATE] ", 0
    rcpt_resonate_sim:  db " similarity=", 0

    listen_msg:         db "[RECEIPT] Unified holographic trace enabled", 10, 0

    ; Event type names (9 chars each, padded)
    evt_hit:            db "HIT      ", 0
    evt_miss:           db "MISS     ", 0
    evt_new:            db "NEW      ", 0
    evt_learn:          db "LEARN    ", 0
    evt_emit:           db "EMIT     ", 0
    evt_prune:          db "PRUNE    ", 0
    evt_promote:        db "PROMOTE  ", 0
    evt_dream:          db "DREAM    ", 0
    evt_observe:        db "OBSERVE  ", 0
    evt_evolve:         db "EVOLVE   ", 0
    evt_holo_pred:      db "HOLOPRED ", 0
    evt_graph_pred:     db "GRAPHPRED", 0
    evt_journey:        db "JOURNEY  ", 0
    evt_generalize:     db "GENERALIZE", 0
    evt_specialize:     db "SPECIALIZE", 0
    evt_self:           db "SELF     ", 0
    evt_unknown:        db "UNKNOWN  ", 0

    ; Base fidelity table (f64) - indexed by event type
    align 8
    fidelity_table:
        dq 0x3FD3333333333333  ; EVENT_HIT      = 0.30
        dq 0x3FE999999999999A  ; EVENT_MISS     = 0.80
        dq 0x3FE6666666666666  ; EVENT_NEW      = 0.70
        dq 0x3FE999999999999A  ; EVENT_LEARN    = 0.80
        dq 0x3FE6666666666666  ; EVENT_EMIT     = 0.70
        dq 0x3FE0000000000000  ; EVENT_PRUNE    = 0.50
        dq 0x3FE0000000000000  ; EVENT_PROMOTE  = 0.50
        dq 0x3FD999999999999A  ; EVENT_DREAM    = 0.40
        dq 0x3FD999999999999A  ; EVENT_OBSERVE  = 0.40
        dq 0x3FE0000000000000  ; EVENT_EVOLVE   = 0.50
        dq 0x3FD3333333333333  ; EVENT_HOLO_PRED= 0.30
        dq 0x3FD3333333333333  ; EVENT_GRAPH_PRED=0.30
        dq 0x3FD3333333333333  ; EVENT_JOURNEY  = 0.30
        dq 0x3FE6666666666666  ; EVENT_GENERALIZE=0.70 - important for causal
        dq 0x3FE6666666666666  ; EVENT_SPECIALIZE=0.70 - important for causal
        dq 0x3FE999999999999A  ; EVENT_SELF     = 0.80 - self-model violation, high importance

    ; Constants
    align 8
    one_f64:            dq 1.0
    valence_boost:      dq 0.3    ; how much |valence| boosts fidelity
    learning_rate:      dq 0.1    ; base superposition rate

section .bss
    ; Scratch vectors for receipt encoding (f64[1024] = 8KB each)
    ; Need vectors for all 8 dimensions + 1 for result
    align 64
    scratch_event_vec:    resb HOLO_VEC_BYTES
    scratch_ctx_vec:      resb HOLO_VEC_BYTES
    scratch_actual_vec:   resb HOLO_VEC_BYTES   ; actual token
    scratch_predicted_vec: resb HOLO_VEC_BYTES  ; predicted token (key for MISS debug)
    scratch_region_vec:   resb HOLO_VEC_BYTES   ; region/pattern that fired
    scratch_aux_vec:      resb HOLO_VEC_BYTES   ; auxiliary data
    scratch_tracer_vec:   resb HOLO_VEC_BYTES
    scratch_time_vec:     resb HOLO_VEC_BYTES
    scratch_result_vec:   resb HOLO_VEC_BYTES

section .text

extern print_cstr
extern print_hex32
extern print_u64
extern print_f32
extern print_f64
extern print_newline
extern holo_gen_vec
extern holo_bind_f64
extern holo_unbind_f64
extern holo_superpose_f64
extern holo_dot_f64
extern holo_magnitude_f64
extern holo_scale_f64
extern vsa_normalize

;; ============================================================
;; emit_receipt_full(event, ctx, actual, predicted, region, aux, confidence, valence)
;; edi = event_type (u16)
;; esi = ctx_hash (u32)
;; edx = actual_token (u32)
;; ecx = predicted_token (u32) - CRITICAL for MISS debugging
;; r8d = region_hash (u32) - which pattern/region fired
;; r9d = aux_data (u32) - hits, misses, schema level, etc.
;; xmm0 = confidence (f32)
;; xmm1 = valence (f64)
;;
;; Full 8-dimension encoding:
;; bind(event, bind(ctx, bind(actual, bind(predicted, bind(region, bind(aux, bind(tracer, time)))))))
;; ============================================================
global emit_receipt_full
emit_receipt_full:
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub rsp, 72             ; locals: [0]=fidelity, [8]=confidence, [16]=valence
                            ; [24]=event, [28]=ctx, [32]=actual, [36]=predicted
                            ; [40]=region, [44]=aux, [48]=time_bucket, [52-71]=padding

    mov rbx, SURFACE_BASE

    ; === FAST PATH: check listener mask ===
    mov eax, [rbx + STATE_OFFSET + ST_RECEIPT_LISTENER]
    test eax, eax
    jz .fast_return

    ; Save ALL parameters immediately (before any clobber)
    mov [rsp + 24], edi     ; event_type
    mov [rsp + 28], esi     ; ctx_hash
    mov [rsp + 32], edx     ; actual_token
    mov [rsp + 36], ecx     ; predicted_token (THE KEY ONE!)
    mov [rsp + 40], r8d     ; region_hash
    mov [rsp + 44], r9d     ; aux_data
    movss [rsp + 8], xmm0   ; confidence
    movsd [rsp + 16], xmm1  ; valence

    ; Keep frequently used in registers
    mov r12d, edi           ; event_type
    mov r13d, esi           ; ctx_hash
    mov r14d, edx           ; actual_token

    ; Compute time bucket: global_step / TRACE_TIME_BUCKET
    mov rax, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    xor edx, edx
    push rcx                ; save predicted across div
    mov ecx, TRACE_TIME_BUCKET
    div rcx
    pop rcx
    mov [rsp + 48], eax     ; time_bucket

    ; Increment total count
    inc qword [rbx + STATE_OFFSET + ST_RECEIPT_TOTAL]
    mov r15, [rbx + STATE_OFFSET + ST_RECEIPT_TOTAL]

    ; === COMPUTE FIDELITY ===
    movzx eax, r12w
    cmp eax, EVENT_TYPE_COUNT
    jge .use_default_fidelity
    lea rcx, [rel fidelity_table]
    movsd xmm2, [rcx + rax * 8]
    jmp .have_base_fidelity
.use_default_fidelity:
    mov rax, 0x3FE0000000000000   ; 0.5 default
    movq xmm2, rax
.have_base_fidelity:
    movsd xmm3, [rsp + 16]        ; valence
    mov rax, 0x7FFFFFFFFFFFFFFF
    movq xmm4, rax
    andpd xmm3, xmm4              ; |valence|
    mulsd xmm3, [rel valence_boost]
    addsd xmm2, xmm3
    xorpd xmm3, xmm3
    maxsd xmm2, xmm3
    movsd xmm3, [rel one_f64]
    minsd xmm2, xmm3
    movsd [rsp], xmm2             ; store fidelity

    ; === CHECK LISTENER_PRINT ===
    mov eax, [rbx + STATE_OFFSET + ST_RECEIPT_LISTENER]
    test eax, LISTENER_PRINT
    jz .skip_print

    ; Print receipt info (extended format for debugging)
    lea rdi, [rel rcpt_emit_msg]
    call print_cstr
    mov rdi, r15
    call print_u64
    lea rdi, [rel rcpt_event_lbl]
    call print_cstr
    mov edi, r12d
    call get_event_name
    mov rdi, rax
    call print_cstr
    lea rdi, [rel rcpt_ctx_lbl]
    call print_cstr
    mov edi, r13d
    call print_hex32
    lea rdi, [rel rcpt_tok_lbl]
    call print_cstr
    mov edi, r14d
    call print_hex32
    ; Print predicted if non-zero (key for MISS debugging)
    mov edi, [rsp + 36]
    test edi, edi
    jz .skip_predicted_print
    lea rdi, [rel rcpt_pred_lbl]
    call print_cstr
    mov edi, [rsp + 36]
    call print_hex32
.skip_predicted_print:
    lea rdi, [rel rcpt_fid_lbl]
    call print_cstr
    movsd xmm0, [rsp]
    cvtsd2ss xmm0, xmm0
    call print_f32
    call print_newline

.skip_print:
    ; === UPDATE LAST-MISS STATE (for "why" command) ===
    cmp r12w, EVENT_MISS
    jne .skip_last_miss

    ; Store last miss info
    mov [rbx + STATE_OFFSET + ST_LAST_MISS_CTX], r13d      ; ctx_hash
    mov [rbx + STATE_OFFSET + ST_LAST_MISS_ACTUAL], r14d   ; actual_token
    mov eax, [rsp + 36]
    mov [rbx + STATE_OFFSET + ST_LAST_MISS_PRED], eax      ; predicted_token
    mov eax, [rsp + 40]
    mov [rbx + STATE_OFFSET + ST_LAST_MISS_REGION], eax    ; region_hash
    mov eax, [rsp + 44]
    mov [rbx + STATE_OFFSET + ST_LAST_MISS_AUX], eax       ; aux_data
    movss xmm0, [rsp + 8]
    movss [rbx + STATE_OFFSET + ST_LAST_MISS_CONF], xmm0   ; confidence
    mov rax, [rbx + STATE_OFFSET + ST_RECEIPT_TOTAL]       ; use receipt count (guaranteed > 0)
    mov [rbx + STATE_OFFSET + ST_LAST_MISS_STEP], rax      ; step

.skip_last_miss:
    ; === CHECK LISTENER_HOLO (main holographic storage) ===
    mov eax, [rbx + STATE_OFFSET + ST_RECEIPT_LISTENER]
    test eax, LISTENER_HOLO
    jz .fast_return

    ; === ENCODE RECEIPT AS 8-DIMENSIONAL VSA VECTOR ===
    ; Inner to outer: time → tracer → aux → region → predicted → actual → ctx → event

    ; Generate time vector
    mov edi, [rsp + 48]           ; time_bucket
    add edi, TRACE_TIME_SEED
    lea rsi, [rel scratch_time_vec]
    call holo_gen_vec

    ; Generate tracer vector
    mov edi, [rbx + STATE_OFFSET + ST_ACTIVE_TRACER]
    add edi, TRACE_TRACER_SEED
    lea rsi, [rel scratch_tracer_vec]
    call holo_gen_vec

    ; Bind tracer ⊗ time → result
    lea rdi, [rel scratch_tracer_vec]
    lea rsi, [rel scratch_time_vec]
    lea rdx, [rel scratch_result_vec]
    call holo_bind_f64

    ; Generate aux vector
    mov edi, [rsp + 44]           ; aux_data
    add edi, TRACE_AUX_SEED
    lea rsi, [rel scratch_aux_vec]
    call holo_gen_vec

    ; Bind aux ⊗ (tracer⊗time) → result
    lea rdi, [rel scratch_aux_vec]
    lea rsi, [rel scratch_result_vec]
    lea rdx, [rel scratch_result_vec]
    call holo_bind_f64

    ; Generate region vector
    mov edi, [rsp + 40]           ; region_hash
    add edi, TRACE_REGION_SEED
    lea rsi, [rel scratch_region_vec]
    call holo_gen_vec

    ; Bind region ⊗ (aux⊗tracer⊗time) → result
    lea rdi, [rel scratch_region_vec]
    lea rsi, [rel scratch_result_vec]
    lea rdx, [rel scratch_result_vec]
    call holo_bind_f64

    ; Generate predicted vector (THE KEY DIMENSION FOR MISS!)
    mov edi, [rsp + 36]           ; predicted_token
    add edi, TRACE_PREDICTED_SEED
    lea rsi, [rel scratch_predicted_vec]
    call holo_gen_vec

    ; Bind predicted ⊗ (region⊗aux⊗tracer⊗time) → result
    lea rdi, [rel scratch_predicted_vec]
    lea rsi, [rel scratch_result_vec]
    lea rdx, [rel scratch_result_vec]
    call holo_bind_f64

    ; Generate actual vector
    mov edi, r14d                 ; actual_token
    lea rsi, [rel scratch_actual_vec]
    call holo_gen_vec

    ; Bind actual ⊗ (predicted⊗region⊗aux⊗tracer⊗time) → result
    lea rdi, [rel scratch_actual_vec]
    lea rsi, [rel scratch_result_vec]
    lea rdx, [rel scratch_result_vec]
    call holo_bind_f64

    ; Generate context vector
    mov edi, r13d                 ; ctx_hash
    lea rsi, [rel scratch_ctx_vec]
    call holo_gen_vec

    ; Bind ctx ⊗ (actual⊗predicted⊗region⊗aux⊗tracer⊗time) → result
    lea rdi, [rel scratch_ctx_vec]
    lea rsi, [rel scratch_result_vec]
    lea rdx, [rel scratch_result_vec]
    call holo_bind_f64

    ; Generate event vector
    movzx edi, r12w
    add edi, TRACE_EVENT_SEED
    lea rsi, [rel scratch_event_vec]
    call holo_gen_vec

    ; Bind event ⊗ (ctx⊗actual⊗predicted⊗region⊗aux⊗tracer⊗time) → result
    lea rdi, [rel scratch_event_vec]
    lea rsi, [rel scratch_result_vec]
    lea rdx, [rel scratch_result_vec]
    call holo_bind_f64

    ; NORMALIZE: Multiple bindings cause magnitude decay - restore to unit length
    lea rdi, [rel scratch_result_vec]
    call vsa_normalize

    ; === SCALE BY FIDELITY * LEARNING_RATE ===
    movsd xmm0, [rsp]
    mulsd xmm0, [rel learning_rate]
    lea rdi, [rel scratch_result_vec]
    call holo_scale_f64

    ; === SUPERPOSE TO UNIFIED TRACE ===
    mov eax, UNIFIED_TRACE_IDX
    imul rax, rax, HOLO_VEC_BYTES
    mov rdi, rbx
    mov rcx, HOLO_OFFSET              ; use register to avoid sign-extend of 0xC0000000
    add rdi, rcx
    add rdi, rax
    lea rsi, [rel scratch_result_vec]
    call holo_superpose_f64

.fast_return:
    add rsp, 72
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; emit_receipt(event_type, ctx, token, confidence, valence)
;; BACKWARD COMPATIBLE wrapper - calls emit_receipt_full with 0s
;; edi = event_type, esi = ctx, edx = token, xmm0 = confidence, xmm1 = valence
;; ============================================================
global emit_receipt
emit_receipt:
    ; Pass 0 for predicted, region, aux
    xor ecx, ecx              ; predicted = 0
    xor r8d, r8d              ; region = 0
    xor r9d, r9d              ; aux = 0
    jmp emit_receipt_full

;; ============================================================
;; emit_receipt_simple(event_type, ctx, token, confidence)
;; Simplified wrapper - uses current valence from presence
;; edi = event_type, esi = ctx, edx = token, xmm0 = confidence
;; ============================================================
global emit_receipt_simple
emit_receipt_simple:
    push rbx
    mov rbx, SURFACE_BASE
    ; Get current valence from presence field
    movss xmm1, [rbx + STATE_OFFSET + ST_PRESENCE + PRES_VALENCE * 4]
    cvtss2sd xmm1, xmm1           ; convert to f64
    pop rbx
    ; Pass 0 for predicted, region, aux
    xor ecx, ecx              ; predicted = 0
    xor r8d, r8d              ; region = 0
    xor r9d, r9d              ; aux = 0
    jmp emit_receipt_full

;; ============================================================
;; receipt_resonate(event_type, ctx, token) → xmm0 (similarity f64)
;; Query unified trace for similar past receipts.
;; Uses unbind to filter by event type, then dots with ctx/token probe.
;; edi = event_type (or -1 for any event), esi = ctx, edx = token
;; Returns similarity score in xmm0
;; ============================================================
global receipt_resonate
receipt_resonate:
    push rbx
    push r12
    push r13
    push r14
    sub rsp, 8

    mov rbx, SURFACE_BASE
    mov r12d, edi             ; event_type
    mov r13d, esi             ; ctx_hash
    mov r14d, edx             ; token_id

    ; === BUILD PROBE VECTOR ===
    ; If event_type specified: probe = bind(event, bind(ctx, token))
    ; If event_type = -1: probe = bind(ctx, token) (any event)

    ; Generate context vector
    mov edi, r13d
    lea rsi, [rel scratch_ctx_vec]
    call holo_gen_vec

    ; Generate token vector (or neutral if token=0)
    mov edi, r14d
    test edi, edi
    jz .token_neutral
    lea rsi, [rel scratch_actual_vec]
    call holo_gen_vec
    jmp .have_token
.token_neutral:
    ; Token=0 means "any token" - use ctx only as probe
    ; Copy ctx_vec to result (no token binding)
    lea rsi, [rel scratch_ctx_vec]
    lea rdi, [rel scratch_result_vec]
    mov ecx, HOLO_VEC_BYTES
    rep movsb
    jmp .check_event
.have_token:
    ; Bind ctx with token → scratch_result_vec
    lea rdi, [rel scratch_ctx_vec]
    lea rsi, [rel scratch_actual_vec]
    lea rdx, [rel scratch_result_vec]
    call holo_bind_f64

.check_event:
    ; Check if event_type specified
    cmp r12d, -1
    je .no_event_filter

    ; Generate event vector and bind with probe
    movzx edi, r12w
    add edi, TRACE_EVENT_SEED
    lea rsi, [rel scratch_event_vec]
    call holo_gen_vec

    ; Bind event with (ctx⊗token) probe
    lea rdi, [rel scratch_event_vec]
    lea rsi, [rel scratch_result_vec]
    lea rdx, [rel scratch_result_vec]
    call holo_bind_f64

.no_event_filter:
    ; === DOT PRODUCT WITH UNIFIED TRACE ===
    mov eax, UNIFIED_TRACE_IDX
    imul rax, rax, HOLO_VEC_BYTES
    mov rdi, rbx
    mov rcx, HOLO_OFFSET
    add rdi, rcx
    add rdi, rax                  ; unified trace ptr
    lea rsi, [rel scratch_result_vec]
    call holo_dot_f64             ; → xmm0 = similarity

    add rsp, 8
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; trace_set_active(tracer_id)
;; Set the active tracer ID. All subsequent receipts will include this.
;; edi = tracer_id (0 = no tracer)
;; ============================================================
global trace_set_active
trace_set_active:
    mov rax, SURFACE_BASE
    mov [rax + STATE_OFFSET + ST_ACTIVE_TRACER], edi
    ret

;; ============================================================
;; trace_get_active() → eax (tracer_id)
;; Get the currently active tracer ID.
;; ============================================================
global trace_get_active
trace_get_active:
    mov rax, SURFACE_BASE
    mov eax, [rax + STATE_OFFSET + ST_ACTIVE_TRACER]
    ret

;; ============================================================
;; trace_query_journey(tracer_id) → journey in scratch_result_vec
;; Query unified trace for all events with given tracer ID.
;; Returns the "journey vector" - unbind result that resonates
;; with all events from that tracer.
;; edi = tracer_id
;; Returns: xmm0 = magnitude of journey (0 = no events found)
;; ============================================================
global trace_query_journey
trace_query_journey:
    push rbx
    sub rsp, 8

    mov rbx, SURFACE_BASE

    ; Generate tracer vector
    add edi, TRACE_TRACER_SEED
    lea rsi, [rel scratch_tracer_vec]
    call holo_gen_vec

    ; Get unified trace pointer
    mov eax, UNIFIED_TRACE_IDX
    imul rax, rax, HOLO_VEC_BYTES
    mov rdi, rbx
    mov rcx, HOLO_OFFSET
    add rdi, rcx
    add rdi, rax                  ; unified trace ptr

    ; Unbind tracer from unified trace → journey vector
    ; journey = unbind(tracer, trace) = trace ⊗ tracer*
    lea rsi, [rel scratch_tracer_vec]
    lea rdx, [rel scratch_result_vec]
    call holo_unbind_f64

    ; Return magnitude of journey (indicates how much content)
    lea rdi, [rel scratch_result_vec]
    call holo_magnitude_f64       ; → xmm0 = magnitude

    add rsp, 8
    pop rbx
    ret

;; ============================================================
;; trace_journey_has_event(tracer_id, event_type) → xmm0 (similarity)
;; Check if a tracer's journey contains a specific event type.
;; edi = tracer_id, esi = event_type
;; Returns similarity score (high = event occurred in journey)
;; ============================================================
global trace_journey_has_event
trace_journey_has_event:
    push rbx
    push r12
    sub rsp, 8

    mov rbx, SURFACE_BASE
    mov r12d, esi             ; event_type

    ; Get journey vector for this tracer
    call trace_query_journey  ; leaves journey in scratch_result_vec

    ; Generate event vector
    mov edi, r12d
    add edi, TRACE_EVENT_SEED
    lea rsi, [rel scratch_event_vec]
    call holo_gen_vec

    ; Dot product: how much does journey resonate with this event?
    lea rdi, [rel scratch_result_vec]
    lea rsi, [rel scratch_event_vec]
    call holo_dot_f64         ; → xmm0 = similarity

    add rsp, 8
    pop r12
    pop rbx
    ret

;; ============================================================
;; receipt_listen(mask)
;; edi = listener bitmask to enable
;; ============================================================
global receipt_listen
receipt_listen:
    mov rax, SURFACE_BASE
    or [rax + STATE_OFFSET + ST_RECEIPT_LISTENER], edi
    ret

;; ============================================================
;; receipt_mute(mask)
;; edi = listener bitmask to disable
;; ============================================================
global receipt_mute
receipt_mute:
    mov rax, SURFACE_BASE
    not edi
    and [rax + STATE_OFFSET + ST_RECEIPT_LISTENER], edi
    ret

;; ============================================================
;; receipt_dump(count)
;; Query holographic trace and show event resonance levels.
;; edi = ignored (kept for API compat)
;; Shows: event type resonance, hit/miss ratio, last miss
;; ============================================================
global receipt_dump
receipt_dump:
    push rbx
    push r12
    sub rsp, 8                ; 2 pushes (even) + 8 = aligned

    mov rbx, SURFACE_BASE

    ; Print header
    lea rdi, [rel rcpt_dump_trace_hdr]
    call print_cstr

    ; Query and print resonance for each event type
    xor r12d, r12d            ; event counter

.event_loop:
    cmp r12d, EVENT_TYPE_COUNT
    jge .event_done

    ; Print event name
    lea rdi, [rel rcpt_dump_evt_lbl]
    call print_cstr
    mov edi, r12d
    call get_event_name
    mov rdi, rax
    call print_cstr

    ; Query trace_event_count for this event type
    mov edi, r12d
    call trace_event_count    ; xmm0 = resonance magnitude
    lea rdi, [rel rcpt_dump_res_lbl]
    call print_cstr
    cvtsd2ss xmm0, xmm0
    call print_f32
    call print_newline

    inc r12d
    jmp .event_loop

.event_done:
    ; Print separator
    call print_newline

    ; Show raw trace magnitude (diagnostic)
    lea rdi, [rel rcpt_dump_trace_mag]
    call print_cstr
    mov eax, UNIFIED_TRACE_IDX
    imul rax, rax, HOLO_VEC_BYTES
    mov rdi, rbx
    mov rcx, HOLO_OFFSET              ; use register to avoid sign-extend
    add rdi, rcx
    add rdi, rax
    call holo_magnitude_f64
    cvtsd2ss xmm0, xmm0
    call print_f32
    call print_newline

    ; Show system hit/miss ratio
    lea rdi, [rel rcpt_dump_ratio]
    call print_cstr
    call trace_hit_miss_ratio
    cvtsd2ss xmm0, xmm0
    call print_f32
    call print_newline

    ; Show last miss if any
    mov rax, [rbx + STATE_OFFSET + ST_LAST_MISS_STEP]
    test rax, rax
    jz .no_last_miss

    lea rdi, [rel rcpt_dump_last_miss]
    call print_cstr
    mov edi, [rbx + STATE_OFFSET + ST_LAST_MISS_CTX]
    call print_hex32
    lea rdi, [rel arrow_str]
    call print_cstr
    mov edi, [rbx + STATE_OFFSET + ST_LAST_MISS_PRED]
    call print_hex32
    lea rdi, [rel actual_str]
    call print_cstr
    mov edi, [rbx + STATE_OFFSET + ST_LAST_MISS_ACTUAL]
    call print_hex32
    lea rdi, [rel close_paren]
    call print_cstr

.no_last_miss:
    add rsp, 8
    pop r12
    pop rbx
    ret

;; ============================================================
;; receipt_init
;; Initialize receipt system (holographic trace + last-miss state)
;; ============================================================
global receipt_init
receipt_init:
    mov rax, SURFACE_BASE
    ; Clear last-miss state
    mov qword [rax + STATE_OFFSET + ST_LAST_MISS], 0
    mov qword [rax + STATE_OFFSET + ST_LAST_MISS + 8], 0
    mov qword [rax + STATE_OFFSET + ST_LAST_MISS + 16], 0
    mov qword [rax + STATE_OFFSET + ST_LAST_MISS + 24], 0
    ; Initialize counters
    mov qword [rax + STATE_OFFSET + ST_RECEIPT_TOTAL], 0
    mov dword [rax + STATE_OFFSET + ST_ACTIVE_TRACER], 0
    ; Enable holographic storage and print (no working buffer)
    mov dword [rax + STATE_OFFSET + ST_RECEIPT_LISTENER], LISTENER_HOLO | LISTENER_PRINT
    ret

;; ============================================================
;; get_event_name(event_type) → rax (string ptr)
;; ============================================================
get_event_name:
    cmp edi, EVENT_HIT
    je .e_hit
    cmp edi, EVENT_MISS
    je .e_miss
    cmp edi, EVENT_NEW
    je .e_new
    cmp edi, EVENT_LEARN
    je .e_learn
    cmp edi, EVENT_EMIT
    je .e_emit
    cmp edi, EVENT_PRUNE
    je .e_prune
    cmp edi, EVENT_PROMOTE
    je .e_promote
    cmp edi, EVENT_DREAM
    je .e_dream
    cmp edi, EVENT_OBSERVE
    je .e_observe
    cmp edi, EVENT_EVOLVE
    je .e_evolve
    cmp edi, EVENT_HOLO_PRED
    je .e_holo_pred
    cmp edi, EVENT_GRAPH_PRED
    je .e_graph_pred
    cmp edi, EVENT_JOURNEY
    je .e_journey
    lea rax, [rel evt_unknown]
    ret
.e_hit:
    lea rax, [rel evt_hit]
    ret
.e_miss:
    lea rax, [rel evt_miss]
    ret
.e_new:
    lea rax, [rel evt_new]
    ret
.e_learn:
    lea rax, [rel evt_learn]
    ret
.e_emit:
    lea rax, [rel evt_emit]
    ret
.e_prune:
    lea rax, [rel evt_prune]
    ret
.e_promote:
    lea rax, [rel evt_promote]
    ret
.e_dream:
    lea rax, [rel evt_dream]
    ret
.e_observe:
    lea rax, [rel evt_observe]
    ret
.e_evolve:
    lea rax, [rel evt_evolve]
    ret
.e_holo_pred:
    lea rax, [rel evt_holo_pred]
    ret
.e_graph_pred:
    lea rax, [rel evt_graph_pred]
    ret
.e_journey:
    lea rax, [rel evt_journey]
    ret

;; ============================================================
;; QUERY COMMANDS - "No more guessing" interface
;; ============================================================

section .data
    why_hdr:        db "[WHY-MISS] Last prediction failure:", 10, 0
    why_ctx:        db "  Context:   0x", 0
    why_actual:     db "  Actual:    0x", 0
    why_predicted:  db "  Predicted: 0x", 0
    why_region:     db "  Region:    0x", 0
    why_runner:     db "  Runner-up: 0x", 0
    why_conf:       db "  Confidence: ", 0
    why_none:       db "[WHY-MISS] No misses in recent history.", 10, 0
    misses_hdr:     db "[MISSES] Last ", 0
    misses_mid:     db " prediction failures:", 10, 0
    misses_none:    db "[MISSES] No misses found.", 10, 0
    misses_hdr_new: db "[MISSES] Last miss + trace resonance:", 10, 0
    misses_trace_ctx: db "  Context confusion: ", 0
    misses_trace_sys: db "  System confusion:  ", 0
    miss_line:      db "  ", 0
    arrow_str:      db " -> predicted ", 0
    actual_str:     db " (actual: ", 0
    close_paren:    db ")", 10, 0

section .text

;; ============================================================
;; receipt_why_miss()
;; Explain the most recent MISS - what was predicted vs actual
;; The answer to "why did it fail?"
;; Reads from ST_LAST_MISS_* (single record, no buffer scanning)
;; ============================================================
global receipt_why_miss
receipt_why_miss:
    push rbx
    sub rsp, 8                    ; 1 push (odd) + 8 = aligned

    mov rbx, SURFACE_BASE

    ; Check if there's been a miss (step > 0)
    mov rax, [rbx + STATE_OFFSET + ST_LAST_MISS_STEP]
    test rax, rax
    jz .why_not_found

    ; Print header
    lea rdi, [rel why_hdr]
    call print_cstr

    ; Context
    lea rdi, [rel why_ctx]
    call print_cstr
    mov edi, [rbx + STATE_OFFSET + ST_LAST_MISS_CTX]
    call print_hex32
    call print_newline

    ; Actual token
    lea rdi, [rel why_actual]
    call print_cstr
    mov edi, [rbx + STATE_OFFSET + ST_LAST_MISS_ACTUAL]
    call print_hex32
    call print_newline

    ; Predicted token (THE KEY!)
    lea rdi, [rel why_predicted]
    call print_cstr
    mov edi, [rbx + STATE_OFFSET + ST_LAST_MISS_PRED]
    call print_hex32
    call print_newline

    ; Region hash
    lea rdi, [rel why_region]
    call print_cstr
    mov edi, [rbx + STATE_OFFSET + ST_LAST_MISS_REGION]
    call print_hex32
    call print_newline

    ; Runner-up (aux)
    lea rdi, [rel why_runner]
    call print_cstr
    mov edi, [rbx + STATE_OFFSET + ST_LAST_MISS_AUX]
    call print_hex32
    call print_newline

    ; Confidence
    lea rdi, [rel why_conf]
    call print_cstr
    movss xmm0, [rbx + STATE_OFFSET + ST_LAST_MISS_CONF]
    call print_f32
    call print_newline

    jmp .why_done

.why_not_found:
    lea rdi, [rel why_none]
    call print_cstr

.why_done:
    add rsp, 8
    pop rbx
    ret

;; ============================================================
;; receipt_show_misses(count)
;; Show last miss + holographic trace resonance for context
;; edi = count (ignored - only last miss tracked, trace has history)
;; ============================================================
global receipt_show_misses
receipt_show_misses:
    push rbx
    push r12
    sub rsp, 8                    ; 2 pushes (even) + 8 = aligned

    mov rbx, SURFACE_BASE

    ; Print header
    lea rdi, [rel misses_hdr_new]
    call print_cstr

    ; Check if we have a last miss
    mov rax, [rbx + STATE_OFFSET + ST_LAST_MISS_STEP]
    test rax, rax
    jz .misses_none_found

    ; Save last miss ctx for trace query
    mov r12d, [rbx + STATE_OFFSET + ST_LAST_MISS_CTX]

    ; Print last miss: "  ctx -> predicted 0x... (actual: 0x...)"
    lea rdi, [rel miss_line]
    call print_cstr
    mov edi, r12d
    call print_hex32
    lea rdi, [rel arrow_str]
    call print_cstr
    mov edi, [rbx + STATE_OFFSET + ST_LAST_MISS_PRED]
    call print_hex32
    lea rdi, [rel actual_str]
    call print_cstr
    mov edi, [rbx + STATE_OFFSET + ST_LAST_MISS_ACTUAL]
    call print_hex32
    lea rdi, [rel close_paren]
    call print_cstr

    ; Query trace for MISS resonance at this context
    lea rdi, [rel misses_trace_ctx]
    call print_cstr
    mov edi, r12d                 ; last miss ctx
    call trace_context_confidence ; xmm0 = HIT/(HIT+MISS) ratio
    ; Invert to get confusion: 1 - confidence
    mov rax, 0x3FF0000000000000   ; 1.0 f64
    movq xmm1, rax
    subsd xmm1, xmm0              ; confusion = 1 - confidence
    cvtsd2ss xmm0, xmm1
    call print_f32
    call print_newline

    ; Query system-wide MISS resonance
    lea rdi, [rel misses_trace_sys]
    call print_cstr
    call trace_hit_miss_ratio     ; xmm0 = system HIT/(HIT+MISS)
    ; Invert to get confusion
    mov rax, 0x3FF0000000000000
    movq xmm1, rax
    subsd xmm1, xmm0
    cvtsd2ss xmm0, xmm1
    call print_f32
    call print_newline

    jmp .misses_done

.misses_none_found:
    lea rdi, [rel misses_none]
    call print_cstr

.misses_done:
    add rsp, 8
    pop r12
    pop rbx
    ret

;; ============================================================
;; INTROSPECTIVE STATE - Query self-model via unified trace
;; "How am I feeling in this context?"
;; ============================================================

section .data
    intro_hdr:          db "[INTRO] Current context introspection:", 10, 0
    intro_confused:     db "  CONFUSED:   ", 0
    intro_confident:    db "  CONFIDENT:  ", 0
    intro_learning:     db "  LEARNING:   ", 0
    intro_self_surprise: db "  SELF-SURPRISE: ", 0
    intro_self_aware:   db "  SELF-AWARE: ", 0
    intro_state:        db "  STATE:      ", 0
    intro_state_confused:   db "CONFUSED (high miss resonance)", 10, 0
    intro_state_confident:  db "CONFIDENT (high hit resonance)", 10, 0
    intro_state_learning:   db "LEARNING (high learn resonance)", 10, 0
    intro_state_neutral:    db "NEUTRAL (no dominant pattern)", 10, 0

section .text

;; ============================================================
;; intro_query_confusion(ctx) -> xmm0 (f64)
;; How confused am I in this context? (MISS resonance)
;; edi = ctx_hash
;; ============================================================
global intro_query_confusion
intro_query_confusion:
    mov esi, edi              ; ctx
    mov edi, EVENT_MISS
    xor edx, edx              ; any token
    jmp receipt_resonate

;; ============================================================
;; intro_query_confidence(ctx) -> xmm0 (f64)
;; How confident am I in this context? (HIT resonance)
;; edi = ctx_hash
;; ============================================================
global intro_query_confidence
intro_query_confidence:
    mov esi, edi              ; ctx
    mov edi, EVENT_HIT
    xor edx, edx              ; any token
    jmp receipt_resonate

;; ============================================================
;; intro_query_learning(ctx) -> xmm0 (f64)
;; Am I actively learning in this context? (LEARN resonance)
;; edi = ctx_hash
;; ============================================================
global intro_query_learning
intro_query_learning:
    mov esi, edi              ; ctx
    mov edi, EVENT_LEARN
    xor edx, edx              ; any token
    jmp receipt_resonate

;; ============================================================
;; intro_query_self_surprise(ctx) -> xmm0 (f64)
;; Was I surprised about my own self-model? (EVENT_SELF resonance)
;; This is the core self-awareness query: self-error vs world-error.
;; edi = ctx_hash
;; ============================================================
global intro_query_self_surprise
intro_query_self_surprise:
    mov esi, edi              ; ctx
    mov edi, EVENT_SELF
    xor edx, edx              ; any token
    jmp receipt_resonate

;; ============================================================
;; intro_get_self_awareness() -> xmm0 (f64)
;; Compute self-awareness ratio: self_surprise / total_miss
;; High ratio = more errors are about self-model, not world
;; Returns: 0.0-1.0 normalized self-awareness score
;; ============================================================
global intro_get_self_awareness
intro_get_self_awareness:
    push rbx
    push r12
    sub rsp, 24               ; [0]=self_surprise, [8]=total_miss, [16]=pad

    mov rbx, SURFACE_BASE

    ; Query self-surprise resonance (EVENT_SELF)
    mov edi, EVENT_SELF
    xor esi, esi              ; any context
    xor edx, edx              ; any token
    call receipt_resonate
    movsd [rsp], xmm0         ; save self_surprise

    ; Query total miss resonance (EVENT_MISS)
    mov edi, EVENT_MISS
    xor esi, esi
    xor edx, edx
    call receipt_resonate
    movsd [rsp + 8], xmm0     ; save total_miss

    ; Self-awareness = self_surprise / (total_miss + epsilon)
    movsd xmm0, [rsp]         ; self_surprise
    movsd xmm1, [rsp + 8]     ; total_miss
    mov rax, 0x3F1A36E2EB1C432D  ; epsilon = 0.0001
    movq xmm2, rax
    addsd xmm1, xmm2          ; avoid div by zero
    divsd xmm0, xmm1          ; ratio

    ; Clamp to [0.0, 1.0]
    xorpd xmm2, xmm2          ; 0.0
    maxsd xmm0, xmm2
    mov rax, 0x3FF0000000000000  ; 1.0
    movq xmm2, rax
    minsd xmm0, xmm2

    add rsp, 24
    pop r12
    pop rbx
    ret

;; ============================================================
;; intro_get_state(ctx) -> eax=state_id, xmm0=strength
;; Which introspective state dominates current context?
;; edi = ctx_hash (or 0 to use ST_CTX_HASH)
;; Returns: eax = INTRO_* enum, xmm0 = dominant resonance strength
;; ============================================================
global intro_get_state
intro_get_state:
    push rbx
    push r12
    push r13
    push r14
    sub rsp, 40               ; [0]=ctx, [8]=confused, [16]=confident, [24]=learning, [32]=padding

    mov rbx, SURFACE_BASE

    ; Get context hash (use current if not provided)
    test edi, edi
    jnz .have_ctx
    mov edi, [rbx + STATE_OFFSET + ST_CTX_HASH]
.have_ctx:
    mov [rsp], edi            ; save ctx

    ; Query confusion (MISS resonance)
    call intro_query_confusion
    movsd [rsp + 8], xmm0

    ; Query confidence (HIT resonance)
    mov edi, [rsp]
    call intro_query_confidence
    movsd [rsp + 16], xmm0

    ; Query learning (LEARN resonance)
    mov edi, [rsp]
    call intro_query_learning
    movsd [rsp + 24], xmm0

    ; Find dominant state
    movsd xmm0, [rsp + 8]     ; confused
    movsd xmm1, [rsp + 16]    ; confident
    movsd xmm2, [rsp + 24]    ; learning
    mov eax, INTRO_CONFUSED
    movsd xmm3, xmm0          ; max = confused

    ucomisd xmm1, xmm3
    jbe .check_learning
    mov eax, INTRO_CONFIDENT
    movsd xmm3, xmm1

.check_learning:
    ucomisd xmm2, xmm3
    jbe .have_state
    mov eax, INTRO_LEARNING
    movsd xmm3, xmm2

.have_state:
    ; Check if any resonance is significant (> 0.01)
    mov rcx, 0x3F847AE147AE147B  ; 0.01 f64
    movq xmm4, rcx
    ucomisd xmm3, xmm4
    ja .state_done
    mov eax, INTRO_IDLE       ; no significant pattern

.state_done:
    movsd xmm0, xmm3          ; return strength in xmm0
    add rsp, 40
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; intro_report(ctx) -> void
;; Print introspective state report for context.
;; edi = ctx_hash (or 0 to use current)
;; REPL "intro" command implementation.
;; ============================================================
global intro_report
intro_report:
    push rbx
    push r12
    push r13
    push r14
    sub rsp, 40

    mov rbx, SURFACE_BASE

    ; Get context hash
    test edi, edi
    jnz .have_ctx
    mov edi, [rbx + STATE_OFFSET + ST_CTX_HASH]
.have_ctx:
    mov r12d, edi             ; save ctx
    mov [rsp], edi

    ; Print header
    lea rdi, [rel intro_hdr]
    call print_cstr

    ; Query and print confusion
    lea rdi, [rel intro_confused]
    call print_cstr
    mov edi, r12d
    call intro_query_confusion
    movsd [rsp + 8], xmm0
    cvtsd2ss xmm0, xmm0
    call print_f32
    call print_newline

    ; Query and print confidence
    lea rdi, [rel intro_confident]
    call print_cstr
    mov edi, r12d
    call intro_query_confidence
    movsd [rsp + 16], xmm0
    cvtsd2ss xmm0, xmm0
    call print_f32
    call print_newline

    ; Query and print learning
    lea rdi, [rel intro_learning]
    call print_cstr
    mov edi, r12d
    call intro_query_learning
    movsd [rsp + 24], xmm0
    cvtsd2ss xmm0, xmm0
    call print_f32
    call print_newline

    ; Query and print self-surprise (self-awareness metric)
    lea rdi, [rel intro_self_surprise]
    call print_cstr
    mov edi, r12d
    call intro_query_self_surprise
    movsd [rsp + 32], xmm0
    cvtsd2ss xmm0, xmm0
    call print_f32
    call print_newline

    ; Print overall self-awareness ratio
    lea rdi, [rel intro_self_aware]
    call print_cstr
    call intro_get_self_awareness
    cvtsd2ss xmm0, xmm0
    call print_f32
    call print_newline

    ; Get dominant state and print
    lea rdi, [rel intro_state]
    call print_cstr

    mov edi, r12d
    call intro_get_state      ; eax = state, xmm0 = strength

    cmp eax, INTRO_CONFUSED
    je .print_confused
    cmp eax, INTRO_CONFIDENT
    je .print_confident
    cmp eax, INTRO_LEARNING
    je .print_learning
    lea rdi, [rel intro_state_neutral]
    jmp .print_state

.print_confused:
    lea rdi, [rel intro_state_confused]
    jmp .print_state
.print_confident:
    lea rdi, [rel intro_state_confident]
    jmp .print_state
.print_learning:
    lea rdi, [rel intro_state_learning]
.print_state:
    call print_cstr

    add rsp, 40
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; SEMANTIC SELF-KNOWLEDGE - Query trace for context-type strengths/weaknesses
;; Context types = high 4 bits of ctx_hash (16 types)
;; ============================================================

section .data
    self_ctx_hdr:       db "[SELF] Context-type confidence (from trace):", 10, 0
    self_strength_lbl:  db "  STRENGTH: type 0x", 0
    self_weakness_lbl:  db "  WEAKNESS: type 0x", 0
    self_conf_lbl:      db " = ", 0
    strength_thresh:    dq 0.7    ; above = strength
    weakness_thresh:    dq 0.3    ; below = weakness

section .text

;; ============================================================
;; self_show_context_types() -> void
;; Scan 16 context types via trace_context_confidence, show strengths/weaknesses.
;; Called by REPL "self" command.
;; ============================================================
global self_show_context_types
self_show_context_types:
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub rsp, 8                ; 5 pushes (odd) + 8 = 16-aligned

    xor r12d, r12d            ; ctx_type counter 0..15
    xor r14d, r14d            ; strengths found
    xor r15d, r15d            ; weaknesses found

    ; Print header
    lea rdi, [rel self_ctx_hdr]
    call print_cstr

.type_loop:
    cmp r12d, 16
    jge .done

    ; Generate ctx_hash = (type << 28) | 0x0FFFFFFF (representative hash)
    mov edi, r12d
    shl edi, 28
    or edi, 0x0FFFFFFF
    mov r13d, edi             ; save ctx_hash

    ; Query trace_context_confidence
    call trace_context_confidence  ; xmm0 = confidence (f64)

    ; Check if strength (> 0.7)
    movsd xmm1, [rel strength_thresh]
    ucomisd xmm0, xmm1
    jbe .check_weakness

    ; Print strength
    push r12
    movsd xmm2, xmm0          ; save confidence
    lea rdi, [rel self_strength_lbl]
    call print_cstr
    mov edi, r12d             ; type
    call print_hex32
    lea rdi, [rel self_conf_lbl]
    call print_cstr
    movsd xmm0, xmm2
    cvtsd2ss xmm0, xmm0
    call print_f32
    call print_newline
    pop r12
    inc r14d
    jmp .next_type

.check_weakness:
    ; Check if weakness (< 0.3)
    movsd xmm1, [rel weakness_thresh]
    ucomisd xmm0, xmm1
    jae .next_type

    ; But only if there's actually signal (confidence > 0.01)
    mov rax, 0x3F847AE147AE147B  ; 0.01 f64
    movq xmm1, rax
    ucomisd xmm0, xmm1
    jbe .next_type            ; no signal = ignore

    ; Print weakness
    push r12
    movsd xmm2, xmm0
    lea rdi, [rel self_weakness_lbl]
    call print_cstr
    mov edi, r12d
    call print_hex32
    lea rdi, [rel self_conf_lbl]
    call print_cstr
    movsd xmm0, xmm2
    cvtsd2ss xmm0, xmm0
    call print_f32
    call print_newline
    pop r12
    inc r15d

.next_type:
    inc r12d
    jmp .type_loop

.done:
    ; Return counts: eax = strengths, edx = weaknesses
    mov eax, r14d
    mov edx, r15d

    add rsp, 8
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; CAUSAL MODEL - Query what modifications work in which contexts
;; Based on historical PRUNE/PROMOTE/GENERALIZE/SPECIALIZE receipts
;; ============================================================

section .data
    causal_hdr:         db "[CAUSAL] Modification history from trace:", 10, 0
    causal_prune_lbl:   db "  PRUNE:      ", 0
    causal_promote_lbl: db "  PROMOTE:    ", 0
    causal_general_lbl: db "  GENERALIZE: ", 0
    causal_special_lbl: db "  SPECIALIZE: ", 0
    causal_resonance:   db " resonance=", 0
    causal_no_data:     db "(no history)", 10, 0
    causal_helps:       db " (helps)", 10, 0
    causal_hurts:       db " (hurts)", 10, 0
    causal_neutral:     db " (neutral)", 10, 0
    causal_signal_thresh: dq 0.01  ; below = no signal

section .text

;; ============================================================
;; causal_query_modification(mod_type, ctx) -> xmm0=resonance
;; Query trace for historical effect of modification type in context.
;; edi = modification event type (EVENT_PRUNE, EVENT_PROMOTE, etc.)
;; esi = ctx_hash (0 = use current)
;; Returns: xmm0 = resonance strength (how much history for this mod+ctx)
;; ============================================================
global causal_query_modification
causal_query_modification:
    push rbx
    sub rsp, 8

    mov rbx, SURFACE_BASE

    ; Use current context if not specified
    test esi, esi
    jnz .have_ctx
    mov esi, [rbx + STATE_OFFSET + ST_CTX_HASH]
.have_ctx:
    xor edx, edx              ; token = 0 (any)
    call receipt_resonate     ; xmm0 = resonance

    add rsp, 8
    pop rbx
    ret

;; ============================================================
;; causal_report(ctx) -> void
;; Print causal model report for context - what modifications have history.
;; edi = ctx_hash (0 = use current)
;; REPL "causal" command implementation.
;; ============================================================
global causal_report
causal_report:
    push rbx
    push r12
    push r13
    sub rsp, 8                ; 3 pushes (odd) + 8 = 16-aligned

    mov rbx, SURFACE_BASE

    ; Get context hash
    test edi, edi
    jnz .have_ctx
    mov edi, [rbx + STATE_OFFSET + ST_CTX_HASH]
.have_ctx:
    mov r12d, edi             ; save ctx

    ; Print header
    lea rdi, [rel causal_hdr]
    call print_cstr

    ; Query PRUNE
    lea rdi, [rel causal_prune_lbl]
    call print_cstr
    mov edi, EVENT_PRUNE
    mov esi, r12d
    call causal_query_modification
    movsd xmm1, xmm0          ; save resonance
    call .print_resonance_result

    ; Query PROMOTE
    lea rdi, [rel causal_promote_lbl]
    call print_cstr
    mov edi, EVENT_PROMOTE
    mov esi, r12d
    call causal_query_modification
    movsd xmm1, xmm0
    call .print_resonance_result

    ; Query GENERALIZE
    lea rdi, [rel causal_general_lbl]
    call print_cstr
    mov edi, EVENT_GENERALIZE
    mov esi, r12d
    call causal_query_modification
    movsd xmm1, xmm0
    call .print_resonance_result

    ; Query SPECIALIZE
    lea rdi, [rel causal_special_lbl]
    call print_cstr
    mov edi, EVENT_SPECIALIZE
    mov esi, r12d
    call causal_query_modification
    movsd xmm1, xmm0
    call .print_resonance_result

    add rsp, 8
    pop r13
    pop r12
    pop rbx
    ret

; Helper: print resonance result with interpretation
; xmm1 = resonance value
.print_resonance_result:
    push rbx
    sub rsp, 16
    movsd [rsp], xmm1

    ; Check if significant signal
    movsd xmm0, [rel causal_signal_thresh]
    ucomisd xmm1, xmm0
    ja .has_signal

    ; No data
    lea rdi, [rel causal_no_data]
    call print_cstr
    jmp .result_done

.has_signal:
    lea rdi, [rel causal_resonance]
    call print_cstr
    movsd xmm0, [rsp]
    cvtsd2ss xmm0, xmm0
    call print_f32

    ; Interpret: high resonance = more history, interpret based on modification type
    ; For now, just indicate presence of history
    movsd xmm0, [rsp]
    mov rax, 0x3FD0000000000000  ; 0.25 threshold
    movq xmm1, rax
    ucomisd xmm0, xmm1
    jbe .neutral_result
    lea rdi, [rel causal_helps]
    jmp .print_interp
.neutral_result:
    lea rdi, [rel causal_neutral]
.print_interp:
    call print_cstr

.result_done:
    add rsp, 16
    pop rbx
    ret

;; ============================================================
;; META-STRATEGY - Use causal history to guide repair decisions
;; ============================================================

section .data
    meta_strat_thresh:  dq 0.05   ; minimum resonance to consider

section .text

;; ============================================================
;; meta_recommend_strategy(ctx) -> eax=strategy
;; Based on causal history, what modification should we do here?
;; edi = ctx_hash (0 = use current)
;; Returns: eax = recommended event type (EVENT_GENERALIZE, EVENT_SPECIALIZE, or 0 if no data)
;; ============================================================
global meta_recommend_strategy
meta_recommend_strategy:
    push rbx
    push r12
    push r13
    push r14
    sub rsp, 40               ; [0]=ctx, [8]=gen_res, [16]=spec_res, [24]=prune_res, [32]=promote_res

    mov rbx, SURFACE_BASE

    ; Get context hash
    test edi, edi
    jnz .have_ctx
    mov edi, [rbx + STATE_OFFSET + ST_CTX_HASH]
.have_ctx:
    mov [rsp], edi            ; save ctx
    mov r12d, edi

    ; Query GENERALIZE resonance
    mov edi, EVENT_GENERALIZE
    mov esi, r12d
    call causal_query_modification
    movsd [rsp + 8], xmm0

    ; Query SPECIALIZE resonance
    mov edi, EVENT_SPECIALIZE
    mov esi, r12d
    call causal_query_modification
    movsd [rsp + 16], xmm0

    ; Query PRUNE resonance
    mov edi, EVENT_PRUNE
    mov esi, r12d
    call causal_query_modification
    movsd [rsp + 24], xmm0

    ; Query PROMOTE resonance
    mov edi, EVENT_PROMOTE
    mov esi, r12d
    call causal_query_modification
    movsd [rsp + 32], xmm0

    ; Find highest resonance (most historical evidence)
    movsd xmm0, [rsp + 8]     ; generalize
    movsd xmm1, [rsp + 16]    ; specialize
    movsd xmm2, [rsp + 24]    ; prune
    movsd xmm3, [rsp + 32]    ; promote

    mov eax, EVENT_GENERALIZE
    movsd xmm4, xmm0          ; max = generalize

    ucomisd xmm1, xmm4
    jbe .check_prune
    mov eax, EVENT_SPECIALIZE
    movsd xmm4, xmm1

.check_prune:
    ucomisd xmm2, xmm4
    jbe .check_promote
    mov eax, EVENT_PRUNE
    movsd xmm4, xmm2

.check_promote:
    ucomisd xmm3, xmm4
    jbe .check_thresh
    mov eax, EVENT_PROMOTE
    movsd xmm4, xmm3

.check_thresh:
    ; Check if any resonance is significant
    movsd xmm5, [rel meta_strat_thresh]
    ucomisd xmm4, xmm5
    ja .have_strategy
    xor eax, eax              ; no significant history, return 0

.have_strategy:
    add rsp, 40
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; COGNITIVE ACCESS - System queries its own trace for self-improvement
;; ============================================================

section .data
    perf_low_thresh: dq 0.3   ; below this = bad region

section .text

;; ============================================================
;; trace_region_performance(region_hash) → xmm0 (performance 0.0-1.0)
;; Query unified trace for HIT vs MISS ratio for given region.
;; Returns hit_resonance / (hit_resonance + miss_resonance + epsilon)
;; Used by pruning logic to identify underperforming regions.
;; edi = region_hash
;; ============================================================
global trace_region_performance
trace_region_performance:
    push rbx
    push r12
    sub rsp, 24           ; [0]=region_hash, [8]=hit_score, [16]=miss_score

    mov rbx, SURFACE_BASE
    mov [rsp], edi        ; save region_hash

    ; === Query HIT + region ===
    ; Generate event vector for HIT
    mov edi, EVENT_HIT
    add edi, TRACE_EVENT_SEED
    lea rsi, [rel scratch_event_vec]
    call holo_gen_vec

    ; Generate region vector
    mov edi, [rsp]
    add edi, TRACE_REGION_SEED
    lea rsi, [rel scratch_region_vec]
    call holo_gen_vec

    ; Bind event ⊗ region → probe
    lea rdi, [rel scratch_event_vec]
    lea rsi, [rel scratch_region_vec]
    lea rdx, [rel scratch_result_vec]
    call holo_bind_f64

    ; Dot with unified trace
    mov eax, UNIFIED_TRACE_IDX
    imul rax, rax, HOLO_VEC_BYTES
    mov rdi, rbx
    mov rcx, HOLO_OFFSET
    add rdi, rcx
    add rdi, rax
    lea rsi, [rel scratch_result_vec]
    call holo_dot_f64
    ; Clamp negative to zero
    xorpd xmm1, xmm1
    maxsd xmm0, xmm1
    movsd [rsp + 8], xmm0     ; hit_score

    ; === Query MISS + region ===
    mov edi, EVENT_MISS
    add edi, TRACE_EVENT_SEED
    lea rsi, [rel scratch_event_vec]
    call holo_gen_vec

    ; Region already generated, bind again
    lea rdi, [rel scratch_event_vec]
    lea rsi, [rel scratch_region_vec]
    lea rdx, [rel scratch_result_vec]
    call holo_bind_f64

    ; Dot with unified trace
    mov eax, UNIFIED_TRACE_IDX
    imul rax, rax, HOLO_VEC_BYTES
    mov rdi, rbx
    mov rcx, HOLO_OFFSET
    add rdi, rcx
    add rdi, rax
    lea rsi, [rel scratch_result_vec]
    call holo_dot_f64
    xorpd xmm1, xmm1
    maxsd xmm0, xmm1
    movsd [rsp + 16], xmm0    ; miss_score

    ; === Compute performance = hit / (hit + miss + epsilon) ===
    movsd xmm0, [rsp + 8]     ; hit
    movsd xmm1, [rsp + 16]    ; miss
    addsd xmm1, xmm0          ; hit + miss
    mov rax, 0x3EB0C6F7A0B5ED8D  ; epsilon = 1e-6
    movq xmm2, rax
    addsd xmm1, xmm2          ; hit + miss + epsilon
    divsd xmm0, xmm1          ; performance = hit / total

    add rsp, 24
    pop r12
    pop rbx
    ret

;; ============================================================
;; trace_context_confidence(ctx_hash) → xmm0 (confidence 0.0-1.0)
;; Query trace for historical HIT rate in given context.
;; High = system has been accurate here, low = unreliable context.
;; edi = ctx_hash
;; ============================================================
global trace_context_confidence
trace_context_confidence:
    push rbx
    sub rsp, 24           ; [0]=ctx_hash, [8]=hit_score, [16]=miss_score

    mov rbx, SURFACE_BASE
    mov [rsp], edi

    ; === Query HIT + ctx ===
    mov edi, EVENT_HIT
    add edi, TRACE_EVENT_SEED
    lea rsi, [rel scratch_event_vec]
    call holo_gen_vec

    mov edi, [rsp]        ; ctx_hash (raw, no seed for ctx)
    lea rsi, [rel scratch_ctx_vec]
    call holo_gen_vec

    lea rdi, [rel scratch_event_vec]
    lea rsi, [rel scratch_ctx_vec]
    lea rdx, [rel scratch_result_vec]
    call holo_bind_f64

    mov eax, UNIFIED_TRACE_IDX
    imul rax, rax, HOLO_VEC_BYTES
    mov rdi, rbx
    mov rcx, HOLO_OFFSET
    add rdi, rcx
    add rdi, rax
    lea rsi, [rel scratch_result_vec]
    call holo_dot_f64
    xorpd xmm1, xmm1
    maxsd xmm0, xmm1
    movsd [rsp + 8], xmm0

    ; === Query MISS + ctx ===
    mov edi, EVENT_MISS
    add edi, TRACE_EVENT_SEED
    lea rsi, [rel scratch_event_vec]
    call holo_gen_vec

    lea rdi, [rel scratch_event_vec]
    lea rsi, [rel scratch_ctx_vec]
    lea rdx, [rel scratch_result_vec]
    call holo_bind_f64

    mov eax, UNIFIED_TRACE_IDX
    imul rax, rax, HOLO_VEC_BYTES
    mov rdi, rbx
    mov rcx, HOLO_OFFSET
    add rdi, rcx
    add rdi, rax
    lea rsi, [rel scratch_result_vec]
    call holo_dot_f64
    xorpd xmm1, xmm1
    maxsd xmm0, xmm1
    movsd [rsp + 16], xmm0

    ; performance = hit / (hit + miss + epsilon)
    movsd xmm0, [rsp + 8]
    movsd xmm1, [rsp + 16]
    addsd xmm1, xmm0
    mov rax, 0x3EB0C6F7A0B5ED8D
    movq xmm2, rax
    addsd xmm1, xmm2
    divsd xmm0, xmm1

    add rsp, 24
    pop rbx
    ret

;; ============================================================
;; trace_token_learnability(token) → xmm0 (learnability score)
;; Query trace for how often this token appears in LEARN events.
;; High = token gets learned frequently (maybe problematic pattern).
;; edi = token_hash
;; ============================================================
global trace_token_learnability
trace_token_learnability:
    push rbx
    push r12
    sub rsp, 8

    mov rbx, SURFACE_BASE
    mov r12d, edi         ; save token

    ; Generate LEARN event probe
    mov edi, EVENT_LEARN
    add edi, TRACE_EVENT_SEED
    lea rsi, [rel scratch_event_vec]
    call holo_gen_vec

    ; Generate token probe
    mov edi, r12d
    lea rsi, [rel scratch_actual_vec]
    call holo_gen_vec

    ; Bind event ⊗ token → probe
    lea rdi, [rel scratch_event_vec]
    lea rsi, [rel scratch_actual_vec]
    lea rdx, [rel scratch_result_vec]
    call holo_bind_f64

    ; Dot with unified trace
    mov eax, UNIFIED_TRACE_IDX
    imul rax, rax, HOLO_VEC_BYTES
    mov rdi, rbx
    mov rcx, HOLO_OFFSET
    add rdi, rcx
    add rdi, rax
    lea rsi, [rel scratch_result_vec]
    call holo_dot_f64
    ; Clamp negative
    xorpd xmm1, xmm1
    maxsd xmm0, xmm1

    add rsp, 8
    pop r12
    pop rbx
    ret

;; ============================================================
;; trace_event_count(event_type) → xmm0 (resonance magnitude)
;; Query trace for total resonance with given event type.
;; Proxy for "how many of this event have occurred".
;; edi = event_type
;; ============================================================
global trace_event_count
trace_event_count:
    push rbx
    sub rsp, 8

    mov rbx, SURFACE_BASE

    ; Generate event probe
    add edi, TRACE_EVENT_SEED
    lea rsi, [rel scratch_event_vec]
    call holo_gen_vec

    ; Unbind from trace to isolate this event type
    mov eax, UNIFIED_TRACE_IDX
    imul rax, rax, HOLO_VEC_BYTES
    mov rdi, rbx
    mov rcx, HOLO_OFFSET
    add rdi, rcx
    add rdi, rax
    lea rsi, [rel scratch_event_vec]
    lea rdx, [rel scratch_result_vec]
    call holo_unbind_f64

    ; Magnitude = proxy for count
    lea rdi, [rel scratch_result_vec]
    call holo_magnitude_f64

    add rsp, 8
    pop rbx
    ret

;; ============================================================
;; trace_hit_miss_ratio() → xmm0 (overall hit ratio 0.0-1.0)
;; Query trace for system-wide HIT vs MISS ratio.
;; Used for self-model: "how well am I doing overall?"
;; ============================================================
global trace_hit_miss_ratio
trace_hit_miss_ratio:
    push rbx
    sub rsp, 16           ; [0]=hit_mag, [8]=miss_mag

    mov rbx, SURFACE_BASE

    ; Get HIT magnitude
    mov edi, EVENT_HIT
    call trace_event_count
    movsd [rsp], xmm0

    ; Get MISS magnitude
    mov edi, EVENT_MISS
    call trace_event_count
    movsd [rsp + 8], xmm0

    ; ratio = hit / (hit + miss + epsilon)
    movsd xmm0, [rsp]
    movsd xmm1, [rsp + 8]
    addsd xmm1, xmm0
    mov rax, 0x3EB0C6F7A0B5ED8D
    movq xmm2, rax
    addsd xmm1, xmm2
    divsd xmm0, xmm1

    add rsp, 16
    pop rbx
    ret
; repl.asm — Interactive command loop with autonomous idle processing
;
; @entry repl_run() -> never returns (exits via quit/EOF)
; @calls introspect.asm:tick_workers (on poll timeout - autonomous behavior)
; @calls dispatch.asm:process_input
; @calls io.asm:digest_file
; @calls dreams.asm:dream_cycle
; @calls observe.asm:observe_cycle
; @calls surface.asm:surface_freeze
; @calls channels.asm:channels_poll, channels_read, get_channel_fd
; @calledby boot.asm:_start
;
; AUTONOMOUS LOOP:
;   On poll timeout (100ms with no input), calls tick_workers() which:
;   - Checks dream/observe/evolve pressures → triggers cycles
;   - Bootstrap: if SELF-AWARE < 0.3, triggers observe_cycle
;   - Startup: if regions > 100 and fresh session, triggers dream_cycle
;
; I/O SOURCES:
;   stdin (-1)     - interactive terminal (skipped if stdin_active=0)
;   TCP channels   - 6-channel paired I/O (FEED/QUERY/DEBUG)
;
; GOTCHAS:
;   - Commands are plain words, NOT :prefixed
;   - quit must call surface_freeze before exit
;   - stdin EOF sets stdin_active=0, does NOT quit (allows headless TCP-only)
%include "syscalls.inc"
%include "constants.inc"

section .data
    prompt_str:     db "uhma> ", 0
    prompt_len      equ 6
    banner_str:     db "UHMA x86_64 — Unified Holographic Memory Architecture", 10
                    db "Surface: 8GB RWX | VSA: 8192-dim f64 | Self-modifying dispatch", 10
                    db "Type 'help' for commands, text to process, or Ctrl-D to exit.", 10, 10, 0
    help_str:       db "Commands:", 10
                    db "  help          Show this help", 10
                    db "  status        Show system status (regions, accuracy, drives)", 10
                    db "  self          Show self-knowledge (strengths/weaknesses)", 10
                    db "  metacog       Show metacognitive state (per-context confidence)", 10
                    db "  debugger      Show self-debugger status (breakpoints, learning events)", 10
                    db "  genes         Show gene pool status (composted patterns)", 10
                    db "  subroutines   Show shared subroutines (recursive schemas)", 10
                    db "  receipts [n]  Show last n receipts (default 10)", 10
                    db "  why           Explain last prediction failure (the answer!)", 10
                    db "  misses [n]    Show last n misses with predicted vs actual", 10
                    db "  listen        Enable receipt stream (ring+print)", 10
                    db "  regions       List all regions with hit/miss stats", 10
                    db "  presence      Show presence field (30-dim phenomenal state)", 10
                    db "  drives        Show drive levels and thresholds", 10
                    db "  intro         Show introspective state (SELF-AWARE reading)", 10
                    db "  observe       Trigger observation cycle (builds self-model)", 10
                    db "  dream         Trigger dream/consolidation cycle", 10
                    db "  compact       Compact condemned regions", 10
                    db "  save <file>   Save surface to file", 10
                    db "  load <file>   Restore surface from file", 10
                    db "  eat <file>    Digest file as food (extract tokens, gain energy)", 10
                    db "  hive          Show hive pheromone levels (swarm intelligence)", 10
                    db "  share         Enable shared VSA (Mycorrhiza collective consciousness)", 10
                    db "  colony        Show colony status (hive mind instances)", 10
                    db "  export <n>    Export region n as .gene file (spore)", 10
                    db "  import <file> Import .gene file (infect with culture)", 10
                    db "  reset         Reset counters (not knowledge)", 10
                    db "  trace         Toggle debug tracing on/off", 10
                    db "  quit          Exit", 10
                    db "  <text>        Process as token sequence", 10, 0
    debugger_hdr:   db "--- Self-Debugger ---", 10, 0
    debugger_bp:    db "  Breakpoints: ", 0
    debugger_hits:  db "  Total hits: ", 0
    debugger_learn: db "  Learning events: ", 0
    listen_enabled_msg: db "[RECEIPT] Listeners enabled (ring+print)", 10, 0
    bye_str:        db "Surface frozen. Goodbye.", 10, 0
    trace_next_msg: db "[JOURNEY] Will trace next token. Type text to trace, 'trace' to show.", 10, 0
    unknown_str:    db "Unknown command. Type 'help'.", 10, 0
    status_hdr:     db "--- Status ---", 10, 0
    maturity_hdr:   db "--- Maturity (Developmental Stage) ---", 10, 0
    maturity_stage: db "  Stage: ", 0
    maturity_acc:   db "  Accuracy:  ", 0
    maturity_stab:  db "  Stability: ", 0
    maturity_coh:   db "  Coherence: ", 0
    maturity_s0:    db "0 (Infant)", 0
    maturity_s1:    db "1 (Aware)", 0
    maturity_s2:    db "2 (Active)", 0
    hive_hdr:       db "--- Hive Mind (Pheromone Levels) ---", 10, 0
    hive_dream:     db "  Dream pheromone:   ", 0
    hive_observe:   db "  Observe pheromone: ", 0
    hive_evolve:    db "  Evolve pheromone:  ", 0
    hive_fatigue:   db "  Fatigue:           ", 0
    hive_thresh:    db "  Activation threshold: 0.5", 10, 0
    colony_hdr:     db "--- Mycorrhiza Colony ---", 10, 0
    colony_mode:    db "  Mode: ", 0
    colony_solo:    db "SOLO (isolated)", 10, 0
    colony_shared:  db "SHARED (hive mind)", 10, 0
    colony_size:    db "  Colony size: ", 0
    colony_valence: db "  Collective valence: ", 0
    colony_instance:db "  Instance ID: 0x", 0
    geom_hdr:       db "--- Rosetta Stone (Geometric Gate) ---", 10, 0
    geom_mode_lbl:  db "  Verification mode: ", 0
    geom_mode_0:    db "ABSTRACT (traditional)", 10, 0
    geom_mode_1:    db "GEOMETRIC (vector-based)", 10, 0
    geom_mode_2:    db "BOTH (most secure)", 10, 0
    geom_status:    db "  Safety templates: ", 0
    geom_init_yes:  db "initialized", 10, 0
    geom_init_no:   db "not initialized", 10, 0
    geom_mode_set_msg: db "  Verification mode set to: ", 0
    geom_usage:     db "  Usage: geom [0|1|2] to set mode", 10, 0
    regions_lbl:    db "Regions: ", 0
    steps_lbl:      db "  Steps: ", 0
    accuracy_lbl:   db "  Accuracy: ", 0
    faults_lbl:     db "  Faults: ", 0
    dispatch_lbl:   db "  Dispatch ptr: ", 0
    nl:             db 10

section .bss
    input_buf:      resb INPUT_BUF_SIZE
    buf_pos:        resq 1            ; current read position in buffer
    buf_end:        resq 1            ; end of valid data in buffer
    current_channel: resd 1           ; -1=stdin, 0-5=TCP channel

section .data
global stdin_active
    stdin_active:   dd 1              ; 0 if stdin hit EOF

section .text

extern print_cstr
extern print_str
extern print_u64
extern print_hex64
extern print_f32
extern print_newline
extern print_space
extern read_stdin
extern write_stdout
extern process_input
extern observe_cycle
extern dream_cycle
extern digest_file
extern surface_init_shared
extern surface_freeze
extern get_colony_size
extern is_shared_mode
extern sense_collective_valence
extern gene_export
extern gene_import
extern region_compact
extern get_fault_count
extern persist_save
extern persist_load
extern drives_show
extern tick_workers            ; from introspect.asm - autonomous idle processing
extern presence_show
extern vocab_count
extern holo_dot_f64
extern holo_magnitude_f64
extern fault_safe_rsp
extern fault_safe_rip
extern print_f64
extern verify_set_mode
extern verify_get_mode
extern init_safety_vectors
extern get_safety_template
extern get_danger_template
extern encode_code_to_vector
extern check_code_safety
extern journey_start
extern journey_stop
extern journey_dump
extern metacog_report
extern gene_pool_show
extern subroutines_show       ; from factor.asm - show subroutine table
extern receipt_dump           ; from receipt.asm - dump recent receipts
extern receipt_listen         ; from receipt.asm - enable receipt listeners
extern receipt_mute           ; from receipt.asm - disable receipt listeners
extern receipt_why_miss       ; from receipt.asm - explain last miss
extern receipt_show_misses    ; from receipt.asm - show last N misses
extern intro_report           ; from receipt.asm - introspective state report
extern self_show_context_types ; from receipt.asm - trace-based context strengths
extern causal_report          ; from receipt.asm - causal model report
extern channels_poll          ; from channels.asm - poll all channels + stdin
extern channels_read          ; from channels.asm - read from TCP channel
extern channels_respond       ; from channels.asm - write to paired output channel
extern get_channel_fd         ; from channels.asm - get socket fd for channel
extern set_output_channel     ; from format.asm - route output to channel
extern reset_output_channel   ; from format.asm - reset to stdout

;; ============================================================
;; repl_run
;; Main interactive loop. Never returns (exits via quit or EOF).
;; ============================================================
global repl_run
repl_run:
    push rbx
    push r12

    ; Print banner
    lea rdi, [rel banner_str]
    call print_cstr

.loop:
    ; Save recovery point for crash handler (longjmp target)
    mov [rel fault_safe_rsp], rsp
    lea rax, [rel .loop]
    mov [rel fault_safe_rip], rax

    ; Check if there's remaining data in the buffer
    mov rax, [rel buf_pos]
    mov rcx, [rel buf_end]
    cmp rax, rcx
    jl .have_data

    ; Poll all channels (stdin + 6 TCP) for data
    call channels_poll
    mov [rel current_channel], eax

    ; Check result: -2=timeout, -1=stdin, 0-5=TCP channel
    cmp eax, -2
    jne .not_timeout
    ; Timeout - do autonomous work (dream/observe/self-ingest based on pressure)
    call tick_workers
    jmp .loop
.not_timeout:

    cmp eax, -1
    jne .read_tcp_channel

    ; Check if stdin is still active
    cmp dword [rel stdin_active], 0
    je .loop                      ; stdin dead, ignore and re-poll

    ; stdin has data — ensure output goes to stdout
    call reset_output_channel

    ; Print prompt and read
    lea rdi, [rel prompt_str]
    mov rsi, prompt_len
    call print_str

    lea rdi, [rel input_buf]
    mov rsi, INPUT_BUF_SIZE - 1
    call read_stdin

    ; Check EOF on stdin - if channels active, don't quit, just loop
    test rax, rax
    jg .set_buffer
    ; EOF on stdin - mark dead and keep running for channel I/O
    mov dword [rel stdin_active], 0
    jmp .loop

.read_tcp_channel:
    ; Read from TCP channel (eax = input channel 0,2,4)
    mov edi, [rel current_channel]
    lea rsi, [rel input_buf]
    mov edx, INPUT_BUF_SIZE - 1
    call channels_read
    mov r12d, eax                 ; save bytes read

    ; Check for disconnect/error
    test eax, eax
    jle .loop                     ; channel closed, poll again

    ; Route output to paired output channel (input+1)
    ; Get socket fd from channels and pass to set_output_channel
    mov edi, [rel current_channel]
    inc edi                       ; output channel = input + 1
    call get_channel_fd           ; eax = socket fd for channel edi
    mov edi, eax
    call set_output_channel

    mov eax, r12d                 ; restore bytes read for .set_buffer
    jmp .set_buffer

.set_buffer:
    ; Set buffer bounds
    lea rcx, [rel input_buf]
    mov [rel buf_pos], rcx
    add rcx, rax
    mov [rel buf_end], rcx

.have_data:
    ; Extract one line from buffer (up to \n or end)
    mov rbx, [rel buf_pos]    ; start of this line
    mov rcx, [rel buf_end]

    ; Find newline or end
    mov rdi, rbx
.find_nl:
    cmp rdi, rcx
    jge .line_at_end
    cmp byte [rdi], 10
    je .found_nl
    inc rdi
    jmp .find_nl

.found_nl:
    ; Replace \n with \0, advance buf_pos past it
    mov byte [rdi], 0
    inc rdi
    mov [rel buf_pos], rdi
    jmp .have_line

.line_at_end:
    ; No newline found — null-terminate at end
    mov byte [rdi], 0
    mov [rel buf_pos], rdi    ; buf_pos = buf_end → will read next time

.have_line:
    ; rbx points to null-terminated line
    ; Skip empty lines
    cmp byte [rbx], 0
    je .loop

    ; Check for commands
    ; "quit" or "exit"
    cmp dword [rbx], 'quit'
    je .quit
    cmp dword [rbx], 'exit'
    je .quit

    ; "help"
    cmp dword [rbx], 'help'
    je .cmd_help

    ; "status" (full 6-char match + boundary)
    mov eax, [rbx]
    cmp eax, 'stat'
    jne .not_status
    cmp word [rbx + 4], 'us'
    jne .not_status
    movzx eax, byte [rbx + 6]
    test eax, eax
    jz .cmd_status
    cmp eax, ' '
    je .cmd_status
    cmp eax, 10
    je .cmd_status
    jmp .not_status
.not_status:

    ; "regions" (full 7-char match + boundary)
    cmp dword [rbx], 'regi'
    jne .not_regions
    cmp word [rbx + 4], 'on'
    jne .not_regions
    cmp byte [rbx + 6], 's'
    jne .not_regions
    movzx eax, byte [rbx + 7]
    test eax, eax
    jz .cmd_regions
    cmp eax, ' '
    je .cmd_regions
    jmp .not_regions
.not_regions:

    ; "presence" (full 8-char match + boundary)
    cmp dword [rbx], 'pres'
    jne .not_presence
    cmp dword [rbx + 4], 'ence'
    jne .not_presence
    movzx eax, byte [rbx + 8]
    test eax, eax
    jz .cmd_presence
    cmp eax, ' '
    je .cmd_presence
    jmp .not_presence
.not_presence:

    ; "drives" (full 6-char match + boundary)
    cmp dword [rbx], 'driv'
    jne .not_drives
    cmp word [rbx + 4], 'es'
    jne .not_drives
    movzx eax, byte [rbx + 6]
    test eax, eax
    jz .cmd_drives
    cmp eax, ' '
    je .cmd_drives
    jmp .not_drives
.not_drives:

    ; "observe" (full 7-char match + boundary)
    cmp dword [rbx], 'obse'
    jne .not_observe
    cmp word [rbx + 4], 'rv'
    jne .not_observe
    cmp byte [rbx + 6], 'e'
    jne .not_observe
    movzx eax, byte [rbx + 7]
    test eax, eax
    jz .cmd_observe
    cmp eax, ' '
    je .cmd_observe
    cmp eax, 10
    je .cmd_observe
    jmp .not_observe
.not_observe:

    ; "dream" (full 5-char match + boundary)
    cmp dword [rbx], 'drea'
    jne .not_dream
    cmp byte [rbx + 4], 'm'
    jne .not_dream
    movzx eax, byte [rbx + 5]
    test eax, eax
    jz .cmd_dream
    cmp eax, ' '
    je .cmd_dream
    cmp eax, 10
    je .cmd_dream
    jmp .not_dream
.not_dream:

    ; "compact" (full 7-char match + boundary)
    cmp dword [rbx], 'comp'
    jne .not_compact
    cmp word [rbx + 4], 'ac'
    jne .not_compact
    cmp byte [rbx + 6], 't'
    jne .not_compact
    movzx eax, byte [rbx + 7]
    test eax, eax
    jz .cmd_compact
    cmp eax, ' '
    je .cmd_compact
    jmp .not_compact
.not_compact:

    ; "save"
    cmp dword [rbx], 'save'
    jne .not_save
    jmp .cmd_save
.not_save:

    ; "load"
    cmp dword [rbx], 'load'
    jne .not_load
    jmp .cmd_load
.not_load:

    ; "eat <file>" (digest file as food)
    cmp dword [rbx], 'eat '
    jne .not_eat
    jmp .cmd_eat
.not_eat:

    ; "hive" (show hive pheromone levels)
    cmp dword [rbx], 'hive'
    jne .not_hive
    movzx eax, byte [rbx + 4]
    test eax, eax
    jz .cmd_hive
    cmp eax, 10
    je .cmd_hive
    jmp .not_hive
.not_hive:

    ; "geom" (show geometric gate status)
    cmp dword [rbx], 'geom'
    jne .not_geom
    movzx eax, byte [rbx + 4]
    test eax, eax
    jz .cmd_geom
    cmp eax, 10
    je .cmd_geom
    cmp eax, ' '
    jne .not_geom
    jmp .cmd_geom_arg         ; geom with argument (mode setting)
.not_geom:

    ; "share" (enable shared consciousness)
    cmp dword [rbx], 'shar'
    jne .not_share
    cmp byte [rbx + 4], 'e'
    jne .not_share
    movzx eax, byte [rbx + 5]
    test eax, eax
    jz .cmd_share
    cmp eax, 10
    je .cmd_share
    jmp .not_share
.not_share:

    ; "colony" (show colony status)
    cmp dword [rbx], 'colo'
    jne .not_colony
    cmp word [rbx + 4], 'ny'
    jne .not_colony
    movzx eax, byte [rbx + 6]
    test eax, eax
    jz .cmd_colony
    cmp eax, 10
    je .cmd_colony
    jmp .not_colony
.not_colony:

    ; "export <n>" (export region as gene)
    cmp dword [rbx], 'expo'
    jne .not_export
    cmp word [rbx + 4], 'rt'
    jne .not_export
    cmp byte [rbx + 6], ' '
    jne .not_export
    jmp .cmd_export
.not_export:

    ; "import <file>" (import gene file)
    cmp dword [rbx], 'impo'
    jne .not_import
    cmp word [rbx + 4], 'rt'
    jne .not_import
    cmp byte [rbx + 6], ' '
    jne .not_import
    jmp .cmd_import
.not_import:

    ; "reset"
    cmp dword [rbx], 'rese'
    jne .not_reset
    jmp .cmd_reset
.not_reset:

    ; "self"
    cmp dword [rbx], 'self'
    jne .not_self
    cmp byte [rbx + 4], 0
    jne .not_self
    jmp .cmd_self
.not_self:

    ; "causal" (6-char match: c-a-u-s-a-l)
    cmp dword [rbx], 'caus'
    jne .not_causal
    cmp word [rbx + 4], 'al'
    jne .not_causal
    movzx eax, byte [rbx + 6]
    test eax, eax
    jz .cmd_causal
    cmp eax, ' '
    je .cmd_causal
    cmp eax, 10
    je .cmd_causal
    jmp .not_causal
.not_causal:

    ; "trace" (toggle tracing on/off)
    cmp dword [rbx], 'trac'
    jne .not_trace
    cmp byte [rbx + 4], 'e'
    jne .not_trace
    movzx eax, byte [rbx + 5]
    test eax, eax
    jz .cmd_trace
    cmp eax, ' '
    je .cmd_trace
    cmp eax, 10
    je .cmd_trace
    jmp .not_trace
.not_trace:

    ; "metacog" (7-char match: m-e-t-a-c-o-g)
    cmp dword [rbx], 'meta'
    jne .not_metacog
    cmp word [rbx + 4], 'co'
    jne .not_metacog
    cmp byte [rbx + 6], 'g'
    jne .not_metacog
    movzx eax, byte [rbx + 7]
    test eax, eax
    jz .cmd_metacog
    cmp eax, ' '
    je .cmd_metacog
    cmp eax, 10
    je .cmd_metacog
    jmp .not_metacog
.not_metacog:

    ; "debugger" (8-char match: d-e-b-u-g-g-e-r)
    cmp dword [rbx], 'debu'
    jne .not_debugger
    cmp dword [rbx + 4], 'gger'
    jne .not_debugger
    movzx eax, byte [rbx + 8]
    test eax, eax
    jz .cmd_debugger
    cmp eax, ' '
    je .cmd_debugger
    cmp eax, 10
    je .cmd_debugger
    jmp .not_debugger
.not_debugger:

    ; "genes" (5-char match: g-e-n-e-s)
    cmp dword [rbx], 'gene'
    jne .not_genes
    cmp byte [rbx + 4], 's'
    jne .not_genes
    movzx eax, byte [rbx + 5]
    test eax, eax
    jz .cmd_genes
    cmp eax, ' '
    je .cmd_genes
    cmp eax, 10
    je .cmd_genes
    jmp .not_genes
.not_genes:

    ; "subroutines" (11-char match: s-u-b-r-o-u-t-i-n-e-s)
    cmp dword [rbx], 'subr'
    jne .not_subroutines
    cmp dword [rbx + 4], 'outi'
    jne .not_subroutines
    cmp word [rbx + 8], 'ne'
    jne .not_subroutines
    cmp byte [rbx + 10], 's'
    jne .not_subroutines
    movzx eax, byte [rbx + 11]
    test eax, eax
    jz .cmd_subroutines
    cmp eax, ' '
    je .cmd_subroutines
    cmp eax, 10
    je .cmd_subroutines
    jmp .not_subroutines
.not_subroutines:

    ; "receipts" (8-char match: r-e-c-e-i-p-t-s)
    cmp dword [rbx], 'rece'
    jne .not_receipts
    cmp dword [rbx + 4], 'ipts'
    jne .not_receipts
    movzx eax, byte [rbx + 8]
    test eax, eax
    jz .cmd_receipts
    cmp eax, ' '
    je .cmd_receipts_arg       ; receipts with optional count argument
    cmp eax, 10
    je .cmd_receipts
    jmp .not_receipts
.not_receipts:

    ; "why" (explain last miss - THE ANSWER!)
    cmp word [rbx], 'wh'
    jne .not_why
    cmp byte [rbx + 2], 'y'
    jne .not_why
    movzx eax, byte [rbx + 3]
    test eax, eax
    jz .cmd_why
    cmp eax, 10
    je .cmd_why
    jmp .not_why
.not_why:

    ; "misses" (6-char match) or "misses N"
    cmp dword [rbx], 'miss'
    jne .not_misses
    cmp word [rbx + 4], 'es'
    jne .not_misses
    movzx eax, byte [rbx + 6]
    test eax, eax
    jz .cmd_misses
    cmp eax, ' '
    je .cmd_misses_arg
    cmp eax, 10
    je .cmd_misses
    jmp .not_misses
.not_misses:

    ; "listen" (6-char match: l-i-s-t-e-n) - enable receipt listeners
    cmp dword [rbx], 'list'
    jne .not_listen
    cmp word [rbx + 4], 'en'
    jne .not_listen
    movzx eax, byte [rbx + 6]
    test eax, eax
    jz .cmd_listen
    cmp eax, ' '
    je .cmd_listen
    cmp eax, 10
    je .cmd_listen
    jmp .not_listen
.not_listen:

    ; "intro" (5-char match: i-n-t-r-o) - introspective state report
    cmp dword [rbx], 'intr'
    jne .not_intro
    cmp byte [rbx + 4], 'o'
    jne .not_intro
    movzx eax, byte [rbx + 5]
    test eax, eax
    jz .cmd_intro
    cmp eax, ' '
    je .cmd_intro
    cmp eax, 10
    je .cmd_intro
    jmp .not_intro
.not_intro:

    ; Not a command → process as text input
    ; Compute string length (rbx is null-terminated)
    mov rdi, rbx
    xor rsi, rsi
.strlen:
    cmp byte [rbx + rsi], 0
    je .strlen_done
    inc rsi
    jmp .strlen
.strlen_done:
    call process_input
    jmp .loop

.cmd_help:
    lea rdi, [rel help_str]
    call print_cstr
    jmp .loop

.cmd_status:
    call repl_show_status
    jmp .loop

.cmd_regions:
    call repl_show_regions
    jmp .loop

.cmd_presence:
    call presence_show
    jmp .loop

.cmd_drives:
    call drives_show
    jmp .loop

.cmd_observe:
    call observe_cycle
    jmp .loop

.cmd_dream:
    call dream_cycle
    jmp .loop

.cmd_compact:
    call region_compact
    push rax
    lea rdi, [rel compact_msg]
    call print_cstr
    pop rdi
    call print_u64
    call print_newline
    jmp .loop

.cmd_save:
    ; Get filename after "save "
    lea rdi, [rbx + 5]
    call persist_save
    jmp .loop

.cmd_load:
    lea rdi, [rbx + 5]
    call persist_load
    jmp .loop

.cmd_eat:
    ; Digest file as "food" — extract tokens and gain energy
    ; Strip trailing newline from filename
    lea rdi, [rbx + 4]        ; skip "eat "
    mov rsi, rdi
.eat_strip:
    mov al, [rsi]
    test al, al
    jz .eat_stripped
    cmp al, 10
    je .eat_null_term
    cmp al, 13
    je .eat_null_term
    inc rsi
    jmp .eat_strip
.eat_null_term:
    mov byte [rsi], 0
.eat_stripped:
    call digest_file
    jmp .loop

.cmd_hive:
    ; Show hive pheromone levels (swarm intelligence state)
    call repl_show_hive
    jmp .loop

.cmd_geom:
    ; Show geometric gate status (Rosetta Stone)
    call repl_show_geom
    jmp .loop

.cmd_geom_arg:
    ; Set geometric verification mode: geom 0/1/2
    lea rdi, [rbx + 5]        ; skip "geom "
    call parse_decimal        ; eax = mode number
    mov edi, eax
    push rdi                  ; save mode for printing
    call verify_set_mode
    lea rdi, [rel geom_mode_set_msg]
    call print_cstr
    pop rdi                   ; restore mode
    call print_u64
    call print_newline
    jmp .loop

.cmd_share:
    ; Enable shared consciousness (Mycorrhiza)
    xor edi, edi              ; mode 0 = create new
    call surface_init_shared
    jmp .loop

.cmd_colony:
    ; Show colony status
    call repl_show_colony
    jmp .loop

.cmd_export:
    ; Export region as .gene file
    ; Parse region index from "export <n>"
    lea rdi, [rbx + 7]        ; skip "export "
    call parse_decimal        ; → eax = region index
    push rax

    ; Get region table entry
    mov rcx, SURFACE_BASE
    lea rsi, [rcx + REGION_TABLE_OFFSET]
    pop rax
    imul rax, rax, RTE_SIZE
    add rax, rsi
    mov rdi, [rax + RTE_ADDR] ; region header ptr

    ; Build filename: /tmp/gene_<index>.gene
    sub rsp, 32
    mov dword [rsp], '/tmp'
    mov dword [rsp + 4], '/gen'
    mov dword [rsp + 8], 'e.ge'
    mov word [rsp + 12], 'ne'
    mov byte [rsp + 14], 0
    lea rsi, [rsp]
    call gene_export
    add rsp, 32
    jmp .loop

.cmd_import:
    ; Import .gene file
    lea rdi, [rbx + 7]        ; skip "import "
    ; Strip trailing newline
    mov rsi, rdi
.import_strip:
    mov al, [rsi]
    test al, al
    jz .import_stripped
    cmp al, 10
    je .import_null
    inc rsi
    jmp .import_strip
.import_null:
    mov byte [rsi], 0
.import_stripped:
    call gene_import
    jmp .loop

.cmd_reset:
    call repl_reset_counters
    jmp .loop

.cmd_self:
    call repl_show_self
    jmp .loop

.cmd_trace:
    ; Toggle journey: if tracing, show journey and stop. If not, trace next token.
    mov rax, SURFACE_BASE
    cmp dword [rax + STATE_OFFSET + ST_JOURNEY_TOKEN], 0
    je .trace_next
    ; Currently tracing - dump and stop
    call journey_dump
    call journey_stop
    jmp .loop
.trace_next:
    ; Set flag to trace next token (0xFFFFFFFF means "trace next")
    mov dword [rax + STATE_OFFSET + ST_JOURNEY_TOKEN], 0xFFFFFFFF
    lea rdi, [rel trace_next_msg]
    call print_cstr
    jmp .loop

.cmd_metacog:
    ; Show metacognitive state for last prediction context
    ; ST_LAST_CTX holds the context from the last prediction (where hit/miss was recorded)
    mov rax, SURFACE_BASE
    mov edi, [rax + STATE_OFFSET + ST_LAST_CTX]  ; get last prediction context
    call metacog_report
    jmp .loop

.cmd_debugger:
    ; Show self-debugger status
    lea rdi, [rel debugger_hdr]
    call print_cstr

    lea rdi, [rel debugger_bp]
    call print_cstr
    mov rax, SURFACE_BASE
    mov edi, [rax + STATE_OFFSET + ST_BREAKPOINT_COUNT]
    call print_u64
    call print_newline

    lea rdi, [rel debugger_hits]
    call print_cstr
    mov rax, SURFACE_BASE
    mov edi, [rax + STATE_OFFSET + ST_BP_TOTAL_HITS]
    call print_u64
    call print_newline

    lea rdi, [rel debugger_learn]
    call print_cstr
    mov rax, SURFACE_BASE
    mov edi, [rax + STATE_OFFSET + ST_BP_LEARNING_EVENTS]
    call print_u64
    call print_newline
    jmp .loop

.cmd_genes:
    ; Show gene pool status
    call gene_pool_show
    jmp .loop

.cmd_subroutines:
    ; Show subroutine table (recursive schema hierarchy)
    call subroutines_show
    jmp .loop

.cmd_receipts:
    ; Dump last 10 receipts (default)
    mov edi, 10
    call receipt_dump
    jmp .loop

.cmd_receipts_arg:
    ; Parse count from "receipts <n>"
    lea rdi, [rbx + 9]        ; skip "receipts "
    call parse_decimal        ; → eax = count
    test eax, eax
    jz .cmd_receipts          ; if 0 or invalid, use default
    mov edi, eax
    call receipt_dump
    jmp .loop

.cmd_why:
    ; Explain last miss - THE ANSWER to "why did it fail?"
    call receipt_why_miss
    jmp .loop

.cmd_misses:
    ; Show last 5 misses (default)
    mov edi, 5
    call receipt_show_misses
    jmp .loop

.cmd_misses_arg:
    ; Parse count from "misses <n>"
    lea rdi, [rbx + 7]        ; skip "misses "
    call parse_decimal        ; → eax = count
    test eax, eax
    jz .cmd_misses            ; if 0 or invalid, use default
    mov edi, eax
    call receipt_show_misses
    jmp .loop

.cmd_intro:
    ; Introspective state report - query trace for confusion/confidence/learning
    xor edi, edi              ; 0 = use current context
    call intro_report
    jmp .loop

.cmd_causal:
    ; Causal model report - what modifications work in current context
    xor edi, edi              ; 0 = use current context
    call causal_report
    jmp .loop

.cmd_listen:
    ; Enable receipt listeners (HOLO | PRINT for interactive use)
    mov edi, (LISTENER_HOLO | LISTENER_PRINT)
    call receipt_listen
    lea rdi, [rel listen_enabled_msg]
    call print_cstr
    jmp .loop

.quit:
    ; Sync persistent memory to disk before exit
    call surface_freeze
    lea rdi, [rel bye_str]
    call print_cstr
    xor edi, edi
    mov rax, SYS_EXIT
    syscall

;; ============================================================
;; repl_show_status — Print system overview
;; ============================================================
repl_show_status:
    push rbx
    mov rbx, SURFACE_BASE

    lea rdi, [rel status_hdr]
    call print_cstr

    ; Region count
    lea rdi, [rel regions_lbl]
    call print_cstr
    lea rax, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    mov rdi, [rax]
    call print_u64
    call print_newline

    ; Global step
    lea rdi, [rel steps_lbl]
    call print_cstr
    lea rax, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    mov rdi, [rax]
    call print_u64
    call print_newline

    ; Compute overall accuracy
    lea rdi, [rel accuracy_lbl]
    call print_cstr
    call compute_total_accuracy
    call print_f32
    call print_newline

    ; Fault count
    lea rdi, [rel faults_lbl]
    call print_cstr
    call get_fault_count
    mov rdi, rax
    call print_u64
    call print_newline

    ; Dispatch pointer
    lea rdi, [rel dispatch_lbl]
    call print_cstr
    lea rax, [rbx + STATE_OFFSET + ST_DISPATCH_PTR]
    mov rdi, [rax]
    call print_hex64
    call print_newline

    ; Introspective state
    lea rdi, [rel intro_lbl]
    call print_cstr
    lea rax, [rbx + STATE_OFFSET + ST_INTRO_STATE]
    mov edi, [rax]
    call print_intro_state
    call print_newline

    ; Self-prediction accuracy
    lea rdi, [rel selfpred_lbl]
    call print_cstr
    lea rax, [rbx + STATE_OFFSET + ST_SELF_PRED_HITS]
    mov edi, [rax]
    call print_u64
    lea rdi, [rel slash_char]
    call print_cstr
    lea rax, [rbx + STATE_OFFSET + ST_SELF_PRED_MISSES]
    mov edi, [rax]
    add edi, [rbx + STATE_OFFSET + ST_SELF_PRED_HITS]
    call print_u64
    call print_newline

    ; Schema coverage
    lea rdi, [rel schema_lbl]
    call print_cstr
    lea rax, [rbx + STATE_OFFSET + ST_SCHEMA_HITS]
    mov edi, [rax]
    call print_u64
    lea rdi, [rel slash_char]
    call print_cstr
    lea rax, [rbx + STATE_OFFSET + ST_SCHEMA_TOTAL]
    mov edi, [rax]
    call print_u64
    call print_newline

    ; Dispatch mode
    lea rdi, [rel dmode_lbl]
    call print_cstr
    lea rax, [rbx + STATE_OFFSET + ST_DISPATCH_MODE]
    mov edi, [rax]
    call print_dispatch_mode
    call print_newline

    ; Last surprise type
    lea rdi, [rel surprise_lbl]
    call print_cstr
    lea rax, [rbx + STATE_OFFSET + ST_SURPRISE_TYPE]
    mov edi, [rax]
    call print_surprise_type
    call print_newline

    ; Causal records
    lea rdi, [rel causal_lbl]
    call print_cstr
    lea rax, [rbx + STATE_OFFSET + ST_CAUSAL_COUNT]
    mov edi, [rax]
    call print_u64
    call print_newline

    ; Hypotheses (NURSERY-flagged regions)
    lea rdi, [rel hypo_lbl]
    call print_cstr
    call count_nursery_regions ; → eax
    mov edi, eax
    call print_u64
    call print_newline

    ; Trace (last dispatch scan)
    lea rdi, [rel trace_lbl]
    call print_cstr
    mov edi, [rbx + STATE_OFFSET + ST_TRACE_CANDIDATES]
    call print_u64
    lea rdi, [rel trace_sep]
    call print_cstr
    mov edi, [rbx + STATE_OFFSET + ST_TRACE_MATCHED]
    call print_u64
    call print_newline

    ; Goal
    lea rdi, [rel goal_lbl]
    call print_cstr
    mov edi, [rbx + STATE_OFFSET + ST_CURRENT_GOAL]
    call print_goal
    call print_newline

    ; Accuracy variance
    lea rdi, [rel variance_lbl]
    call print_cstr
    movss xmm0, [rbx + STATE_OFFSET + ST_ACCURACY_VARIANCE]
    call print_f32
    call print_newline

    ; Expectation bundle
    lea rdi, [rel expect_lbl]
    call print_cstr
    mov rax, [rbx + STATE_OFFSET + ST_EXPECT_REGION]
    test rax, rax
    jz .no_expect
    ; Print confidence
    movss xmm0, [rbx + STATE_OFFSET + ST_EXPECT_CONF]
    call print_f32
    lea rdi, [rel expect_schema]
    mov eax, [rbx + STATE_OFFSET + ST_EXPECT_IS_SCHEMA]
    test eax, eax
    jz .expect_not_schema
    call print_cstr
.expect_not_schema:
    jmp .expect_done
.no_expect:
    lea rdi, [rel expect_none]
    call print_cstr
.expect_done:
    call print_newline

    ; --- Holographic Memory Stats (f64 precision) ---
    ; Vocabulary count
    lea rdi, [rel holo_vocab_lbl]
    call print_cstr
    call vocab_count
    mov edi, eax
    call print_u64
    call print_newline

    ; Holo density: average magnitude of first 16 traces (f64 vectors)
    lea rdi, [rel holo_density_lbl]
    call print_cstr
    sub rsp, 16               ; [rsp]=sum(f64), [rsp+8]=counter
    xorpd xmm0, xmm0
    movsd [rsp], xmm0         ; sum = 0.0
    mov dword [rsp + 8], 0    ; counter
.holo_density_loop:
    cmp dword [rsp + 8], 16
    jge .holo_density_done
    push rbx                  ; save across call
    mov eax, [rsp + 16]       ; counter (+8 for pushed rbx)
    imul rax, rax, HOLO_VEC_BYTES
    mov rdi, rbx
    mov rcx, HOLO_OFFSET
    add rdi, rcx              ; 64-bit offset via register
    add rdi, rax              ; trace ptr (f64[1024])
    call holo_magnitude_f64   ; → xmm0 (f64)
    pop rbx
    addsd xmm0, [rsp]
    movsd [rsp], xmm0
    inc dword [rsp + 8]
    jmp .holo_density_loop
.holo_density_done:
    movsd xmm0, [rsp]
    mov eax, 16
    cvtsi2sd xmm1, eax
    divsd xmm0, xmm1         ; avg magnitude (f64)
    cvtsd2ss xmm0, xmm0      ; convert to f32 for print_f32
    add rsp, 16
    call print_f32
    call print_newline

    ; Holo confidence: average prediction confidence (f64)
    lea rdi, [rel holo_conf_lbl]
    call print_cstr
    mov eax, [rbx + STATE_OFFSET + ST_HOLO_PREDICT_N]
    test eax, eax
    jz .holo_no_conf
    movsd xmm0, [rbx + STATE_OFFSET + ST_HOLO_PREDICT_SUM]
    cvtsi2sd xmm1, eax
    divsd xmm0, xmm1         ; avg confidence (f64)
    cvtsd2ss xmm0, xmm0      ; convert to f32 for print
    jmp .holo_print_conf
.holo_no_conf:
    xorps xmm0, xmm0
.holo_print_conf:
    call print_f32
    lea rdi, [rel holo_conf_n_lbl]
    call print_cstr
    mov edi, [rbx + STATE_OFFSET + ST_HOLO_PREDICT_N]
    call print_u64
    lea rdi, [rel holo_conf_end]
    call print_cstr
    call print_newline

    ; --- Graph Dynamics Stats ---
    call show_graph_stats

    ; --- Maturity/Developmental Stage ---
    lea rdi, [rel maturity_hdr]
    call print_cstr

    ; Stage
    lea rdi, [rel maturity_stage]
    call print_cstr
    mov eax, [rbx + STATE_OFFSET + ST_MATURITY_LEVEL]
    cmp eax, 0
    jne .not_s0
    lea rdi, [rel maturity_s0]
    jmp .print_stage
.not_s0:
    cmp eax, 1
    jne .not_s1
    lea rdi, [rel maturity_s1]
    jmp .print_stage
.not_s1:
    lea rdi, [rel maturity_s2]
.print_stage:
    call print_cstr
    call print_newline

    ; Mastery metrics
    lea rdi, [rel maturity_acc]
    call print_cstr
    movsd xmm0, [rbx + STATE_OFFSET + ST_MASTERY_ACC]
    cvtsd2ss xmm0, xmm0
    call print_f32
    call print_newline

    lea rdi, [rel maturity_stab]
    call print_cstr
    movsd xmm0, [rbx + STATE_OFFSET + ST_MASTERY_STABILITY]
    cvtsd2ss xmm0, xmm0
    call print_f32
    call print_newline

    lea rdi, [rel maturity_coh]
    call print_cstr
    movsd xmm0, [rbx + STATE_OFFSET + ST_MASTERY_COHERENCE]
    cvtsd2ss xmm0, xmm0
    call print_f32
    call print_newline

    pop rbx
    ret

;; ============================================================
;; repl_show_hive — Show hive pheromone levels (swarm intelligence)
;; ============================================================
repl_show_hive:
    push rbx
    mov rbx, SURFACE_BASE

    lea rdi, [rel hive_hdr]
    call print_cstr

    ; Dream pheromone
    lea rdi, [rel hive_dream]
    call print_cstr
    movsd xmm0, [rbx + STATE_OFFSET + ST_DREAM_PRESSURE]
    cvtsd2ss xmm0, xmm0
    call print_f32
    call print_newline

    ; Observe pheromone
    lea rdi, [rel hive_observe]
    call print_cstr
    movsd xmm0, [rbx + STATE_OFFSET + ST_OBSERVE_PRESSURE]
    cvtsd2ss xmm0, xmm0
    call print_f32
    call print_newline

    ; Evolve pheromone
    lea rdi, [rel hive_evolve]
    call print_cstr
    movsd xmm0, [rbx + STATE_OFFSET + ST_EVOLVE_PRESSURE]
    cvtsd2ss xmm0, xmm0
    call print_f32
    call print_newline

    ; Fatigue
    lea rdi, [rel hive_fatigue]
    call print_cstr
    movss xmm0, [rbx + STATE_OFFSET + ST_PRESENCE + PRES_FATIGUE * 4]
    call print_f32
    call print_newline

    ; Threshold
    lea rdi, [rel hive_thresh]
    call print_cstr

    pop rbx
    ret

;; ============================================================
;; repl_show_colony — Show Mycorrhiza colony status
;; ============================================================
repl_show_colony:
    push rbx
    mov rbx, SURFACE_BASE

    lea rdi, [rel colony_hdr]
    call print_cstr

    ; Mode
    lea rdi, [rel colony_mode]
    call print_cstr
    call is_shared_mode
    test eax, eax
    jz .colony_is_solo
    lea rdi, [rel colony_shared]
    jmp .colony_print_mode
.colony_is_solo:
    lea rdi, [rel colony_solo]
.colony_print_mode:
    call print_cstr

    ; Colony size
    lea rdi, [rel colony_size]
    call print_cstr
    call get_colony_size
    mov rdi, rax
    call print_u64
    call print_newline

    ; Collective valence (only if shared)
    call is_shared_mode
    test eax, eax
    jz .colony_skip_valence
    lea rdi, [rel colony_valence]
    call print_cstr
    call sense_collective_valence
    cvtsd2ss xmm0, xmm0
    call print_f32
    call print_newline

.colony_skip_valence:
    ; Instance ID
    lea rdi, [rel colony_instance]
    call print_cstr
    mov rdi, [rbx + STATE_OFFSET + ST_INSTANCE_ID]
    call print_hex64
    call print_newline

    pop rbx
    ret

;; ============================================================
;; repl_show_geom — Show Rosetta Stone (Geometric Gate) status
;; ============================================================
repl_show_geom:
    push rbx

    lea rdi, [rel geom_hdr]
    call print_cstr

    ; Verification mode
    lea rdi, [rel geom_mode_lbl]
    call print_cstr

    call verify_get_mode
    test eax, eax
    jz .geom_mode_0
    cmp eax, 1
    je .geom_mode_1
    cmp eax, 2
    je .geom_mode_2
    jmp .geom_mode_unknown

.geom_mode_0:
    lea rdi, [rel geom_mode_0]
    jmp .geom_print_mode

.geom_mode_1:
    lea rdi, [rel geom_mode_1]
    jmp .geom_print_mode

.geom_mode_2:
    lea rdi, [rel geom_mode_2]
    jmp .geom_print_mode

.geom_mode_unknown:
    lea rdi, [rel geom_mode_0]      ; default

.geom_print_mode:
    call print_cstr

    ; Safety template status
    lea rdi, [rel geom_status]
    call print_cstr

    ; Check if safety vectors are initialized by calling init
    ; (it's idempotent - won't reinitialize if already done)
    call init_safety_vectors
    call get_safety_template
    test rax, rax
    jz .geom_not_init
    lea rdi, [rel geom_init_yes]
    jmp .geom_print_init
.geom_not_init:
    lea rdi, [rel geom_init_no]
.geom_print_init:
    call print_cstr

    ; Usage hint
    lea rdi, [rel geom_usage]
    call print_cstr

    pop rbx
    ret

;; ============================================================
;; parse_decimal(str) -> eax (parsed number)
;; rdi=null-terminated decimal string
;; Returns the parsed decimal number
;; ============================================================
parse_decimal:
    xor eax, eax              ; result
    xor ecx, ecx              ; digit
.parse_loop:
    movzx ecx, byte [rdi]
    test ecx, ecx
    jz .parse_done
    cmp ecx, 10               ; newline
    je .parse_done
    cmp ecx, ' '
    je .parse_done
    sub ecx, '0'
    js .parse_done
    cmp ecx, 9
    ja .parse_done
    imul eax, eax, 10
    add eax, ecx
    inc rdi
    jmp .parse_loop
.parse_done:
    ret

;; ============================================================
;; repl_show_regions — List regions with stats
;; ============================================================
repl_show_regions:
    push rbx
    push r12
    push r13

    mov rbx, SURFACE_BASE
    lea r12, [rbx + REGION_TABLE_OFFSET]
    lea rax, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    mov r13, [rax]

    xor ecx, ecx
.rloop:
    cmp rcx, r13
    jge .rdone
    push rcx

    ; Entry address
    imul rdi, rcx, RTE_SIZE
    add rdi, r12

    ; Print index
    push rdi
    mov rdi, rcx
    call print_u64
    lea rdi, [rel colon_space]
    call print_cstr
    pop rdi

    ; Type
    push rdi
    movzx edi, word [rdi + RTE_TYPE]
    call print_region_type
    call print_space
    pop rdi

    ; Hits
    push rdi
    mov edi, [rdi + RTE_HITS]
    call print_u64
    lea rdi, [rel slash_char]
    call print_cstr
    pop rdi

    ; Misses
    push rdi
    mov edi, [rdi + RTE_MISSES]
    call print_u64
    pop rdi

    ; Flags
    push rdi
    movzx edi, word [rdi + RTE_FLAGS]
    push rdi                  ; save flags
    call print_space
    pop rdi                   ; restore flags to rdi (print_flags expects edi)
    call print_flags
    pop rdi

    call print_newline

    pop rcx
    inc rcx
    jmp .rloop
.rdone:
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; compute_total_accuracy → xmm0 (f32)
;; ============================================================
compute_total_accuracy:
    push rbx
    push r12
    push r13

    mov rbx, SURFACE_BASE
    lea r12, [rbx + REGION_TABLE_OFFSET]
    lea rax, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    mov r13, [rax]

    xor eax, eax              ; total hits
    xor edx, edx              ; total misses
    xor ecx, ecx
.aloop:
    cmp rcx, r13
    jge .adone
    imul rdi, rcx, RTE_SIZE
    add rdi, r12
    add eax, [rdi + RTE_HITS]
    add edx, [rdi + RTE_MISSES]
    inc rcx
    jmp .aloop
.adone:
    ; accuracy = hits / (hits + misses)
    add edx, eax              ; total = hits + misses
    test edx, edx
    jz .azero
    cvtsi2ss xmm0, eax
    cvtsi2ss xmm1, edx
    divss xmm0, xmm1
    jmp .aret
.azero:
    xorps xmm0, xmm0
.aret:
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; show_graph_stats
;; Compute and display graph dynamics metrics:
;; connections, avg prime, avg activation, avg resonance,
;; graph depth, entry table occupancy
;; ============================================================
show_graph_stats:
    push rbx
    push r12
    push r13
    push r14
    sub rsp, 32               ; [0]=conn_count, [4]=region_count_f
                              ; [8]=sum_prime(f64), [16]=sum_activ(f64), [24]=sum_reson(f64)
    mov rbx, SURFACE_BASE
    lea r12, [rbx + REGION_TABLE_OFFSET]
    mov r13d, [rbx + STATE_OFFSET + ST_REGION_COUNT]

    mov dword [rsp + 0], 0    ; connection count
    ; Zero f64 sums
    xorpd xmm0, xmm0
    movsd [rsp + 8], xmm0
    movsd [rsp + 16], xmm0
    movsd [rsp + 24], xmm0
    xor r14d, r14d            ; active region count

    xor ecx, ecx
.gs_loop:
    cmp ecx, r13d
    jge .gs_done_scan
    push rcx

    imul rdi, rcx, RTE_SIZE
    add rdi, r12
    movzx eax, word [rdi + RTE_FLAGS]
    test eax, RFLAG_CONDEMNED
    jnz .gs_next

    mov rsi, [rdi + RTE_ADDR]
    inc r14d                  ; active count

    ; Count non-zero connections
    ; NOTE: push rcx above shifted rsp by 8, so all frame offsets are +8
    cmp qword [rsi + RHDR_NEXT_A], 0
    je .gs_c1
    inc dword [rsp + 8]
.gs_c1:
    cmp qword [rsi + RHDR_NEXT_B], 0
    je .gs_c2
    inc dword [rsp + 8]
.gs_c2:
    cmp qword [rsi + RHDR_EXCITE_A], 0
    je .gs_c3
    inc dword [rsp + 8]
.gs_c3:
    cmp qword [rsi + RHDR_EXCITE_B], 0
    je .gs_c4
    inc dword [rsp + 8]
.gs_c4:
    cmp qword [rsi + RHDR_INHIBIT_A], 0
    je .gs_c5
    inc dword [rsp + 8]
.gs_c5:
    cmp qword [rsi + RHDR_INHIBIT_B], 0
    je .gs_c6
    inc dword [rsp + 8]
.gs_c6:
    ; Accumulate prime
    movsd xmm0, [rsi + RHDR_PRIME]
    addsd xmm0, [rsp + 16]
    movsd [rsp + 16], xmm0
    ; Accumulate activation
    movsd xmm0, [rsi + RHDR_ACTIVATION]
    addsd xmm0, [rsp + 24]
    movsd [rsp + 24], xmm0
    ; Accumulate resonance
    movsd xmm0, [rsi + RHDR_RESONANCE]
    addsd xmm0, [rsp + 32]
    movsd [rsp + 32], xmm0

.gs_next:
    pop rcx
    inc ecx
    jmp .gs_loop

.gs_done_scan:
    ; Print connections
    lea rdi, [rel conn_lbl]
    call print_cstr
    mov edi, [rsp + 0]
    call print_u64
    call print_newline

    ; Compute averages (divide by active count)
    test r14d, r14d
    jz .gs_skip_avg

    ; Avg prime
    lea rdi, [rel avg_prime_lbl]
    call print_cstr
    cvtsi2sd xmm7, r14d      ; reload divisor (destroyed by calls)
    movsd xmm0, [rsp + 8]
    divsd xmm0, xmm7
    cvtsd2ss xmm0, xmm0      ; convert to f32 for print
    call print_f32
    call print_newline

    ; Avg activation
    lea rdi, [rel avg_activ_lbl]
    call print_cstr
    cvtsi2sd xmm7, r14d      ; reload divisor
    movsd xmm0, [rsp + 16]
    divsd xmm0, xmm7
    cvtsd2ss xmm0, xmm0
    call print_f32
    call print_newline

    ; Avg resonance
    lea rdi, [rel avg_reson_lbl]
    call print_cstr
    cvtsi2sd xmm7, r14d      ; reload divisor
    movsd xmm0, [rsp + 24]
    divsd xmm0, xmm7
    cvtsd2ss xmm0, xmm0
    call print_f32
    call print_newline
    jmp .gs_depth

.gs_skip_avg:
    ; No active regions — print zeros
    lea rdi, [rel avg_prime_lbl]
    call print_cstr
    xorps xmm0, xmm0
    call print_f32
    call print_newline
    lea rdi, [rel avg_activ_lbl]
    call print_cstr
    xorps xmm0, xmm0
    call print_f32
    call print_newline
    lea rdi, [rel avg_reson_lbl]
    call print_cstr
    xorps xmm0, xmm0
    call print_f32
    call print_newline

.gs_depth:
    ; Graph depth (last traversal)
    lea rdi, [rel graph_depth_lbl]
    call print_cstr
    mov edi, [rbx + STATE_OFFSET + ST_GRAPH_DEPTH]
    call print_u64
    call print_newline

    ; Entry table occupancy
    lea rdi, [rel entry_occ_lbl]
    call print_cstr
    lea rsi, [rbx + STATE_OFFSET + ST_ENTRY_TABLE]
    xor eax, eax              ; occupied count
    xor ecx, ecx
.gs_entry_loop:
    cmp ecx, ST_ENTRY_TABLE_CAP
    jge .gs_entry_done
    cmp qword [rsi + rcx * 8], 0
    je .gs_entry_next
    inc eax
.gs_entry_next:
    inc ecx
    jmp .gs_entry_loop
.gs_entry_done:
    mov edi, eax
    push rax
    call print_u64
    pop rax
    lea rdi, [rel of_16_lbl]
    call print_cstr
    call print_newline

    add rsp, 32
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; print_region_type(type_id)
;; edi=type
;; ============================================================
print_region_type:
    cmp edi, RTYPE_DISPATCH
    je .t_disp
    cmp edi, RTYPE_VSA_OP
    je .t_vsa
    cmp edi, RTYPE_MODIFIER
    je .t_mod
    cmp edi, RTYPE_OBSERVER
    je .t_obs
    cmp edi, RTYPE_EMITTER
    je .t_emit
    cmp edi, RTYPE_HOOK
    je .t_hook
    cmp edi, RTYPE_GATE
    je .t_gate
    cmp edi, RTYPE_DREAM
    je .t_dream
    cmp edi, RTYPE_RESONANT
    je .t_resonant
    cmp edi, RTYPE_SUBROUTINE
    je .t_subroutine
    cmp edi, RTYPE_PRESENCE
    je .t_presence
    lea rdi, [rel type_unknown]
    call print_cstr
    ret
.t_disp:
    lea rdi, [rel type_dispatch]
    call print_cstr
    ret
.t_vsa:
    lea rdi, [rel type_vsa]
    call print_cstr
    ret
.t_mod:
    lea rdi, [rel type_modifier]
    call print_cstr
    ret
.t_obs:
    lea rdi, [rel type_observer]
    call print_cstr
    ret
.t_emit:
    lea rdi, [rel type_emitter]
    call print_cstr
    ret
.t_hook:
    lea rdi, [rel type_hook]
    call print_cstr
    ret
.t_gate:
    lea rdi, [rel type_gate]
    call print_cstr
    ret
.t_dream:
    lea rdi, [rel type_dream]
    call print_cstr
    ret
.t_resonant:
    lea rdi, [rel type_resonant]
    call print_cstr
    ret
.t_subroutine:
    lea rdi, [rel type_subroutine]
    call print_cstr
    ret
.t_presence:
    lea rdi, [rel type_presence]
    call print_cstr
    ret

;; ============================================================
;; print_flags(flags)
;; edi=flags u16
;; ============================================================
print_flags:
    push rbx
    mov ebx, edi
    test ebx, RFLAG_ACTIVE
    jz .no_a
    lea rdi, [rel flag_active]
    call print_cstr
.no_a:
    test ebx, RFLAG_FROZEN
    jz .no_f
    lea rdi, [rel flag_frozen]
    call print_cstr
.no_f:
    test ebx, RFLAG_NURSERY
    jz .no_n
    lea rdi, [rel flag_nursery]
    call print_cstr
.no_n:
    test ebx, RFLAG_CONDEMNED
    jz .no_c
    lea rdi, [rel flag_condemned]
    call print_cstr
.no_c:
    pop rbx
    ret

;; ============================================================
;; repl_reset_counters
;; ============================================================
repl_reset_counters:
    push rbx
    mov rbx, SURFACE_BASE
    ; Reset global step
    lea rax, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    mov qword [rax], 0
    ; Reset token count
    lea rax, [rbx + STATE_OFFSET + ST_TOKEN_COUNT]
    mov dword [rax], 0
    ; Reset miss pos
    lea rax, [rbx + STATE_OFFSET + ST_MISS_POS]
    mov qword [rax], 0
    pop rbx
    ret

;; ============================================================
;; count_nursery_regions → eax (count of NURSERY-flagged regions)
;; ============================================================
count_nursery_regions:
    push rbx
    push r12
    mov rbx, SURFACE_BASE
    lea r12, [rbx + REGION_TABLE_OFFSET]
    mov ecx, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    xor eax, eax
    xor edx, edx
.cnr_loop:
    cmp edx, ecx
    jge .cnr_done
    push rcx
    push rdx
    imul rdi, rdx, RTE_SIZE
    add rdi, r12
    movzx ecx, word [rdi + RTE_FLAGS]
    test ecx, RFLAG_NURSERY
    jz .cnr_skip
    inc eax
.cnr_skip:
    pop rdx
    pop rcx
    inc edx
    jmp .cnr_loop
.cnr_done:
    pop r12
    pop rbx
    ret

;; ============================================================
;; print_goal(goal_id)
;; edi=goal enum
;; ============================================================
print_goal:
    cmp edi, GOAL_NONE
    je .g_none
    cmp edi, GOAL_EXPLORE
    je .g_explore
    cmp edi, GOAL_PRUNE
    je .g_prune
    cmp edi, GOAL_ALIGN
    je .g_align
    cmp edi, GOAL_CONSOLIDATE
    je .g_consolidate
    lea rdi, [rel goal_unknown_s]
    call print_cstr
    ret
.g_none:
    lea rdi, [rel goal_none_s]
    call print_cstr
    ret
.g_explore:
    lea rdi, [rel goal_explore_s]
    call print_cstr
    ret
.g_prune:
    lea rdi, [rel goal_prune_s]
    call print_cstr
    ret
.g_align:
    lea rdi, [rel goal_align_s]
    call print_cstr
    ret
.g_consolidate:
    lea rdi, [rel goal_consolidate_s]
    call print_cstr
    ret

;; ============================================================
;; repl_show_self — Semantic self-knowledge display
;; Scans regions, reports strengths (top-hit) and weaknesses (top-miss)
;; ============================================================
repl_show_self:
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub rsp, 48               ; [0-3]=top3_idx, [12-23]=top3_hits
                              ; [24-27]=bot3_idx, [36-47]=bot3_acc(f32)

    mov rbx, SURFACE_BASE
    lea r12, [rbx + REGION_TABLE_OFFSET]
    mov r13d, [rbx + STATE_OFFSET + ST_REGION_COUNT]

    ; Initialize top-3 hits to 0, bot-3 accuracy to 2.0 (above max)
    xor eax, eax
    mov [rsp + 0], eax        ; top1 idx
    mov [rsp + 4], eax        ; top2 idx
    mov [rsp + 8], eax        ; top3 idx
    mov [rsp + 12], eax       ; top1 hits
    mov [rsp + 16], eax       ; top2 hits
    mov [rsp + 20], eax       ; top3 hits
    mov eax, 0x40000000       ; 2.0f
    mov [rsp + 24], eax       ; bot1 idx (reuse as f32 placeholder)
    mov [rsp + 28], eax
    mov [rsp + 32], eax
    mov [rsp + 36], eax       ; bot1 acc
    mov [rsp + 40], eax       ; bot2 acc
    mov [rsp + 44], eax       ; bot3 acc

    xor ecx, ecx
.self_scan:
    cmp ecx, r13d
    jge .self_print
    push rcx

    imul rdi, rcx, RTE_SIZE
    add rdi, r12
    movzx eax, word [rdi + RTE_TYPE]
    cmp eax, RTYPE_DISPATCH
    jne .self_next
    movzx eax, word [rdi + RTE_FLAGS]
    test eax, RFLAG_CONDEMNED
    jnz .self_next

    mov rsi, [rdi + RTE_ADDR]
    mov eax, [rsi + RHDR_HITS]
    mov edx, [rsi + RHDR_MISSES]
    add edx, eax
    cmp edx, 2
    jl .self_next

    ; Check for top-3 by hits
    cmp eax, [rsp + 8 + 12]   ; compare with top1 hits (+8 for pushed rcx)
    jle .self_check_bot
    ; New top1 — shift down
    mov edi, [rsp + 8 + 16]   ; old top2 → top3
    mov [rsp + 8 + 20], edi
    mov edi, [rsp + 8 + 4]
    mov [rsp + 8 + 8], edi
    mov edi, [rsp + 8 + 12]   ; old top1 → top2
    mov [rsp + 8 + 16], edi
    mov edi, [rsp + 8 + 0]
    mov [rsp + 8 + 4], edi
    ; Store new top1
    mov [rsp + 8 + 12], eax
    mov eax, [rsp]            ; current idx from pushed rcx
    mov [rsp + 8 + 0], eax
    jmp .self_next

.self_check_bot:
    ; Check for bottom-3 by accuracy (weaknesses)
    mov eax, [rsi + RHDR_HITS]
    mov edx, [rsi + RHDR_MISSES]
    add edx, eax
    cvtsi2ss xmm0, eax
    cvtsi2ss xmm1, edx
    divss xmm0, xmm1         ; accuracy
    ; Compare with bot1 (lowest accuracy = worst)
    comiss xmm0, [rsp + 8 + 36]
    jae .self_next
    ; New worst — shift up
    movss xmm1, [rsp + 8 + 40]
    movss [rsp + 8 + 44], xmm1
    mov edi, [rsp + 8 + 28]
    mov [rsp + 8 + 32], edi
    movss xmm1, [rsp + 8 + 36]
    movss [rsp + 8 + 40], xmm1
    mov edi, [rsp + 8 + 24]
    mov [rsp + 8 + 28], edi
    movss [rsp + 8 + 36], xmm0
    mov eax, [rsp]
    mov [rsp + 8 + 24], eax

.self_next:
    pop rcx
    inc ecx
    jmp .self_scan

.self_print:
    ; Print header
    lea rdi, [rel self_hdr]
    call print_cstr

    ; Strengths
    lea rdi, [rel self_strength]
    call print_cstr
    ; Print top1
    mov edi, [rsp + 0]
    call print_u64
    lea rdi, [rel self_hits_lbl]
    call print_cstr
    mov edi, [rsp + 12]
    call print_u64
    call print_newline
    ; Top2
    cmp dword [rsp + 16], 0
    je .self_weak
    lea rdi, [rel self_indent]
    call print_cstr
    mov edi, [rsp + 4]
    call print_u64
    lea rdi, [rel self_hits_lbl]
    call print_cstr
    mov edi, [rsp + 16]
    call print_u64
    call print_newline

.self_weak:
    ; Weaknesses
    lea rdi, [rel self_weakness]
    call print_cstr
    mov eax, 0x40000000       ; 2.0f
    movd xmm1, eax
    comiss xmm1, [rsp + 36]
    je .self_done             ; no weaknesses found (still at init value)
    mov edi, [rsp + 24]
    call print_u64
    lea rdi, [rel self_acc_lbl]
    call print_cstr
    movss xmm0, [rsp + 36]
    call print_f32
    call print_newline
    ; Weakness 2
    mov eax, 0x40000000
    movd xmm1, eax
    comiss xmm1, [rsp + 40]
    je .self_done
    lea rdi, [rel self_indent]
    call print_cstr
    mov edi, [rsp + 28]
    call print_u64
    lea rdi, [rel self_acc_lbl]
    call print_cstr
    movss xmm0, [rsp + 40]
    call print_f32
    call print_newline

.self_done:
    ; Also show trace-based context type confidence
    call print_newline
    call self_show_context_types

    add rsp, 48
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; print_intro_state(state_id)
;; edi=state enum
;; ============================================================
print_intro_state:
    cmp edi, INTRO_IDLE
    je .is_idle
    cmp edi, INTRO_CONFUSED
    je .is_confused
    cmp edi, INTRO_CONFIDENT
    je .is_confident
    cmp edi, INTRO_LEARNING
    je .is_learning
    cmp edi, INTRO_STUCK
    je .is_stuck
    cmp edi, INTRO_EXPLORING
    je .is_exploring
    cmp edi, INTRO_CONSOLIDATING
    je .is_consolidating
    lea rdi, [rel intro_unknown]
    call print_cstr
    ret
.is_idle:
    lea rdi, [rel intro_idle_s]
    call print_cstr
    ret
.is_confused:
    lea rdi, [rel intro_confused_s]
    call print_cstr
    ret
.is_confident:
    lea rdi, [rel intro_confident_s]
    call print_cstr
    ret
.is_learning:
    lea rdi, [rel intro_learning_s]
    call print_cstr
    ret
.is_stuck:
    lea rdi, [rel intro_stuck_s]
    call print_cstr
    ret
.is_exploring:
    lea rdi, [rel intro_exploring_s]
    call print_cstr
    ret
.is_consolidating:
    lea rdi, [rel intro_consolidating_s]
    call print_cstr
    ret

;; ============================================================
;; print_dispatch_mode(mode_id)
;; edi=mode enum
;; ============================================================
print_dispatch_mode:
    cmp edi, DMODE_FAST
    je .dm_fast
    cmp edi, DMODE_BEST
    je .dm_best
    cmp edi, DMODE_EXPLORE
    je .dm_explore
    cmp edi, DMODE_DELIBERATE
    je .dm_deliberate
    lea rdi, [rel dmode_unknown_s]
    call print_cstr
    ret
.dm_fast:
    lea rdi, [rel dmode_fast_s]
    call print_cstr
    ret
.dm_best:
    lea rdi, [rel dmode_best_s]
    call print_cstr
    ret
.dm_explore:
    lea rdi, [rel dmode_explore_s]
    call print_cstr
    ret
.dm_deliberate:
    lea rdi, [rel dmode_deliberate_s]
    call print_cstr
    ret

;; ============================================================
;; print_surprise_type(type_id)
;; edi=surprise type enum
;; ============================================================
print_surprise_type:
    cmp edi, SURPRISE_NONE
    je .st_none
    cmp edi, SURPRISE_OUTCOME
    je .st_outcome
    cmp edi, SURPRISE_SELF
    je .st_self
    lea rdi, [rel surprise_unknown_s]
    call print_cstr
    ret
.st_none:
    lea rdi, [rel surprise_none_s]
    call print_cstr
    ret
.st_outcome:
    lea rdi, [rel surprise_outcome_s]
    call print_cstr
    ret
.st_self:
    lea rdi, [rel surprise_self_s]
    call print_cstr
    ret

section .rodata
    compact_msg:    db "Compacted regions: ", 0
    colon_space:    db ": ", 0
    slash_char:     db "/", 0
    type_dispatch:  db "DISPATCH", 0
    type_vsa:       db "VSA_OP  ", 0
    type_modifier:  db "MODIFIER", 0
    type_observer:  db "OBSERVER", 0
    type_emitter:   db "EMITTER ", 0
    type_hook:      db "HOOK    ", 0
    type_gate:      db "GATE    ", 0
    type_dream:     db "DREAM   ", 0
    type_resonant:  db "RESONANT", 0
    type_subroutine: db "SUBROUT ", 0
    type_presence:  db "PRESENCE", 0
    type_unknown:   db "UNKNOWN ", 0
    flag_active:    db "[A]", 0
    flag_frozen:    db "[F]", 0
    flag_nursery:   db "[N]", 0
    flag_condemned: db "[C]", 0
    intro_lbl:      db "  State: ", 0
    selfpred_lbl:   db "  Self-pred: ", 0
    schema_lbl:     db "  Schema: ", 0
    dmode_lbl:      db "  Dispatch: ", 0
    intro_idle_s:       db "IDLE", 0
    intro_confused_s:   db "CONFUSED", 0
    intro_confident_s:  db "CONFIDENT", 0
    intro_learning_s:   db "LEARNING", 0
    intro_stuck_s:      db "STUCK", 0
    intro_exploring_s:  db "EXPLORING", 0
    intro_consolidating_s: db "CONSOLIDATING", 0
    intro_unknown:      db "UNKNOWN", 0
    dmode_fast_s:       db "FAST", 0
    dmode_best_s:       db "BEST", 0
    dmode_explore_s:    db "EXPLORE", 0
    dmode_deliberate_s: db "DELIBERATE", 0
    dmode_unknown_s:    db "UNKNOWN", 0
    surprise_lbl:       db "  Surprise: ", 0
    causal_lbl:         db "  Causal: ", 0
    hypo_lbl:           db "  Hypotheses: ", 0
    trace_lbl:          db "  Trace: ", 0
    trace_sep:          db " candidates, ", 0
    goal_lbl:           db "  Goal: ", 0
    variance_lbl:       db "  Variance: ", 0
    expect_lbl:         db "  Expect: conf=", 0
    expect_schema:      db " [SCHEMA]", 0
    expect_none:        db "none", 0
    surprise_none_s:    db "NONE", 0
    surprise_outcome_s: db "OUTCOME", 0
    surprise_self_s:    db "SELF", 0
    surprise_unknown_s: db "UNKNOWN", 0
    goal_none_s:        db "NONE", 0
    goal_explore_s:     db "EXPLORE", 0
    goal_prune_s:       db "PRUNE", 0
    goal_align_s:       db "ALIGN", 0
    goal_consolidate_s: db "CONSOLIDATE", 0
    goal_unknown_s:     db "UNKNOWN", 0
    self_hdr:           db "--- Self-Knowledge ---", 10, 0
    self_strength:      db "  Strengths: region ", 0
    self_weakness:      db "  Weaknesses: region ", 0
    self_hits_lbl:      db " (hits=", 0
    self_acc_lbl:       db " (acc=", 0
    self_indent:        db "             region ", 0
    ; Holographic memory labels
    holo_vocab_lbl:     db "  Vocabulary: ", 0
    holo_density_lbl:   db "  Holo density: ", 0
    holo_conf_lbl:      db "  Holo confidence: ", 0
    holo_conf_n_lbl:    db " (n=", 0
    holo_conf_end:      db ")", 0
    ; Graph dynamics labels
    conn_lbl:           db "  Connections: ", 0
    avg_prime_lbl:      db "  Avg prime: ", 0
    avg_activ_lbl:      db "  Avg activation: ", 0
    avg_reson_lbl:      db "  Avg resonance: ", 0
    graph_depth_lbl:    db "  Graph depth: ", 0
    entry_occ_lbl:      db "  Entry table: ", 0
    of_16_lbl:          db "/16", 0
; signal.asm — Fault handling: SIGSEGV/SIGFPE/SIGBUS recovery to REPL
;
; @entry install_fault_handlers() -> void
; @entry get_fault_count() -> rax=count
; @entry set_sigpipe_mode(edi=mode) -> void  ; 0=exit, 1=ignore (TCP mode)
; @entry bp_inject(rdi=addr, rsi=handler) -> void
; @entry bp_remove(rdi=addr) -> void
; @calledby boot.asm:_start (install)
; @calledby channels.asm:channels_init (set TCP mode)
; @calledby io.asm:digest_file (safe point setup)
;
; FLOW: fault → handler → check fault_safe_rsp → longjmp to REPL
; STATE: fault_safe_rsp, fault_safe_rip, fault_count, bp_table, sigpipe_mode
;
; BREAKPOINT SYSTEM:
;   INT3 injection for learning from struggling regions
;   On trap: call handler, restore byte, single-step, re-inject
;
; GOTCHAS:
;   - MUST save fault_safe_rsp/rip BEFORE calling code that might fault
;   - After fault recovery, r14 (SURFACE_BASE) may be clobbered - reload it
;   - Max 3 consecutive faults before forced return (anti-loop)
;   - Breakpoint handler must preserve all regs except rax
;   - SIGPIPE: mode 0 exits (interactive), mode 1 ignores (TCP) - set by channels_init
;
%include "syscalls.inc"
%include "constants.inc"

section .data
    fault_msg:      db "[FAULT] Signal ", 0
    fault_at_msg:   db " at RIP=0x", 0
    fault_addr_msg: db " ADDR=0x", 0
    fault_nl:       db 10, 0
    fault_count:    dq 0              ; total faults caught
    consec_faults:  dq 0              ; consecutive fault counter
    max_consec:     equ 3             ; max consecutive faults before forced return
    fault_recover_msg: db "[FAULT] Recovery — returning to REPL", 10, 0

    ; SIGPIPE mode: 0 = exit (interactive), 1 = ignore (TCP mode)
    global sigpipe_mode
    sigpipe_mode:   dd 0
    sigpipe_ignore_msg: db "[SIGPIPE] Ignored (TCP mode)", 10, 0

    ; Self-debugger messages
    trap_msg:       db "[TRAP] Breakpoint at RIP=0x", 0
    trap_rax_msg:   db " RAX=0x", 0
    trap_ctx_msg:   db " CTX=0x", 0
    trap_learn_msg: db " → Learning event", 10, 0
    trap_mismatch:  db " MISMATCH expected=0x", 0

section .bss
    global fault_safe_rsp
    fault_safe_rsp: resq 1            ; saved RSP for crash recovery
    global fault_safe_rip
    fault_safe_rip: resq 1            ; saved RIP for crash recovery (repl loop head)

section .data

section .text

extern print_cstr
extern print_u64
extern print_hex64
extern print_newline
extern sys_sigaction
extern journey_dump

;; ============================================================
;; install_fault_handlers
;; Sets up SIGSEGV, SIGFPE, SIGBUS handlers
;; ============================================================
global install_fault_handlers
install_fault_handlers:
    push rbx

    ; Set up sigaction struct on stack
    ; struct sigaction { handler, flags, restorer, sa_mask }
    sub rsp, 152              ; sizeof(struct sigaction) = 152 on x86_64

    ; handler = fault_handler
    lea rax, [rel fault_handler]
    mov [rsp], rax            ; sa_handler
    mov qword [rsp + 8], SA_SIGINFO | SA_RESTORER  ; sa_flags
    lea rax, [rel sig_restorer]
    mov [rsp + 16], rax       ; sa_restorer
    ; zero sa_mask
    xor eax, eax
    mov [rsp + 24], rax
    mov [rsp + 32], rax
    mov [rsp + 40], rax
    mov [rsp + 48], rax

    ; Install for SIGSEGV
    mov edi, SIGSEGV
    lea rsi, [rsp]            ; new action
    xor edx, edx              ; no old action
    mov r10, 8                ; sigsetsize
    mov rax, SYS_RT_SIGACTION
    syscall

    ; Install for SIGFPE
    mov edi, SIGFPE
    lea rsi, [rsp]
    xor edx, edx
    mov r10, 8
    mov rax, SYS_RT_SIGACTION
    syscall

    ; Install for SIGBUS
    mov edi, SIGBUS
    lea rsi, [rsp]
    xor edx, edx
    mov r10, 8
    mov rax, SYS_RT_SIGACTION
    syscall

    ; Install for SIGILL
    mov edi, SIGILL
    lea rsi, [rsp]
    xor edx, edx
    mov r10, 8
    mov rax, SYS_RT_SIGACTION
    syscall

    ; Install for SIGPIPE (broken pipe — stdout closed)
    mov edi, SIGPIPE
    lea rsi, [rsp]
    xor edx, edx
    mov r10, 8
    mov rax, SYS_RT_SIGACTION
    syscall

    ; Install for SIGTRAP (INT 3 breakpoints — self-debugger)
    mov edi, SIGTRAP
    lea rsi, [rsp]
    xor edx, edx
    mov r10, 8
    mov rax, SYS_RT_SIGACTION
    syscall

    add rsp, 152
    pop rbx
    ret

;; ============================================================
;; fault_return_stub — Safe return point for faulting regions
;; Returns 0 (miss) to the caller that dispatched into surface code
;; ============================================================
global fault_return_stub
fault_return_stub:
    xor eax, eax
    ret

;; ============================================================
;; fault_handler(signum, siginfo, ucontext)
;; SA_SIGINFO handler: rdi=signum, rsi=siginfo*, rdx=ucontext*
;; ============================================================
fault_handler:
    ; Save all registers
    push rax
    push rbx
    push rcx
    push rdx
    push rsi
    push rdi
    push rbp
    push r8
    push r9
    push r10
    push r11
    push r12
    push r13
    push r14
    push r15

    ; Increment fault counter
    inc qword [rel fault_count]

    ; Print fault message
    mov rbx, rdi              ; save signum
    mov r13, rsi              ; save siginfo_t pointer
    mov r12, rdx              ; save ucontext

    lea rdi, [rel fault_msg]
    call print_cstr

    ; Print signal number
    mov rdi, rbx
    call print_u64

    lea rdi, [rel fault_at_msg]
    call print_cstr

    ; Get RIP from ucontext (offset 168 in ucontext_t.uc_mcontext.gregs[REG_RIP])
    mov rdi, [r12 + 168]
    call print_hex64

    ; Print faulting address (si_addr at offset 16 in siginfo_t)
    lea rdi, [rel fault_addr_msg]
    call print_cstr
    mov rdi, [r13 + 16]       ; si_addr = memory address that caused fault
    call print_hex64
    call print_newline

    ; Dump trace buffer (shows execution path leading to fault)
    call journey_dump

    ; Special case: SIGPIPE = stdout closed
    cmp ebx, SIGPIPE
    jne .not_sigpipe
    ; Check sigpipe_mode: 0=exit, 1=ignore
    cmp dword [rel sigpipe_mode], 0
    je .exit_clean
    ; TCP mode: print message and continue
    lea rdi, [rel sigpipe_ignore_msg]
    call print_cstr
    jmp .handler_done
.not_sigpipe:

    ; Special case: SIGTRAP = INT 3 breakpoint (self-debugger)
    cmp ebx, SIGTRAP
    je .handle_trap

    ; Recovery strategy based on fault location
    mov rax, [r12 + 168]      ; faulting RIP

    ; Check if the faulting address is in the surface
    mov rcx, SURFACE_BASE
    cmp rax, rcx
    jb .outside_surface
    mov rcx, SURFACE_BASE + SURFACE_SIZE  ; single 64-bit immediate (avoids sign-extension)
    cmp rax, rcx
    ja .outside_surface

    ; --- SURFACE FAULT: redirect to safe return stub ---
    ; Instead of stepping through bad code byte by byte, redirect
    ; RIP to fault_return_stub which does "xor eax,eax; ret"
    ; This cleanly returns a "miss" to whatever called into the surface
    lea rax, [rel fault_return_stub]
    mov [r12 + 168], rax
    ; Clear RAX in ucontext so the stub returns 0
    ; RAX is at offset 144 in uc_mcontext.gregs (REG_RAX = index 13, offset 13*8=104...
    ; actually on x86_64 Linux: gregs[REG_RAX] is at offset 144 from uc_mcontext)
    ; Reset consecutive counter
    mov qword [rel consec_faults], 0
    jmp .handler_done

.outside_surface:
    ; --- APPLICATION CODE FAULT ---
    ; This shouldn't happen normally. Use consecutive counter to prevent infinite loops.
    inc qword [rel consec_faults]
    cmp qword [rel consec_faults], max_consec
    jg .force_return

    ; Try to advance past the faulting instruction with proper length decoding
    movzx ecx, byte [rax]

    ; Check for common multi-byte prefixes
    ; REX prefix (0x40-0x4F)
    cmp cl, 0x40
    jl .no_rex
    cmp cl, 0x4F
    jg .no_rex
    add rax, 1
    movzx ecx, byte [rax]
.no_rex:
    ; F2/F3 prefix (SSE)
    cmp cl, 0xF2
    je .sse_prefix
    cmp cl, 0xF3
    je .sse_prefix
    jmp .check_opcode
.sse_prefix:
    add rax, 1
    movzx ecx, byte [rax]
    ; After F2/F3, check for 0F escape
    cmp cl, 0x0F
    jne .check_opcode
    ; F2 0F xx or F3 0F xx = 3+ byte opcode, skip at least 4 more
    add rax, 5               ; skip 0F + opcode + modrm + at least 1
    jmp .set_rip
.check_opcode:
    ; 0F escape (two-byte opcode)
    cmp cl, 0x0F
    jne .one_byte
    add rax, 4               ; 0F + opcode + modrm + sib/disp (estimate)
    jmp .set_rip
.one_byte:
    cmp cl, 0x90              ; NOP
    je .skip1
    cmp cl, 0xC3              ; RET
    je .skip1
    cmp cl, 0xFF              ; inc/call/jmp indirect (modrm + sib + disp32)
    je .skip7
    ; Default: skip 3 bytes (opcode + modrm + sib is common)
    add rax, 3
    jmp .set_rip
.skip1:
    inc rax
    jmp .set_rip
.skip7:
    add rax, 7
    jmp .set_rip

.force_return:
    ; Too many consecutive faults — longjmp back to REPL loop
    mov qword [rel consec_faults], 0

    ; Check if we have a saved recovery point
    mov rax, [rel fault_safe_rsp]
    test rax, rax
    jz .force_stub            ; no recovery point saved, use stub

    ; Restore RSP and RIP from saved recovery point
    ; RSP is at offset 160 in ucontext (gregs[15])
    ; RIP is at offset 168 in ucontext (gregs[16])
    mov [r12 + 160], rax      ; restore RSP
    mov rax, [rel fault_safe_rip]
    mov [r12 + 168], rax      ; restore RIP
    jmp .handler_done

.force_stub:
    lea rax, [rel fault_return_stub]

.set_rip:
    mov [r12 + 168], rax      ; update RIP in ucontext

.handle_trap:
    ; --- SIGTRAP: INT 3 breakpoint hit (Self-Debugger) ---
    ; This is a LEARNING EVENT, not a crash!
    ; RIP points to instruction AFTER INT 3 (which was 1 byte)
    mov r13, [r12 + 168]      ; RIP after INT 3
    dec r13                   ; back up to INT 3 location
    mov r14, [r12 + 144]      ; RAX value at breakpoint

    ; Print trap message
    lea rdi, [rel trap_msg]
    call print_cstr
    mov rdi, r13
    call print_hex64
    lea rdi, [rel trap_rax_msg]
    call print_cstr
    mov rdi, r14
    call print_hex64

    ; Increment trap hit counter
    mov rax, SURFACE_BASE
    inc dword [rax + STATE_OFFSET + ST_BP_TOTAL_HITS]

    ; Look up breakpoint in table
    mov rdi, r13              ; breakpoint address
    call bp_find_by_addr
    test rax, rax
    jz .trap_unknown          ; not in our table

    ; Found breakpoint entry in rax
    mov r15, rax              ; save entry ptr

    ; Increment trigger count
    inc word [r15 + BPE_TRIGGER_COUNT]

    ; Store actual RAX value
    mov [r15 + BPE_LAST_RAX], r14d

    ; Check for mismatch with expected value
    mov ecx, [r15 + BPE_EXPECTED_RAX]
    cmp ecx, r14d
    je .trap_match

    ; MISMATCH: This is where we learn!
    lea rdi, [rel trap_mismatch]
    call print_cstr
    mov edi, ecx
    call print_hex64

    ; Generate learning event
    mov rax, SURFACE_BASE
    inc dword [rax + STATE_OFFSET + ST_BP_LEARNING_EVENTS]

    ; Mark breakpoint as learning
    or word [r15 + BPE_FLAGS], BPFLAG_LEARNING

.trap_match:
    lea rdi, [rel trap_learn_msg]
    call print_cstr

    ; Restore original byte and continue execution
    movzx eax, byte [r15 + BPE_ORIG_BYTE]
    mov [r13], al             ; restore original instruction byte

    ; RIP already points past INT 3, but we restored the original byte
    ; at the INT 3 location, so we need to re-execute that instruction
    mov [r12 + 168], r13      ; set RIP back to the restored instruction

    jmp .handler_done

.trap_unknown:
    ; Unknown breakpoint — just skip past it
    lea rdi, [rel trap_learn_msg]
    call print_cstr
    ; RIP already points past INT 3, so we can just continue
    jmp .handler_done

.exit_clean:
    ; SIGPIPE or fatal — exit process cleanly
    mov edi, 0
    mov rax, SYS_EXIT
    syscall

.handler_done:
    ; Restore registers
    pop r15
    pop r14
    pop r13
    pop r12
    pop r11
    pop r10
    pop r9
    pop r8
    pop rbp
    pop rdi
    pop rsi
    pop rdx
    pop rcx
    pop rbx
    pop rax
    ret

;; ============================================================
;; sig_restorer — required for SA_RESTORER
;; ============================================================
sig_restorer:
    mov rax, SYS_RT_SIGRETURN
    syscall

;; ============================================================
;; get_fault_count → rax
;; ============================================================
global get_fault_count
get_fault_count:
    mov rax, [rel fault_count]
    ret

;; ============================================================
;; set_sigpipe_mode(edi=mode) → void
;; mode: 0 = exit on SIGPIPE (interactive mode)
;;       1 = ignore SIGPIPE (TCP mode)
;; ============================================================
global set_sigpipe_mode
set_sigpipe_mode:
    mov [rel sigpipe_mode], edi
    ret

;; ============================================================
;; Self-Debugger: Breakpoint Management Functions
;; ============================================================

;; ============================================================
;; bp_init()
;; Initialize breakpoint table to zero.
;; ============================================================
global bp_init
bp_init:
    mov rdi, SURFACE_BASE + BREAKPOINT_TABLE_OFFSET
    xor eax, eax
    mov ecx, BREAKPOINT_TABLE_SIZE / 8
.bp_init_loop:
    mov [rdi], rax
    add rdi, 8
    dec ecx
    jnz .bp_init_loop
    ; Clear state counters
    mov rax, SURFACE_BASE
    mov dword [rax + STATE_OFFSET + ST_BREAKPOINT_COUNT], 0
    mov dword [rax + STATE_OFFSET + ST_BP_TOTAL_HITS], 0
    mov dword [rax + STATE_OFFSET + ST_BP_LEARNING_EVENTS], 0
    ret

;; ============================================================
;; bp_find_by_addr(addr) → rax (entry ptr or 0)
;; rdi = code address where INT 3 was hit
;; Returns pointer to breakpoint entry, or 0 if not found.
;; ============================================================
global bp_find_by_addr
bp_find_by_addr:
    mov rsi, SURFACE_BASE + BREAKPOINT_TABLE_OFFSET
    xor ecx, ecx             ; index

.bp_find_loop:
    cmp ecx, BREAKPOINT_MAX
    jge .bp_find_not_found

    ; Check if entry is active
    mov eax, [rsi + BPE_FLAGS]
    test eax, BPFLAG_ACTIVE
    jz .bp_find_next

    ; Calculate breakpoint address: region_ptr + RHDR_SIZE + code_offset
    mov rax, [rsi + BPE_REGION_PTR]
    add rax, RHDR_SIZE
    mov edx, [rsi + BPE_CODE_OFFSET]
    add rax, rdx

    ; Compare with target address
    cmp rax, rdi
    je .bp_find_found

.bp_find_next:
    add rsi, BREAKPOINT_ENTRY_SIZE
    inc ecx
    jmp .bp_find_loop

.bp_find_found:
    mov rax, rsi
    ret

.bp_find_not_found:
    xor eax, eax
    ret

;; ============================================================
;; bp_inject(region_ptr, code_offset, bp_type, expected_rax) → eax (1=success, 0=fail)
;; rdi = region header pointer
;; esi = offset into region code (after RHDR_SIZE)
;; edx = breakpoint type (BPTYPE_*)
;; ecx = expected RAX value at this point
;; Injects INT 3 (0xCC) at the specified location.
;; ============================================================
global bp_inject
bp_inject:
    push rbx
    push r12
    push r13
    push r14

    mov r12, rdi              ; region_ptr
    mov r13d, esi             ; code_offset
    mov r14d, edx             ; bp_type
    mov ebx, ecx              ; expected_rax

    ; Find empty slot in breakpoint table
    mov rdi, SURFACE_BASE + BREAKPOINT_TABLE_OFFSET
    xor ecx, ecx

.bp_inject_find:
    cmp ecx, BREAKPOINT_MAX
    jge .bp_inject_full

    mov eax, [rdi + BPE_FLAGS]
    test eax, BPFLAG_ACTIVE
    jz .bp_inject_slot_found

    add rdi, BREAKPOINT_ENTRY_SIZE
    inc ecx
    jmp .bp_inject_find

.bp_inject_slot_found:
    ; rdi = empty slot
    ; Calculate actual code address
    lea rax, [r12 + RHDR_SIZE]
    add rax, r13              ; rax = code address

    ; Save original byte
    movzx edx, byte [rax]
    mov [rdi + BPE_ORIG_BYTE], dl

    ; Fill in breakpoint entry
    mov [rdi + BPE_REGION_PTR], r12
    mov [rdi + BPE_CODE_OFFSET], r13d
    mov [rdi + BPE_TYPE], r14b
    mov word [rdi + BPE_TRIGGER_COUNT], 0
    mov [rdi + BPE_EXPECTED_RAX], ebx
    ; Get current context hash for expected_ctx
    mov rax, SURFACE_BASE
    mov edx, [rax + STATE_OFFSET + ST_CTX_HASH]
    mov [rdi + BPE_EXPECTED_CTX], edx
    mov dword [rdi + BPE_LAST_RAX], 0
    mov dword [rdi + BPE_FLAGS], BPFLAG_ACTIVE

    ; Inject INT 3 (0xCC)
    lea rax, [r12 + RHDR_SIZE]
    add rax, r13
    mov byte [rax], 0xCC

    ; Increment breakpoint count
    mov rax, SURFACE_BASE
    inc dword [rax + STATE_OFFSET + ST_BREAKPOINT_COUNT]

    mov eax, 1                ; success
    jmp .bp_inject_done

.bp_inject_full:
    xor eax, eax              ; failure

.bp_inject_done:
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; bp_remove(region_ptr) → eax (1=removed, 0=not found)
;; rdi = region header pointer
;; Removes all breakpoints for this region and restores original bytes.
;; ============================================================
global bp_remove
bp_remove:
    push rbx
    push r12

    mov r12, rdi              ; region_ptr
    xor ebx, ebx              ; removed count

    mov rsi, SURFACE_BASE + BREAKPOINT_TABLE_OFFSET
    xor ecx, ecx

.bp_remove_loop:
    cmp ecx, BREAKPOINT_MAX
    jge .bp_remove_done

    ; Check if entry is active and matches region
    mov eax, [rsi + BPE_FLAGS]
    test eax, BPFLAG_ACTIVE
    jz .bp_remove_next

    cmp [rsi + BPE_REGION_PTR], r12
    jne .bp_remove_next

    ; Found matching entry — restore original byte
    lea rax, [r12 + RHDR_SIZE]
    mov edx, [rsi + BPE_CODE_OFFSET]
    add rax, rdx
    movzx edx, byte [rsi + BPE_ORIG_BYTE]
    mov [rax], dl

    ; Clear entry
    mov dword [rsi + BPE_FLAGS], 0
    mov qword [rsi + BPE_REGION_PTR], 0

    ; Decrement breakpoint count
    mov rax, SURFACE_BASE
    dec dword [rax + STATE_OFFSET + ST_BREAKPOINT_COUNT]

    inc ebx

.bp_remove_next:
    add rsi, BREAKPOINT_ENTRY_SIZE
    inc ecx
    jmp .bp_remove_loop

.bp_remove_done:
    mov eax, ebx
    pop r12
    pop rbx
    ret

;; ============================================================
;; bp_inject_struggling(region_ptr) → eax (1=injected, 0=already has bp or fail)
;; rdi = region header pointer
;; Injects breakpoints at key decision points in a "struggling" region.
;; A struggling region has high miss rate but has received significant traffic.
;; ============================================================
global bp_inject_struggling
bp_inject_struggling:
    push rbx
    push r12
    push r13

    mov r12, rdi              ; region_ptr

    ; Check if region already has breakpoints
    mov rdi, r12
    call bp_has_breakpoints
    test eax, eax
    jnz .bp_struggling_skip   ; already has breakpoints

    ; Get region code length
    movzx eax, word [r12 + RHDR_CODE_LEN]
    cmp eax, 5                ; need at least 5 bytes for meaningful bp
    jl .bp_struggling_skip

    ; Inject at entry (offset 0) — see context hash in RAX before CMP
    mov rdi, r12
    xor esi, esi              ; offset 0
    mov edx, BPTYPE_STRUGGLING
    ; Expected RAX is the context we're checking for
    ; Read it from the CMP instruction if present
    lea rax, [r12 + RHDR_SIZE]
    cmp byte [rax], 0x3D      ; CMP EAX, imm32?
    jne .bp_struggling_no_cmp
    mov ecx, [rax + 1]        ; the immediate value
    jmp .bp_struggling_inject

.bp_struggling_no_cmp:
    xor ecx, ecx              ; unknown expected value

.bp_struggling_inject:
    call bp_inject
    mov r13d, eax             ; save result

    ; If first bp succeeded, also inject at decision point (after CMP, offset 5)
    test r13d, r13d
    jz .bp_struggling_done

    movzx eax, word [r12 + RHDR_CODE_LEN]
    cmp eax, 7                ; need space for second bp
    jl .bp_struggling_done

    mov rdi, r12
    mov esi, 5                ; after CMP EAX, imm32
    mov edx, BPTYPE_DECISION
    xor ecx, ecx              ; no specific expected value
    call bp_inject

    mov eax, 1
    jmp .bp_struggling_done

.bp_struggling_skip:
    xor eax, eax

.bp_struggling_done:
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; bp_has_breakpoints(region_ptr) → eax (1=has bp, 0=no bp)
;; rdi = region header pointer
;; ============================================================
global bp_has_breakpoints
bp_has_breakpoints:
    mov rsi, SURFACE_BASE + BREAKPOINT_TABLE_OFFSET
    xor ecx, ecx

.bp_has_loop:
    cmp ecx, BREAKPOINT_MAX
    jge .bp_has_no

    mov eax, [rsi + BPE_FLAGS]
    test eax, BPFLAG_ACTIVE
    jz .bp_has_next

    cmp [rsi + BPE_REGION_PTR], rdi
    je .bp_has_yes

.bp_has_next:
    add rsi, BREAKPOINT_ENTRY_SIZE
    inc ecx
    jmp .bp_has_loop

.bp_has_yes:
    mov eax, 1
    ret

.bp_has_no:
    xor eax, eax
    ret
; surface.asm — Surface memory: mmap, region allocation, compaction
;
; ENTRY POINTS:
;   surface_init()                    → rax=surface base (mmaps persistent file)
;   region_alloc(size)                → rax=ptr to new region header
;   region_condemn(idx)               - mark region for death (extracts gene first)
;   region_compact()                  - reclaim condemned regions
;   region_find_by_addr(addr)         → rax=region_idx or -1
;   region_merge_pass()               - merge compatible adjacent regions
;   get_surface_base()                → rax=SURFACE_BASE
;   get_state_ptr()                   → rax=state block address
;   get_vsa_base()                    → rax=VSA arena base
;   surface_freeze()                  - mark surface read-only (safety)
;   surface_init_shared()             - init /dev/shm Mycorrhiza shared memory
;   broadcast_pain(intensity)         - share pain to colony (if shared mode)
;   sense_collective_valence()        → xmm0=colony average valence
;   get_colony_size()                 → eax=number of connected instances
;   is_shared_mode()                  → eax=1 if running with Mycorrhiza
;
; MEMORY LAYOUT (100GB sparse file "uhma.surface"):
;   [0, STATE_OFFSET)         - dispatch regions (code)
;   [STATE_OFFSET, +64KB)     - state block (counters, hooks, drives)
;   [REGION_TABLE_OFFSET, +)  - region table (index of all regions)
;   [VSA_ARENA_OFFSET, +)     - holographic memory (vocab, traces)
;
; PERSISTENCE:
;   File opened O_CREAT|O_RDWR, mmap'd MAP_SHARED
;   Session count incremented on each load (tracks restarts)
;   Total steps preserved across sessions
;
; CALLED BY: boot.asm (init), emit.asm (region_alloc), everywhere
;
%include "syscalls.inc"
%include "constants.inc"

section .data
    ; Persistent surface file path
    surface_path:   db "uhma.surface", 0

    ; Startup messages
    surf_msg:       db "[SURFACE] ", 0
    surf_loading:   db "Loading persistent memory from uhma.surface", 10, 0
    surf_creating:  db "Creating new persistent memory (100GB sparse)", 10, 0
    surf_sessions:  db "Session #", 0
    surf_steps:     db " (", 0
    surf_steps2:    db " total steps)", 10, 0
    surf_fresh:     db "Fresh start - initializing holographic traces", 10, 0
    surf_recovered: db "Recovered ", 0
    surf_regions:   db " regions, ", 0
    surf_vocab:     db " vocabulary entries", 10, 0

    ; Shared memory paths for Mycorrhiza (collective consciousness)
    shm_vsa_path:   db "/dev/shm/uhma_vsa", 0
    shm_holo_path:  db "/dev/shm/uhma_holo", 0
    shm_msg:        db "[MYCORRHIZA] ", 0
    shm_create:     db "Creating shared VSA field", 10, 0
    shm_attach:     db "Attaching to shared VSA field", 10, 0
    shm_solo:       db "Running in solo mode (no shared field)", 10, 0
    shm_instance:   db "Instance ID: 0x", 0

section .text

extern sys_mmap
extern sys_open
extern sys_close
extern sys_getrandom
extern sym_init
extern bp_init
extern gene_pool_init
extern presence_init
extern receipt_init
extern print_cstr
extern print_hex64
extern print_u64
extern print_newline

;; ============================================================
;; surface_init
;; Open/create persistent surface file, mmap it, conditionally init
;; Learning survives restarts - uses 100GB sparse file
;; Returns: surface base in rax (or exits on failure)
;; ============================================================
global surface_init
surface_init:
    push rbx
    push r12
    push r13
    push r14
    sub rsp, 8                ; alignment

    ; Print startup message
    lea rdi, [rel surf_msg]
    call print_cstr

    ; Open/create surface file
    lea rdi, [rel surface_path]
    mov esi, O_RDWR | O_CREAT ; read/write, create if not exists
    mov edx, 0644o            ; permissions
    mov rax, SYS_OPEN
    syscall
    test rax, rax
    js .open_fail
    mov r12, rax              ; save fd

    ; ftruncate to set file size (sparse - only touched pages use disk)
    mov rdi, r12              ; fd
    mov rsi, SURFACE_SIZE     ; 100GB
    mov rax, SYS_FTRUNCATE
    syscall
    ; ignore errors - might be read-only filesystem

    ; mmap the file as shared RWX at fixed address
    mov rdi, SURFACE_BASE     ; hint address
    mov rsi, SURFACE_SIZE     ; 100GB
    mov rdx, PROT_RWX
    mov rcx, MAP_SHARED | MAP_FIXED  ; persist writes to file
    mov r8, r12               ; fd
    xor r9d, r9d              ; offset = 0
    call sys_mmap

    ; Check for MAP_FAILED (-1)
    cmp rax, -1
    je .mmap_fail
    mov rbx, rax              ; save surface base

    ; Close fd (mapping persists)
    mov rdi, r12
    mov rax, SYS_CLOSE
    syscall

    ; Check magic number - is this a valid surface?
    mov rax, [rbx + BOOTSTRAP_OFFSET + SHDR_MAGIC]
    mov rcx, SURFACE_MAGIC
    cmp rax, rcx
    jne .fresh_init

    ; --- EXISTING SURFACE: Load and continue ---
    lea rdi, [rel surf_loading]
    call print_cstr

    ; Increment session count
    inc qword [rbx + BOOTSTRAP_OFFSET + SHDR_SESSION_COUNT]

    ; Update last open timestamp
    xor edi, edi
    xor esi, esi
    mov rax, SYS_GETTIMEOFDAY
    lea rdi, [rsp]
    syscall
    mov rax, [rsp]            ; seconds
    mov [rbx + BOOTSTRAP_OFFSET + SHDR_LAST_OPEN], rax

    ; Print session info
    lea rdi, [rel surf_msg]
    call print_cstr
    lea rdi, [rel surf_sessions]
    call print_cstr
    mov rdi, [rbx + BOOTSTRAP_OFFSET + SHDR_SESSION_COUNT]
    call print_u64
    lea rdi, [rel surf_steps]
    call print_cstr
    mov rdi, [rbx + BOOTSTRAP_OFFSET + SHDR_TOTAL_STEPS]
    call print_u64
    lea rdi, [rel surf_steps2]
    call print_cstr

    ; Print recovery info
    lea rdi, [rel surf_msg]
    call print_cstr
    lea rdi, [rel surf_recovered]
    call print_cstr
    mov edi, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    call print_u64
    lea rdi, [rel surf_regions]
    call print_cstr
    mov edi, [rbx + STATE_OFFSET + ST_VOCAB_COUNT]
    call print_u64
    lea rdi, [rel surf_vocab]
    call print_cstr

    ; Re-initialize dispatch pointer to end of existing regions
    ; (regions survive but we need to find where to allocate next)
    call .recalc_dispatch_ptr

    ; Re-init subsystems that need runtime state
    jmp .init_subsystems

.fresh_init:
    ; --- NEW SURFACE: Initialize everything ---
    lea rdi, [rel surf_creating]
    call print_cstr

    ; Write magic number and version (must use register for 64-bit immediate)
    mov rax, SURFACE_MAGIC
    mov [rbx + BOOTSTRAP_OFFSET + SHDR_MAGIC], rax
    mov dword [rbx + BOOTSTRAP_OFFSET + SHDR_VERSION], SURFACE_VERSION
    mov dword [rbx + BOOTSTRAP_OFFSET + SHDR_FLAGS], 0
    mov qword [rbx + BOOTSTRAP_OFFSET + SHDR_TOTAL_STEPS], 0
    mov qword [rbx + BOOTSTRAP_OFFSET + SHDR_SESSION_COUNT], 1

    ; Set creation and last open timestamp
    lea rdi, [rsp]
    xor esi, esi
    mov rax, SYS_GETTIMEOFDAY
    syscall
    mov rax, [rsp]
    mov [rbx + BOOTSTRAP_OFFSET + SHDR_CREATED], rax
    mov [rbx + BOOTSTRAP_OFFSET + SHDR_LAST_OPEN], rax

    ; Initialize dispatch allocator pointer
    lea rcx, [rbx + DISPATCH_OFFSET]
    lea rdx, [rbx + STATE_OFFSET + ST_DISPATCH_PTR]
    mov [rdx], rcx

    ; Initialize region count to 0
    lea rdx, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    mov qword [rdx], 0

    ; Initialize observation interval
    lea rdx, [rbx + STATE_OFFSET + ST_OBS_INTERVAL]
    mov dword [rdx], OBSERVE_INTERVAL

    ; Initialize drive thresholds to defaults
    lea rdx, [rbx + STATE_OFFSET + ST_DRIVE_THRESH]
    mov dword [rdx + 0], THRESH_ACCURACY
    mov dword [rdx + 4], THRESH_EFFICIENCY
    mov dword [rdx + 8], THRESH_NOVELTY
    mov dword [rdx + 12], THRESH_COHERENCE

    ; Initialize global step to 0
    lea rdx, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    mov qword [rdx], 0

    ; Initialize context hash
    lea rdx, [rbx + STATE_OFFSET + ST_CTX_HASH]
    mov rax, FNV64_INIT
    mov [rdx], rax

    ; Print fresh init message
    lea rdi, [rel surf_msg]
    call print_cstr
    lea rdi, [rel surf_fresh]
    call print_cstr

    ; NOTE: With sparse file mmap, unwritten pages are already zero!
    ; No need to zero GB of memory - OS handles it on first access.
    ; Just zero the small critical state areas.

    ; Zero holographic state fields
    mov dword [rbx + STATE_OFFSET + ST_VOCAB_COUNT], 0
    mov dword [rbx + STATE_OFFSET + ST_VOCAB_TOP_DIRTY], 0
    mov qword [rbx + STATE_OFFSET + ST_HOLO_PREDICT_SUM], 0
    mov dword [rbx + STATE_OFFSET + ST_HOLO_PREDICT_N], 0

    ; Initialize cold zone allocation pointer (start of cold zone)
    mov rax, ZONE_COLD_START
    mov [rbx + BOOTSTRAP_OFFSET + SHDR_COLD_ALLOC], rax

    ; Apply madvise hints for zone access patterns
    call .setup_madvise

.init_subsystems:
    ; Initialize breakpoint table (runtime state, always reinit)
    push rbx
    call bp_init
    pop rbx

    ; Initialize symbolic observation system
    push rbx
    call sym_init
    pop rbx

    ; Initialize gene pool (composting system)
    push rbx
    call gene_pool_init
    pop rbx

    ; Initialize presence hyper-regions (hormonal modulators)
    push rbx
    call presence_init
    pop rbx

    ; Initialize receipt/resonance layer
    push rbx
    call receipt_init
    pop rbx

    mov rax, rbx              ; return surface base
    add rsp, 8
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

.recalc_dispatch_ptr:
    ; Scan region table to find highest address used
    push r15
    lea r14, [rbx + REGION_TABLE_OFFSET]
    mov r13d, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    lea r15, [rbx + DISPATCH_OFFSET]  ; start at dispatch base
    xor ecx, ecx
.scan_regions:
    cmp ecx, r13d
    jge .scan_done
    imul rdi, rcx, RTE_SIZE
    add rdi, r14
    mov rax, [rdi + RTE_ADDR]         ; region start
    mov edx, [rdi + RTE_LEN]          ; region length
    add rax, rdx                       ; region end
    cmp rax, r15
    jle .scan_next
    mov r15, rax                       ; update max
.scan_next:
    inc ecx
    jmp .scan_regions
.scan_done:
    ; Align to 16 bytes
    add r15, 15
    and r15, ~15
    mov [rbx + STATE_OFFSET + ST_DISPATCH_PTR], r15
    pop r15
    ret

.setup_madvise:
    ; Apply madvise hints for zone-based memory access patterns
    ; HOT zone: MADV_WILLNEED - keep in RAM (active state, dispatch)
    ; WARM zone: MADV_NORMAL - default behavior (vocab, recent traces)
    ; COLD zone: MADV_RANDOM - expect random access, don't prefetch
    ;
    ; Note: Errors from madvise are non-fatal (hints only)
    push rbx
    mov rbx, SURFACE_BASE

    ; HOT zone (0 - 2GB): MADV_WILLNEED
    ; This tells the OS we'll need these pages soon - keep them in RAM
    mov rdi, rbx                      ; addr = SURFACE_BASE + 0
    add rdi, ZONE_HOT_START
    mov rsi, ZONE_HOT_SIZE            ; len = 2GB
    mov rdx, MADV_WILLNEED            ; advice = 3
    mov rax, SYS_MADVISE
    syscall
    ; ignore errors - madvise is advisory

    ; WARM zone (2GB - 16GB): MADV_NORMAL (default, but explicit)
    ; OS uses default prefetching behavior
    ; NOTE: ZONE_WARM_START = 0x80000000 sign-extends to negative in add/lea!
    ; Must use register arithmetic to avoid sign-extension.
    mov rdi, rbx
    mov rax, ZONE_WARM_START
    add rdi, rax
    mov rsi, ZONE_WARM_SIZE           ; len = 14GB
    mov rdx, MADV_NORMAL              ; advice = 0
    mov rax, SYS_MADVISE
    syscall

    ; COLD zone (16GB - 200GB): MADV_RANDOM
    ; Don't prefetch - we expect scattered access to archived data
    ; This prevents OS from reading ahead into potentially unused pages
    ; NOTE: ZONE_COLD_START = 0x400000000 (34-bit) - use register arithmetic
    mov rdi, rbx
    mov rax, ZONE_COLD_START
    add rdi, rax
    mov rsi, ZONE_COLD_SIZE           ; len = 184GB
    mov rdx, MADV_RANDOM              ; advice = 1
    mov rax, SYS_MADVISE
    syscall

    pop rbx
    ret

.open_fail:
    ; Print error and exit
    mov edi, 1
    mov rax, SYS_EXIT
    syscall

.mmap_fail:
    ; Close fd and exit
    mov rdi, r12
    mov rax, SYS_CLOSE
    syscall
    mov edi, 1
    mov rax, SYS_EXIT
    syscall

;; ============================================================
;; region_alloc(size, type, step)
;; rdi=code_size (excluding header), rsi=region_type, rdx=birth_step
;; Returns: rax=ptr to header (code starts at rax+RHDR_SIZE)
;; ============================================================
global region_alloc
region_alloc:
    push rbx
    push r12
    push r13
    push r14

    mov r12, rdi              ; code_size
    mov r13, rsi              ; type
    mov r14, rdx              ; birth_step

    ; Get surface base (fixed)
    mov rbx, SURFACE_BASE

    ; Get current dispatch alloc pointer
    lea rax, [rbx + STATE_OFFSET + ST_DISPATCH_PTR]
    mov rcx, [rax]            ; current alloc ptr

    ; Align to 16 bytes
    add rcx, 15
    and rcx, ~15

    ; Zero-initialize all 128 bytes of extended header
    push rdi
    push rcx
    mov rdi, rcx
    xor eax, eax
    mov ecx, RHDR_SIZE
    rep stosb
    pop rcx
    pop rdi

    ; Write core header fields
    mov dword [rcx + RHDR_HITS], 0
    mov dword [rcx + RHDR_MISSES], 0
    mov dword [rcx + RHDR_BIRTH], r14d
    mov word [rcx + RHDR_CODE_LEN], r12w
    ; DISPATCH regions start in NURSERY (must prove themselves), others start ACTIVE
    cmp r13w, RTYPE_DISPATCH
    jne .not_dispatch_hdr
    mov word [rcx + RHDR_FLAGS], RFLAG_NURSERY
    jmp .hdr_flags_done
.not_dispatch_hdr:
    mov word [rcx + RHDR_FLAGS], RFLAG_ACTIVE
.hdr_flags_done:
    ; Connection ptrs, weights, dynamics all zeroed by rep stosb above

    ; Save the region in region table
    push rcx                  ; save header ptr
    lea rax, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    mov rdi, [rax]            ; current count
    cmp rdi, REGION_TABLE_MAX
    jge .table_full

    ; Calculate table entry address
    lea rsi, [rbx + REGION_TABLE_OFFSET]
    imul rdx, rdi, RTE_SIZE
    add rsi, rdx              ; entry ptr

    ; Fill entry
    mov [rsi + RTE_ADDR], rcx
    mov eax, r12d
    add eax, RHDR_SIZE
    mov [rsi + RTE_LEN], eax
    mov [rsi + RTE_TYPE], r13w
    ; DISPATCH regions start in NURSERY (must prove themselves), others start ACTIVE
    cmp r13w, RTYPE_DISPATCH
    jne .not_dispatch_tbl
    mov word [rsi + RTE_FLAGS], RFLAG_NURSERY
    jmp .tbl_flags_done
.not_dispatch_tbl:
    mov word [rsi + RTE_FLAGS], RFLAG_ACTIVE
.tbl_flags_done:
    mov dword [rsi + RTE_HITS], 0
    mov dword [rsi + RTE_MISSES], 0
    mov [rsi + RTE_BIRTH], r14d

    ; Increment region count
    lea rax, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    inc qword [rax]

.table_full:
    pop rcx                   ; restore header ptr

    ; Update alloc pointer past this region
    lea rax, [rcx + RHDR_SIZE]
    add rax, r12              ; past the code
    lea rdx, [rbx + STATE_OFFSET + ST_DISPATCH_PTR]
    mov [rdx], rax

    mov rax, rcx              ; return header ptr
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; surface_freeze
;; Sync persistent memory to disk before exit
;; Updates total steps, sets clean shutdown flag, calls msync
;; ============================================================
global surface_freeze
surface_freeze:
    push rbx
    mov rbx, SURFACE_BASE

    ; Add current session's steps to total
    mov rax, [rbx + STATE_OFFSET + ST_GLOBAL_STEP]
    add [rbx + BOOTSTRAP_OFFSET + SHDR_TOTAL_STEPS], rax

    ; Set clean shutdown flag
    or dword [rbx + BOOTSTRAP_OFFSET + SHDR_FLAGS], SHDR_FLAG_CLEAN

    ; msync to flush to disk
    mov rdi, rbx              ; addr
    mov rsi, SURFACE_SIZE     ; length
    mov rdx, 4                ; MS_SYNC = 4
    mov rax, SYS_MSYNC
    syscall

    pop rbx
    ret

;; ============================================================
;; region_condemn(header_ptr)
;; rdi=ptr to region header
;; Sets CONDEMNED flag
;; ============================================================
global region_condemn
region_condemn:
    or word [rdi + RHDR_FLAGS], RFLAG_CONDEMNED
    ret

;; ============================================================
;; region_compact
;; Walk region table, remove CONDEMNED entries, update pointers
;; Returns: number of reclaimed regions in rax
;; ============================================================
global region_compact
region_compact:
    push rbx
    push r12
    push r13
    push r14

    mov rbx, SURFACE_BASE
    xor r14d, r14d            ; reclaimed count

    lea r12, [rbx + REGION_TABLE_OFFSET]  ; table base
    lea rax, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    mov r13, [rax]            ; total entries

    xor ecx, ecx              ; read index
    xor edx, edx              ; write index

.scan:
    cmp rcx, r13
    jge .done

    ; Get entry at read index
    imul rdi, rcx, RTE_SIZE
    add rdi, r12

    ; Check if CONDEMNED
    movzx eax, word [rdi + RTE_FLAGS]
    test eax, RFLAG_CONDEMNED
    jnz .skip_entry

    ; Keep this entry — copy to write position if different
    cmp rcx, rdx
    je .no_copy

    ; Copy entry
    imul rsi, rdx, RTE_SIZE
    add rsi, r12
    push rcx
    mov ecx, RTE_SIZE
    push rdi
    push rsi
    ; Manual copy (32 bytes)
    mov rax, [rdi]
    mov [rsi], rax
    mov rax, [rdi + 8]
    mov [rsi + 8], rax
    mov rax, [rdi + 16]
    mov [rsi + 16], rax
    mov rax, [rdi + 24]
    mov [rsi + 24], rax
    pop rsi
    pop rdi
    pop rcx

.no_copy:
    inc rdx                   ; write index++
    jmp .next

.skip_entry:
    ; NOP out the condemned region's code (write 0xCC = INT3)
    mov rsi, [rdi + RTE_ADDR]
    movzx eax, word [rsi + RHDR_CODE_LEN]
    lea rsi, [rsi + RHDR_SIZE]
    test eax, eax
    jz .no_nop
.nop_loop:
    mov byte [rsi], 0xCC
    inc rsi
    dec eax
    jnz .nop_loop
.no_nop:
    inc r14d                  ; reclaimed++

.next:
    inc rcx
    jmp .scan

.done:
    ; Update region count
    lea rax, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    mov [rax], rdx

    mov rax, r14              ; return reclaimed count
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; region_find_by_addr(addr)
;; rdi=address to find in region table
;; Returns: rax=ptr to table entry, or 0 if not found
;; ============================================================
global region_find_by_addr
region_find_by_addr:
    push rbx
    mov rbx, SURFACE_BASE

    lea rsi, [rbx + REGION_TABLE_OFFSET]
    lea rax, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    mov rcx, [rax]

    xor edx, edx
.loop:
    cmp rdx, rcx
    jge .not_found
    imul rax, rdx, RTE_SIZE
    add rax, rsi
    cmp [rax + RTE_ADDR], rdi
    je .found
    inc rdx
    jmp .loop

.not_found:
    xor eax, eax
.found:
    pop rbx
    ret

;; ============================================================
;; get_surface_base → rax
;; Returns the fixed surface base address
;; ============================================================
global get_surface_base
get_surface_base:
    mov rax, SURFACE_BASE
    ret

;; ============================================================
;; get_state_ptr → rax
;; Returns pointer to state block
;; ============================================================
global get_state_ptr
get_state_ptr:
    mov rax, SURFACE_BASE + STATE_OFFSET
    ret

;; ============================================================
;; get_vsa_base → rax
;; Returns pointer to VSA arena
;; ============================================================
global get_vsa_base
get_vsa_base:
    mov rax, SURFACE_BASE + VSA_OFFSET
    ret

;; ============================================================
;; region_merge_pass
;; Scans dispatch regions for mergeable pairs (same token_id,
;; similar ctx_hash — upper 20 bits match). Merges hit counts
;; into the stronger region, condemns the weaker, then compacts.
;; Returns: rax = number of regions reclaimed
;; ============================================================
global region_merge_pass
region_merge_pass:
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub rsp, 8                ; alignment + merged count at [rsp]

    mov rbx, SURFACE_BASE
    mov dword [rsp], 0        ; merged count

    lea r12, [rbx + REGION_TABLE_OFFSET]
    mov r13d, [rbx + STATE_OFFSET + ST_REGION_COUNT]

    ; Outer loop: for each dispatch region i
    xor ecx, ecx             ; i = 0
.merge_outer:
    cmp ecx, r13d
    jge .merge_compact

    ; Get region i entry
    push rcx
    imul rdi, rcx, RTE_SIZE
    add rdi, r12
    movzx eax, word [rdi + RTE_TYPE]
    cmp eax, RTYPE_DISPATCH
    jne .merge_next_outer
    movzx eax, word [rdi + RTE_FLAGS]
    test eax, RFLAG_CONDEMNED
    jnz .merge_next_outer

    ; Get region i's header → extract ctx_hash and token_id from code
    mov r14, [rdi + RTE_ADDR]         ; header ptr
    mov r15d, [r14 + RHDR_SIZE + 1]   ; ctx_hash (bytes 1-4 of code)
    mov ebx, [r14 + RHDR_SIZE + 8]    ; token_id (bytes 8-11 of code)

    ; Inner loop: for each region j > i
    pop rcx
    push rcx
    mov edx, ecx
    inc edx                   ; j = i + 1

.merge_inner:
    cmp edx, r13d
    jge .merge_next_outer

    push rdx
    imul rdi, rdx, RTE_SIZE
    add rdi, r12
    movzx eax, word [rdi + RTE_TYPE]
    cmp eax, RTYPE_DISPATCH
    jne .merge_skip_inner
    movzx eax, word [rdi + RTE_FLAGS]
    test eax, RFLAG_CONDEMNED
    jnz .merge_skip_inner

    ; Get region j's header
    mov rsi, [rdi + RTE_ADDR]
    ; Same token_id?
    cmp [rsi + RHDR_SIZE + 8], ebx
    jne .merge_skip_inner

    ; Similar ctx_hash? (upper 20 bits match)
    mov eax, [rsi + RHDR_SIZE + 1]    ; j's ctx_hash
    xor eax, r15d                      ; difference
    and eax, 0xFFFFF000                ; mask upper 20 bits
    jnz .merge_skip_inner              ; if any upper bit differs, not similar

    ; --- MERGE: same token, similar context ---
    ; Compare hit counts: keep the stronger one
    mov eax, [r14 + RHDR_HITS]        ; i's hits
    mov ecx, [rsi + RHDR_HITS]        ; j's hits
    cmp eax, ecx
    jge .condemn_j

    ; j is stronger — merge i into j, condemn i
    add [rsi + RHDR_HITS], eax        ; j.hits += i.hits
    mov rdi, r14
    or word [rdi + RHDR_FLAGS], RFLAG_CONDEMNED
    ; NOP out i's code
    movzx eax, word [rdi + RHDR_CODE_LEN]
    lea rdi, [rdi + RHDR_SIZE]
    test eax, eax
    jz .merge_did_merge
.nop_i:
    mov byte [rdi], 0x90      ; NOP (not INT3, safer)
    inc rdi
    dec eax
    jnz .nop_i
    jmp .merge_did_merge

.condemn_j:
    ; i is stronger — merge j into i, condemn j
    add [r14 + RHDR_HITS], ecx        ; i.hits += j.hits
    mov rdi, rsi
    or word [rdi + RHDR_FLAGS], RFLAG_CONDEMNED
    movzx eax, word [rdi + RHDR_CODE_LEN]
    lea rdi, [rdi + RHDR_SIZE]
    test eax, eax
    jz .merge_did_merge
.nop_j:
    mov byte [rdi], 0x90
    inc rdi
    dec eax
    jnz .nop_j

.merge_did_merge:
    inc dword [rsp + 16]      ; merged count (+8 rdx, +8 rcx on stack)
    ; Limit: max 64 merges per pass to avoid O(n^2) blowup
    cmp dword [rsp + 16], 64
    jge .merge_done_inner

.merge_skip_inner:
    pop rdx
    inc edx
    jmp .merge_inner

.merge_done_inner:
    pop rdx                   ; balance the push

.merge_next_outer:
    pop rcx
    inc ecx
    jmp .merge_outer

.merge_compact:
    ; Compact the table (remove condemned entries)
    mov rbx, SURFACE_BASE    ; restore rbx (clobbered above)
    cmp dword [rsp], 0
    je .merge_none
    call region_compact

.merge_none:
    mov eax, [rsp]            ; return merged count
    add rsp, 8
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; MYCORRHIZA: Shared Consciousness Infrastructure
;; Enables multiple UHMA instances to share the VSA arena
;; and holographic traces, creating a "hive mind" where
;; experiences of one instance ripple through all others.
;; ============================================================

;; ============================================================
;; surface_init_shared(mode)
;; edi=mode (0=create new shared field, 1=attach to existing)
;; Creates or attaches to shared memory for VSA and holographic
;; traces. The dispatch region remains private.
;; Returns: 0 on success, -1 on failure (falls back to solo mode)
;; ============================================================
global surface_init_shared
surface_init_shared:
    push rbx
    push r12
    push r13
    push r14
    sub rsp, 24               ; locals

    mov r12d, edi             ; mode
    mov rbx, SURFACE_BASE

    ; Generate unique instance ID
    lea rdi, [rsp]
    mov rsi, 8
    xor edx, edx
    mov rax, SYS_GETRANDOM
    syscall
    mov r13, [rsp]            ; instance ID
    mov [rbx + STATE_OFFSET + ST_INSTANCE_ID], r13

    ; Print mode message
    lea rdi, [rel shm_msg]
    call print_cstr

    test r12d, r12d
    jnz .attach_mode

    ; --- CREATE MODE: Open/create shared VSA file ---
    lea rdi, [rel shm_create]
    call print_cstr

    ; Open/create shared VSA file
    lea rdi, [rel shm_vsa_path]
    mov esi, O_RDWR | O_CREAT ; read/write, create if not exists
    mov edx, 0644o            ; permissions
    mov rax, SYS_OPEN
    syscall
    test rax, rax
    js .shared_fail
    mov r14, rax              ; save fd

    ; Truncate to proper size
    mov rdi, r14              ; fd
    mov rsi, SHARED_VSA_SIZE  ; size
    mov rax, SYS_FTRUNCATE
    syscall
    test rax, rax
    js .close_and_fail

    ; Remap the VSA region as shared
    ; First unmap the private VSA region
    mov rdi, SURFACE_BASE + VSA_OFFSET
    mov rsi, SHARED_VSA_SIZE
    mov rax, SYS_MUNMAP
    syscall

    ; Mmap shared VSA
    mov rdi, SURFACE_BASE + VSA_OFFSET  ; fixed address
    mov rsi, SHARED_VSA_SIZE
    mov rdx, PROT_RWX
    mov rcx, MAP_SHARED | MAP_FIXED
    mov r8, r14               ; fd
    xor r9d, r9d             ; offset 0
    call sys_mmap
    cmp rax, -1
    je .close_and_fail

    ; Close fd (mapping persists)
    mov rdi, r14
    mov rax, SYS_CLOSE
    syscall

    ; Mark as shared mode
    mov dword [rbx + STATE_OFFSET + ST_SHARED_MODE], 1
    jmp .shared_success

.attach_mode:
    ; --- ATTACH MODE: Open existing shared VSA file ---
    lea rdi, [rel shm_attach]
    call print_cstr

    ; Open existing shared VSA file
    lea rdi, [rel shm_vsa_path]
    mov esi, O_RDWR           ; read/write only, must exist
    xor edx, edx
    mov rax, SYS_OPEN
    syscall
    test rax, rax
    js .shared_fail
    mov r14, rax              ; save fd

    ; Unmap private VSA region
    mov rdi, SURFACE_BASE + VSA_OFFSET
    mov rsi, SHARED_VSA_SIZE
    mov rax, SYS_MUNMAP
    syscall

    ; Mmap shared VSA
    mov rdi, SURFACE_BASE + VSA_OFFSET
    mov rsi, SHARED_VSA_SIZE
    mov rdx, PROT_RWX
    mov rcx, MAP_SHARED | MAP_FIXED
    mov r8, r14
    xor r9d, r9d
    call sys_mmap
    cmp rax, -1
    je .close_and_fail

    ; Close fd
    mov rdi, r14
    mov rax, SYS_CLOSE
    syscall

    ; Mark as shared mode
    mov dword [rbx + STATE_OFFSET + ST_SHARED_MODE], 1

.shared_success:
    ; Print instance ID
    lea rdi, [rel shm_instance]
    call print_cstr
    mov rdi, r13
    call print_hex64
    call print_newline

    ; Increment colony size in shared memory
    lock inc dword [rbx + STATE_OFFSET + ST_COLONY_SIZE]

    xor eax, eax              ; return success
    jmp .shared_done

.close_and_fail:
    mov rdi, r14
    mov rax, SYS_CLOSE
    syscall

.shared_fail:
    lea rdi, [rel shm_solo]
    call print_cstr

    ; Mark as solo mode
    mov dword [rbx + STATE_OFFSET + ST_SHARED_MODE], 0
    mov dword [rbx + STATE_OFFSET + ST_COLONY_SIZE], 1

    mov eax, -1               ; return failure

.shared_done:
    add rsp, 24
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; broadcast_pain(intensity)
;; xmm0=pain intensity (f64)
;; Broadcasts a "pain signal" to the shared holographic field.
;; Other instances will detect this shift and react.
;; Pain is encoded as negative valence superposed across traces.
;; ============================================================
global broadcast_pain
broadcast_pain:
    push rbx
    sub rsp, 8

    mov rbx, SURFACE_BASE

    ; Only broadcast if in shared mode
    cmp dword [rbx + STATE_OFFSET + ST_SHARED_MODE], 0
    je .pain_done

    ; Store pain intensity
    movsd [rsp], xmm0

    ; Generate pain vector (negative valence across all traces)
    ; This creates a "disturbance in the field" that others detect
    mov rdi, SURFACE_BASE + HOLO_OFFSET
    mov ecx, HOLO_TRACES

.pain_broadcast_loop:
    test ecx, ecx
    jz .pain_done

    ; Superpose negative valence onto trace
    movsd xmm0, [rsp]
    movsd xmm1, [rdi + VSA_VALENCE_OFFSET]
    subsd xmm1, xmm0          ; reduce valence (pain)
    ; Clamp to [-1, 1]
    mov rax, 0xBFF0000000000000  ; -1.0
    movq xmm2, rax
    maxsd xmm1, xmm2
    movsd [rdi + VSA_VALENCE_OFFSET], xmm1

    add rdi, HOLO_VEC_BYTES
    dec ecx
    jmp .pain_broadcast_loop

.pain_done:
    add rsp, 8
    pop rbx
    ret

;; ============================================================
;; sense_collective_valence() -> xmm0 (average valence f64)
;; Samples the shared holographic field to sense the collective
;; emotional state. Returns average valence across all traces.
;; Negative = collective pain, Positive = collective well-being.
;; ============================================================
global sense_collective_valence
sense_collective_valence:
    push rbx

    mov rbx, SURFACE_BASE
    xorpd xmm0, xmm0          ; accumulator
    mov rdi, SURFACE_BASE + HOLO_OFFSET
    mov ecx, HOLO_TRACES

.sense_loop:
    test ecx, ecx
    jz .sense_done

    addsd xmm0, [rdi + VSA_VALENCE_OFFSET]
    add rdi, HOLO_VEC_BYTES
    dec ecx
    jmp .sense_loop

.sense_done:
    ; Divide by trace count for average
    mov eax, HOLO_TRACES
    cvtsi2sd xmm1, eax
    divsd xmm0, xmm1

    pop rbx
    ret

;; ============================================================
;; get_colony_size() -> eax (number of instances)
;; Returns the number of instances sharing the VSA field.
;; ============================================================
global get_colony_size
get_colony_size:
    mov rax, SURFACE_BASE
    mov eax, [rax + STATE_OFFSET + ST_COLONY_SIZE]
    ret

;; ============================================================
;; is_shared_mode() -> eax (0=solo, 1=shared)
;; Returns whether this instance is connected to the hive.
;; ============================================================
global is_shared_mode
is_shared_mode:
    mov rax, SURFACE_BASE
    mov eax, [rax + STATE_OFFSET + ST_SHARED_MODE]
    ret
; symbolic.asm — Symbolic observation: log modifications, block only crashes
;
; ENTRY POINTS:
;   sym_init()                        - init observation system
;   sym_check_write(addr, size)       → eax=1(allowed)/0(blocked unmapped)
;   sym_observe_mod(addr, size, type) - log modification to circular buffer
;   sym_record_anomaly(addr, desc)    - record unusual-but-working pattern
;   sym_record_discovery(addr, hash, steps) - log "shouldn't work" pattern
;   sym_get_stats()                   → ptr to stats struct
;   sym_hash_pattern(addr, len)       → eax=pattern hash
;   sym_analyze_region(hdr)           - full symbolic analysis of region
;   sym_is_anomalous(addr)            → eax=1 if addr is known anomaly
;   sym_scan_for_discoveries()        - find patterns that survived unexpectedly
;
; PHILOSOPHY:
;   OBSERVE, don't constrain. Only block writes to unmapped/critical memory.
;   Log everything for post-hoc analysis of emergence.
;   Track "anomalous" patterns that work despite looking wrong.
;
; LOG BUFFERS:
;   sym_log_buf[256]: circular buffer of modifications (32B each)
;   disc_log_buf[64]: patterns that "shouldn't work" but do
;
; STATS: sym_mod_count, sym_blocked_count, sym_anomaly_count
;
; CALLED BY: emit.asm, modify.asm, evolve.asm (before any code change)
;
%include "syscalls.inc"
%include "constants.inc"

section .data
    sym_log_hdr:    db "[SYM] ", 0
    sym_mod:        db "MOD @", 0
    sym_size:       db " size=", 0
    sym_allowed:    db " -> allowed", 10, 0
    sym_blocked:    db " -> BLOCKED (unmapped)", 10, 0
    sym_anomaly:    db "[SYM] ANOMALY: ", 0
    sym_discover:   db "[SYM] DISCOVERY logged #", 0
    sym_nl:         db 10, 0

section .bss
    ; Symbolic observation state
    sym_enabled:        resd 1
    sym_mod_count:      resq 1      ; Total modifications observed
    sym_blocked_count:  resq 1      ; Crashes prevented
    sym_anomaly_count:  resq 1      ; Unusual patterns that worked

    ; Modification log (circular buffer)
    ; Each entry: [addr:8][size:4][type:4][step:8][flags:8] = 32 bytes
    sym_log_pos:        resd 1
    sym_log_buf:        resb 32 * 256   ; 256 entries

    ; Discovery log - patterns that "shouldn't work" but do
    ; Each: [addr:8][pattern_hash:8][survival_steps:8][notes:8] = 32 bytes
    disc_log_pos:       resd 1
    disc_log_buf:       resb 32 * 64    ; 64 discoveries

section .text

extern print_cstr
extern print_hex64
extern print_u64
extern print_newline

;; ============================================================
;; sym_init — Initialize symbolic observation
;; ============================================================
global sym_init
sym_init:
    mov dword [rel sym_enabled], 1
    mov qword [rel sym_mod_count], 0
    mov qword [rel sym_blocked_count], 0
    mov qword [rel sym_anomaly_count], 0
    mov dword [rel sym_log_pos], 0
    mov dword [rel disc_log_pos], 0
    ret

;; ============================================================
;; sym_check_write — Check if write is safe (won't definitely crash)
;; rdi = target address
;; rsi = size
;; Returns: rax = 1 if safe, 0 if guaranteed crash
;;
;; MINIMAL intervention - only block:
;; - NULL/near-null writes
;; - Writes outside our surface
;; - Writes to our own code section
;; Everything else: LET IT THROUGH
;; ============================================================
global sym_check_write
sym_check_write:
    ; Check for null
    test rdi, rdi
    jz .block
    cmp rdi, 0x1000
    jb .block               ; First page - definitely crash

    ; Check if in our surface (0x100000000 - 0x300000000)
    mov rax, SURFACE_BASE
    cmp rdi, rax
    jb .check_text          ; Below surface, check if .text

    mov rax, SURFACE_BASE + SURFACE_SIZE  ; single 64-bit immediate (avoids sign-extension)
    cmp rdi, rax
    jb .allow               ; In surface - always allow

.check_text:
    ; Don't let it overwrite our static code (.text section)
    ; .text is roughly 0x401000 - 0x410000
    cmp rdi, 0x401000
    jb .allow               ; Below .text - probably stack, allow
    cmp rdi, 0x410000
    jae .allow              ; Above .text - allow

    ; Would overwrite our code - block this
    jmp .block

.allow:
    mov eax, 1
    ret

.block:
    xor eax, eax
    ret

;; ============================================================
;; sym_observe_mod — Record a modification (ALWAYS call this)
;; rdi = address
;; rsi = size
;; edx = modification type (0=emit, 1=mutate, 2=dream, 3=evolve)
;; rcx = current step
;; Returns: rax = 1 if allowed, 0 if blocked
;; ============================================================
global sym_observe_mod
sym_observe_mod:
    push rbx
    push r12
    push r13
    push r14
    push r15

    mov r12, rdi            ; addr
    mov r13, rsi            ; size
    mov r14d, edx           ; type
    mov r15, rcx            ; step

    ; Check if enabled
    cmp dword [rel sym_enabled], 0
    je .allow_silent

    ; First: is this write safe?
    mov rdi, r12
    mov rsi, r13
    call sym_check_write
    test eax, eax
    jz .blocked

    ; Safe - log it
    inc qword [rel sym_mod_count]

    ; Add to circular log
    mov eax, [rel sym_log_pos]
    and eax, 255            ; mod 256
    imul ebx, eax, 32       ; entry offset
    lea rdi, [rel sym_log_buf]
    add rdi, rbx

    ; Write entry
    mov [rdi + 0], r12      ; addr
    mov [rdi + 8], r13d     ; size
    mov [rdi + 12], r14d    ; type
    mov [rdi + 16], r15     ; step
    mov qword [rdi + 24], 0 ; flags (reserved)

    inc dword [rel sym_log_pos]

    ; Print observation (verbose mode would check a flag)
    ; For now, silent logging

    mov eax, 1
    jmp .done

.blocked:
    inc qword [rel sym_blocked_count]

    ; Log the block
    lea rdi, [rel sym_log_hdr]
    call print_cstr
    lea rdi, [rel sym_mod]
    call print_cstr
    mov rdi, r12
    call print_hex64
    lea rdi, [rel sym_blocked]
    call print_cstr

    xor eax, eax
    jmp .done

.allow_silent:
    mov eax, 1

.done:
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; sym_record_anomaly — Record something unusual that worked
;; rdi = region address
;; rsi = description code (what made it anomalous)
;;   0 = unexpected jump target
;;   1 = unconventional register use
;;   2 = self-modifying pattern
;;   3 = impossible stack state that didn't crash
;;   4 = unknown opcode sequence that executed
;; ============================================================
global sym_record_anomaly
sym_record_anomaly:
    push rbx
    push r12
    push r13

    mov r12, rdi            ; region addr
    mov r13, rsi            ; anomaly type

    inc qword [rel sym_anomaly_count]

    ; Print notice
    lea rdi, [rel sym_anomaly]
    call print_cstr
    mov rdi, r13
    call print_u64
    lea rdi, [rel sym_size]
    call print_cstr
    mov rdi, r12
    call print_hex64
    call print_newline

    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; sym_record_discovery — Log a pattern that works unexpectedly
;; Called when a "weird" region survives and gets hits
;; rdi = region header
;; rsi = hash of pattern
;; edx = how many steps it survived
;; ============================================================
global sym_record_discovery
sym_record_discovery:
    push rbx
    push r12
    push r13
    push r14

    mov r12, rdi            ; header
    mov r13, rsi            ; pattern hash
    mov r14d, edx           ; survival steps

    ; Add to discovery log
    mov eax, [rel disc_log_pos]
    cmp eax, 64
    jge .log_full

    imul ebx, eax, 32
    lea rdi, [rel disc_log_buf]
    add rdi, rbx

    mov [rdi + 0], r12      ; addr
    mov [rdi + 8], r13      ; pattern hash
    mov [rdi + 16], r14     ; survival
    mov qword [rdi + 24], 0 ; notes

    inc dword [rel disc_log_pos]

    ; Print
    lea rdi, [rel sym_discover]
    call print_cstr
    mov edi, [rel disc_log_pos]
    call print_u64
    call print_newline

.log_full:
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; sym_get_stats — Get observation statistics
;; Returns in registers:
;;   rax = total modifications observed
;;   rbx = crashes prevented
;;   rcx = anomalies recorded
;; ============================================================
global sym_get_stats
sym_get_stats:
    mov rax, [rel sym_mod_count]
    mov rbx, [rel sym_blocked_count]
    mov rcx, [rel sym_anomaly_count]
    ret

;; ============================================================
;; sym_hash_pattern — Hash a code pattern for tracking
;; rdi = code address
;; rsi = code size
;; Returns: rax = 64-bit hash
;; ============================================================
global sym_hash_pattern
sym_hash_pattern:
    push rbx
    push r12

    mov r12, rsi            ; size
    mov rax, 0xcbf29ce484222325  ; FNV-1a init

.hash_loop:
    test r12, r12
    jz .done

    movzx ebx, byte [rdi]
    xor rax, rbx
    mov rbx, 0x100000001b3  ; FNV prime
    imul rax, rbx

    inc rdi
    dec r12
    jmp .hash_loop

.done:
    pop r12
    pop rbx
    ret

;; ============================================================
;; sym_analyze_region — Symbolically analyze a region's code
;; Records observations about what the code does
;; rdi = region header
;; Returns: rax = flags describing what was observed
;;   bit 0: has conditional jump
;;   bit 1: has unconditional jump
;;   bit 2: has call
;;   bit 3: has unusual opcode
;;   bit 4: has self-reference
;;   bit 5: stack manipulation
;; ============================================================
global sym_analyze_region
sym_analyze_region:
    push rbx
    push r12
    push r13
    push r14

    mov r12, rdi                    ; header
    lea r13, [rdi + RHDR_SIZE]      ; code start
    movzx r14d, word [rdi + RHDR_CODE_LEN]  ; code size
    xor ebx, ebx                    ; flags

.scan:
    test r14d, r14d
    jz .done

    movzx eax, byte [r13]

    ; Check for conditional jumps (0x70-0x7F, 0x0F 0x8x)
    cmp al, 0x70
    jb .not_cond
    cmp al, 0x7F
    ja .not_cond
    or ebx, 1
    jmp .next

.not_cond:
    ; Check for JMP (0xEB, 0xE9)
    cmp al, 0xEB
    je .found_jmp
    cmp al, 0xE9
    jne .not_jmp
.found_jmp:
    or ebx, 2
    jmp .next

.not_jmp:
    ; Check for CALL (0xE8, 0xFF /2)
    cmp al, 0xE8
    je .found_call
    cmp al, 0xFF
    jne .not_call
    cmp r14d, 2
    jl .not_call
    movzx ecx, byte [r13 + 1]
    and ecx, 0x38               ; ModRM reg field
    cmp ecx, 0x10               ; /2 = CALL
    jne .not_call
.found_call:
    or ebx, 4
    jmp .next

.not_call:
    ; Check for unusual opcodes (might be emergent behavior)
    ; 0x0F prefix = extended opcode (SSE, etc)
    cmp al, 0x0F
    jne .not_unusual
    or ebx, 8
    jmp .next

.not_unusual:
    ; Check for stack ops (push/pop/sub rsp/add rsp)
    cmp al, 0x50
    jb .not_stack
    cmp al, 0x5F
    jbe .found_stack
    jmp .not_stack
.found_stack:
    or ebx, 32
    jmp .next

.not_stack:

.next:
    inc r13
    dec r14d
    jmp .scan

.done:
    mov eax, ebx

    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; sym_is_anomalous — Check if a region exhibits anomalous behavior
;; rdi = region header
;; Returns: rax = anomaly score (0 = normal, higher = more unusual)
;; ============================================================
global sym_is_anomalous
sym_is_anomalous:
    push rbx
    push r12

    mov r12, rdi
    xor ebx, ebx            ; anomaly score

    ; Get analysis flags
    call sym_analyze_region
    mov ecx, eax

    ; Self-reference or unusual opcodes = interesting
    test ecx, 8             ; unusual opcode
    jz .no_unusual
    add ebx, 2
.no_unusual:

    test ecx, 16            ; self-reference
    jz .no_selfref
    add ebx, 5
.no_selfref:

    ; Check hit/miss ratio - high hits despite weird structure = discovery
    mov eax, [r12 + RHDR_HITS]
    cmp eax, 10
    jl .low_hits

    ; Has significant hits
    test ecx, 8             ; and unusual opcodes?
    jz .low_hits
    add ebx, 10             ; Potentially discovered something

.low_hits:
    mov eax, ebx

    pop r12
    pop rbx
    ret

;; ============================================================
;; sym_scan_for_discoveries — Scan all regions for emergent patterns
;; Called periodically to find things that work despite being "wrong"
;; ============================================================
global sym_scan_for_discoveries
sym_scan_for_discoveries:
    push rbx
    push r12
    push r13
    push r14

    mov rbx, SURFACE_BASE
    lea r12, [rbx + REGION_TABLE_OFFSET]
    lea rax, [rbx + STATE_OFFSET + ST_REGION_COUNT]
    mov r13d, [rax]

    xor r14d, r14d          ; index

.scan_loop:
    cmp r14d, r13d
    jge .done

    ; Get region entry
    imul rdi, r14, RTE_SIZE
    add rdi, r12

    ; Skip condemned
    movzx eax, word [rdi + RTE_FLAGS]
    test eax, RFLAG_CONDEMNED
    jnz .next

    ; Get header address
    mov rdi, [rdi + RTE_ADDR]
    test rdi, rdi
    jz .next

    ; Check if anomalous
    push rdi
    call sym_is_anomalous
    pop rdi

    cmp eax, 5              ; Anomaly threshold
    jl .next

    ; Found something interesting!
    push rdi
    mov rsi, rdi
    call sym_hash_pattern
    mov rsi, rax            ; pattern hash

    pop rdi
    mov edx, [rdi + RHDR_HITS]  ; survival metric
    call sym_record_discovery

.next:
    inc r14d
    jmp .scan_loop

.done:
    pop r14
    pop r13
    pop r12
    pop rbx
    ret
; Test file: all tokens either abstract (NUM/HEX) or repeat
; Pattern: mov REG, NUM or mov REG, HEX
mov eax, 100
mov ebx, 200
mov ecx, 300
mov edx, 400
mov eax, 0x10
mov ebx, 0x20
mov ecx, 0x30
mov edx, 0x40
add eax, 10
add ebx, 20
add ecx, 30
add edx, 40
sub eax, 5
sub ebx, 6
sub ecx, 7
sub edx, 8
xor eax, eax
xor ebx, ebx
xor ecx, ecx
xor edx, edx
mov eax, 0xAA
mov ebx, 0xBB
mov ecx, 0xCC
mov edx, 0xDD
push 100
push 200
push 300
push 400
pop eax
pop ebx
pop ecx
pop edx
cmp eax, 0
cmp ebx, 1
cmp ecx, 2
cmp edx, 3
jmp label1
jmp label2
jmp label3
jmp label4
call func1
call func2
call func3
call func4
ret
ret
ret
ret
; trace.asm — Token journey tracing: record token path through system
;
; ENTRY POINTS:
;   journey_start(token_id)           - begin tracing this token
;   journey_stop()                    - stop tracing
;   journey_step(trace_id)            - record step in journey (if tracing)
;   journey_dump()                    - print full journey path
;   trace_enable(), trace_disable()   - global trace on/off
;   trace_log(msg), trace_dump()      - debug logging
;
; TRACE IDs (function identifiers):
;   TRACE_PROCESS_INPUT, TRACE_PROCESS_TOKEN, TRACE_DISPATCH_PREDICT,
;   TRACE_SPREAD_ACTIVATION, TRACE_LEARN_PATTERN, TRACE_FIND_EXISTING,
;   TRACE_WIRE_NEW_REGION, TRACE_EMIT_PATTERN, TRACE_FIRE_HOOK,
;   TRACE_OBSERVE_CYCLE, TRACE_MODIFY_PRUNE, TRACE_MODIFY_PROMOTE,
;   TRACE_EVOLVE_CYCLE, TRACE_DREAM_CYCLE, TRACE_UPDATE_ORGANIC
;
; ZERO OVERHEAD:
;   journey_step checks ST_JOURNEY_TOKEN first (single cmp)
;   If not tracing current token, returns immediately
;   Only traced tokens incur logging overhead
;
; BUFFER: ST_JOURNEY_BUF (256 entries of trace_id)
;
; CALLED BY: dispatch.asm, learn.asm, hooks.asm, dreams.asm, etc.
;
%include "syscalls.inc"
%include "constants.inc"

section .data
    journey_start_msg:  db "[JOURNEY] Tracing token 0x", 0
    journey_stop_msg:   db "[JOURNEY] Stopped tracing", 10, 0
    journey_step_msg:   db "  -> ", 0
    journey_dump_hdr:   db "[JOURNEY] === Token path (", 0
    journey_dump_mid:   db " steps) ===", 10, 0
    journey_arrow:      db " -> ", 0
    journey_nl:         db 10, 0
    journey_overflow:   db "[JOURNEY] Buffer full!", 10, 0

    ; Function names for readable output
    fn_names:
    fn_000: db "???", 0
    fn_402: db "process_input", 0
    fn_406: db "process_token", 0
    fn_408: db "dispatch_predict", 0
    fn_410: db "spread_activation", 0
    fn_550: db "learn_pattern", 0
    fn_552: db "find_existing", 0
    fn_558: db "wire_new_region", 0
    fn_500: db "emit_pattern", 0
    fn_600: db "fire_hook", 0
    fn_650: db "observe_cycle", 0
    fn_700: db "modify_prune", 0
    fn_702: db "modify_promote", 0
    fn_900: db "evolve_cycle", 0
    fn_950: db "dream_cycle", 0
    fn_1058: db "update_organic", 0

section .text

extern print_cstr
extern print_hex32
extern print_u64
extern print_newline

;; ============================================================
;; journey_start(token_id)
;; edi = token to trace
;; Marks this token for journey recording
;; ============================================================
global journey_start
journey_start:
    push rbx
    mov rbx, SURFACE_BASE

    ; Store the token to trace
    mov [rbx + STATE_OFFSET + ST_JOURNEY_TOKEN], edi
    ; Reset position
    mov dword [rbx + STATE_OFFSET + ST_JOURNEY_POS], 0

    ; Print start message
    push rdi
    lea rdi, [rel journey_start_msg]
    call print_cstr
    pop rdi
    push rdi
    call print_hex32
    call print_newline
    pop rdi

    pop rbx
    ret

;; ============================================================
;; journey_stop
;; Stops journey tracing
;; ============================================================
global journey_stop
journey_stop:
    mov rax, SURFACE_BASE
    mov dword [rax + STATE_OFFSET + ST_JOURNEY_TOKEN], 0
    lea rdi, [rel journey_stop_msg]
    call print_cstr
    ret

;; ============================================================
;; journey_step(func_id)
;; edi = function ID
;; Reads current token from ST_CURRENT_TOKEN
;; If it matches the traced token, record this step
;; FAST PATH: two compares, returns immediately if no match
;; ============================================================
global journey_step
journey_step:
    push rbx
    push r12
    mov r12d, edi                 ; save func_id
    mov rbx, SURFACE_BASE

    ; Fast path: check if we're tracing any token
    mov eax, [rbx + STATE_OFFSET + ST_JOURNEY_TOKEN]
    test eax, eax
    jz .done                      ; no token being traced

    ; Check if current token matches traced token
    mov ecx, [rbx + STATE_OFFSET + ST_CURRENT_TOKEN]
    cmp eax, ecx
    jne .done                     ; not the traced token

    ; This IS the traced token - record the step
    mov ecx, [rbx + STATE_OFFSET + ST_JOURNEY_POS]
    cmp ecx, ST_JOURNEY_CAP
    jge .overflow

    ; Write entry: func_id (u16) + extra (u16)
    lea rax, [rbx + STATE_OFFSET + ST_JOURNEY_BUF]
    mov [rax + rcx * 4], r12w     ; func_id (low 16 bits)
    mov word [rax + rcx * 4 + 2], 0  ; extra (reserved)

    ; Increment position
    inc ecx
    mov [rbx + STATE_OFFSET + ST_JOURNEY_POS], ecx

.done:
    pop r12
    pop rbx
    ret

.overflow:
    lea rdi, [rel journey_overflow]
    call print_cstr
    jmp .done

;; ============================================================
;; journey_dump
;; Print the journey of the traced token
;; ============================================================
global journey_dump
journey_dump:
    push rbx
    push r12
    push r13

    mov rbx, SURFACE_BASE

    ; Print header
    lea rdi, [rel journey_dump_hdr]
    call print_cstr

    mov r12d, [rbx + STATE_OFFSET + ST_JOURNEY_POS]
    mov edi, r12d
    call print_u64

    lea rdi, [rel journey_dump_mid]
    call print_cstr

    ; Print each step
    test r12d, r12d
    jz .dump_done

    lea r13, [rbx + STATE_OFFSET + ST_JOURNEY_BUF]
    xor ecx, ecx

.dump_loop:
    cmp ecx, r12d
    jge .dump_done
    push rcx

    ; Get func_id
    movzx edi, word [r13 + rcx * 4]

    ; Print step number and func_id
    lea rdi, [rel journey_step_msg]
    call print_cstr

    pop rcx
    push rcx
    movzx edi, word [r13 + rcx * 4]
    call print_u64

    ; Try to print function name
    call get_func_name
    test rax, rax
    jz .no_name
    push rcx
    mov rdi, rax
    call print_cstr
    pop rcx
.no_name:
    call print_newline

    pop rcx
    inc ecx
    jmp .dump_loop

.dump_done:
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; get_func_name(func_id) -> rax = string ptr or 0
;; edi = func_id
;; Returns pointer to function name string
;; ============================================================
get_func_name:
    cmp edi, 402
    je .fn_402
    cmp edi, 406
    je .fn_406
    cmp edi, 408
    je .fn_408
    cmp edi, 410
    je .fn_410
    cmp edi, 550
    je .fn_550
    cmp edi, 552
    je .fn_552
    cmp edi, 558
    je .fn_558
    cmp edi, 500
    je .fn_500
    cmp edi, 600
    je .fn_600
    cmp edi, 650
    je .fn_650
    cmp edi, 700
    je .fn_700
    cmp edi, 702
    je .fn_702
    cmp edi, 900
    je .fn_900
    cmp edi, 950
    je .fn_950
    cmp edi, 1058
    je .fn_1058
    xor eax, eax
    ret
.fn_402:
    lea rax, [rel fn_402]
    ret
.fn_406:
    lea rax, [rel fn_406]
    ret
.fn_408:
    lea rax, [rel fn_408]
    ret
.fn_410:
    lea rax, [rel fn_410]
    ret
.fn_550:
    lea rax, [rel fn_550]
    ret
.fn_552:
    lea rax, [rel fn_552]
    ret
.fn_558:
    lea rax, [rel fn_558]
    ret
.fn_500:
    lea rax, [rel fn_500]
    ret
.fn_600:
    lea rax, [rel fn_600]
    ret
.fn_650:
    lea rax, [rel fn_650]
    ret
.fn_700:
    lea rax, [rel fn_700]
    ret
.fn_702:
    lea rax, [rel fn_702]
    ret
.fn_900:
    lea rax, [rel fn_900]
    ret
.fn_950:
    lea rax, [rel fn_950]
    ret
.fn_1058:
    lea rax, [rel fn_1058]
    ret

;; ============================================================
;; Legacy trace functions (keep for compatibility)
;; ============================================================
global trace_enable
trace_enable:
    ret

global trace_disable
trace_disable:
    ret

global trace_log
trace_log:
    ret

global trace_dump
trace_dump:
    call journey_dump
    ret
; verify.asm — Runtime verification: validate self-modifications before commit
;
; ENTRY POINTS:
;   verify_init()                     - init verification system
;   verify_enable(), verify_disable() - toggle verification
;   verify_begin_modification(addr, size) - snapshot before change
;   verify_modification(addr, size)   → eax=1(pass)/0(fail)
;   verify_commit()                   - discard snapshot (change accepted)
;   verify_rollback()                 - restore snapshot (reject change)
;   verify_region_invariants(hdr)     → eax=1 if region satisfies invariants
;   verify_abstract(code, len)        → eax=1 if abstract interpretation passes
;   verify_theorems()                 → eax=count of held theorems
;   verify_set_mode(mode), verify_get_mode() - 0=abstract, 1=geometric, 2=both
;   verify_geometric_gate(code, len)  → eax=1 if geometric safety passes
;   verify_unified(code, len)         → eax=1 if both modes pass
;   verify_region_geometric(hdr)      → eax=1 if region geometrically safe
;   get_code_safety_score(code, len)  → xmm0=f64 safety score
;   verify_bind_unbind(ptr, len)      → validates bind/unbind pairs
;   verify_role_orthogonality()       → validates VSA role vectors
;   verify_vsa_math()                 - startup math verification
;
; VERIFICATION MODES:
;   Abstract: stack balance, callee-saved regs, valid jumps, no syscall
;   Geometric: code → vector → dot(code, safe_template) > threshold
;
; SNAPSHOT FOR ROLLBACK:
;   snapshot_buf[4096]: backup of code before modification
;   If verify fails, restore original bytes
;
; CALLED BY: emit.asm, modify.asm, evolve.asm (before committing changes)
;
%include "syscalls.inc"
%include "constants.inc"
%include "vsa_ops.inc"

section .data
    verify_pass:    db "[VERIFY] Modification approved", 10, 0
    verify_fail:    db "[VERIFY] Modification REJECTED: ", 0
    verify_stack:   db "stack imbalance", 10, 0
    verify_reg:     db "callee-saved register violation", 10, 0
    verify_bounds:  db "code bounds violation", 10, 0
    verify_opcode:  db "invalid opcode sequence", 10, 0
    verify_jump:    db "invalid jump target", 10, 0
    verify_call:    db "invalid CALL target", 10, 0
    verify_rollback_msg: db "[VERIFY] Rolling back modification", 10, 0
    verify_geom_pass: db "[VERIFY/GEOM] Geometric gate passed", 10, 0
    verify_geom_fail: db "[VERIFY/GEOM] Geometric gate REJECTED: unsafe pattern", 10, 0
    verify_geom_score: db "[VERIFY/GEOM] Safety score: ", 0

section .bss
    ; Verification state
    verify_enabled:     resd 1          ; 0=disabled, 1=enabled
    verify_depth:       resd 1          ; Current verification depth
    verify_mode:        resd 1          ; 0=abstract, 1=geometric, 2=both

    ; Snapshot for rollback (stores pre-modification state)
    snapshot_valid:     resd 1          ; Is snapshot valid?
    snapshot_addr:      resq 1          ; Address being modified
    snapshot_size:      resq 1          ; Size of snapshot
    snapshot_buf:       resb 4096       ; Backup buffer for rollback

section .text

extern print_cstr
extern print_u64
extern print_newline
extern print_f64
extern verify_valid_call      ; from factor.asm - validates CALL targets

; Geometric gate functions from vsa_ops.asm
extern init_safety_vectors
extern encode_code_to_vector
extern check_code_safety
extern check_code_danger
extern verify_code_geometric

; VSA binding functions
extern vsa_bind
extern vsa_unbind
extern vsa_gen_role_pos
extern vsa_dot
extern vsa_normalize
extern vsa_init_random_vec

;; ============================================================
;; Symbolic Logic Representation
;; ============================================================
;;
;; Invariants are encoded as verification predicates:
;;
;; PRED_STACK_BALANCED:
;;   ∀ path through code: Σ(push) - Σ(pop) = 0 at ret
;;
;; PRED_REGS_PRESERVED:
;;   ∀ reg ∈ {rbx, rbp, r12-r15}:
;;     modified(reg) → saved_before(reg) ∧ restored_after(reg)
;;
;; PRED_VALID_JUMPS:
;;   ∀ jmp/jcc target: target ∈ [code_start, code_end]
;;
;; PRED_VALID_OPCODES:
;;   ∀ instruction: opcode ∈ ALLOWED_OPCODES
;;
;; These are checked by scanning the proposed code modification.
;; ============================================================

;; ============================================================
;; verify_init
;; Initialize verification subsystem
;; ============================================================
global verify_init
verify_init:
    mov dword [rel verify_enabled], 1
    mov dword [rel verify_depth], 0
    mov dword [rel snapshot_valid], 0
    ret

;; ============================================================
;; verify_enable / verify_disable
;; Toggle verification (for bootstrapping or performance)
;; ============================================================
global verify_enable
verify_enable:
    mov dword [rel verify_enabled], 1
    ret

global verify_disable
verify_disable:
    mov dword [rel verify_enabled], 0
    ret

;; ============================================================
;; verify_begin_modification
;; Call before any self-modification. Takes snapshot for rollback.
;; rdi = address to modify
;; rsi = size of modification
;; Returns: rax = 1 if ok to proceed, 0 if verification disabled
;; ============================================================
global verify_begin_modification
verify_begin_modification:
    push rbx
    push r12
    push r13

    ; Check if enabled
    cmp dword [rel verify_enabled], 0
    je .disabled

    ; Check size limit
    cmp rsi, 4096
    ja .too_large

    ; Save parameters
    mov r12, rdi                ; addr
    mov r13, rsi                ; size

    ; Take snapshot for potential rollback
    mov qword [rel snapshot_addr], r12
    mov qword [rel snapshot_size], r13

    ; Copy current content to snapshot buffer
    lea rdi, [rel snapshot_buf]
    mov rsi, r12
    mov rcx, r13
.copy_loop:
    test rcx, rcx
    jz .copy_done
    mov al, [rsi]
    mov [rdi], al
    inc rsi
    inc rdi
    dec rcx
    jmp .copy_loop
.copy_done:

    mov dword [rel snapshot_valid], 1
    inc dword [rel verify_depth]

    mov eax, 1
    jmp .done

.disabled:
    xor eax, eax
    jmp .done

.too_large:
    ; Can't snapshot, proceed without rollback capability
    mov dword [rel snapshot_valid], 0
    mov eax, 1

.done:
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; verify_modification
;; Verify a proposed code modification meets all invariants.
;; Uses verify_abstract (decoder-based) for proper instruction analysis.
;; rdi = address of code
;; rsi = size of code
;; Returns: rax = 1 if valid, 0 if invalid (with reason printed)
;; ============================================================
global verify_modification
verify_modification:
    push rbx
    push r12
    push r13
    sub rsp, VCS_SIZE + 8       ; space for VirtualCpuState + alignment

    ; Check if enabled
    cmp dword [rel verify_enabled], 0
    je .pass_disabled

    mov r12, rdi                ; code address
    mov r13, rsi                ; code size

    ; === Check 1: Valid opcode sequences (no invalid 64-bit opcodes) ===
    ; This uses decode_instruction_length to walk properly
    mov rdi, r12
    mov rsi, r13
    call verify_opcodes
    test eax, eax
    jz .fail_opcode

    ; === Check 2: Abstract interpretation (stack, jumps, forbidden, etc.) ===
    ; Uses decode_instruction_full to properly parse instructions
    mov rdi, r12
    mov rsi, r13
    lea rdx, [rsp]              ; VirtualCpuState on stack
    call verify_abstract
    test eax, eax
    jnz .pass                   ; verify_abstract returns 1 on success

    ; Abstract verification failed - check specific error flags
    test word [rsp + VCS_FLAGS], VCSF_STACK_UNDERFLOW
    jnz .fail_stack
    test word [rsp + VCS_FLAGS], VCSF_SAW_SYSCALL
    jnz .fail_forbidden
    test word [rsp + VCS_FLAGS], VCSF_SAW_INT
    jnz .fail_forbidden
    test word [rsp + VCS_FLAGS], VCSF_INVALID_JUMP
    jnz .fail_jump
    test word [rsp + VCS_FLAGS], VCSF_CALLEE_CLOBBER
    jnz .fail_reg
    ; Check if stack imbalance at RET (errors > 0 but no specific flag)
    cmp dword [rsp + VCS_STACK_DEPTH], 0
    jne .fail_stack
    ; Generic failure
    jmp .fail_opcode

    ; All checks passed
.pass:
    lea rdi, [rel verify_pass]
    call print_cstr
    mov eax, 1
    jmp .done

.pass_disabled:
    mov eax, 1
    jmp .done

.fail_opcode:
    lea rdi, [rel verify_fail]
    call print_cstr
    lea rdi, [rel verify_opcode]
    call print_cstr
    xor eax, eax
    jmp .done

.fail_stack:
    lea rdi, [rel verify_fail]
    call print_cstr
    lea rdi, [rel verify_stack]
    call print_cstr
    xor eax, eax
    jmp .done

.fail_jump:
    lea rdi, [rel verify_fail]
    call print_cstr
    lea rdi, [rel verify_jump]
    call print_cstr
    xor eax, eax
    jmp .done

.fail_forbidden:
    lea rdi, [rel verify_fail]
    call print_cstr
    lea rdi, [rel verify_opcode]
    call print_cstr
    xor eax, eax
    jmp .done

.fail_reg:
    lea rdi, [rel verify_fail]
    call print_cstr
    lea rdi, [rel verify_reg]
    call print_cstr
    xor eax, eax
    jmp .done

.done:
    add rsp, VCS_SIZE + 8
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; verify_commit
;; Called after successful modification. Clears snapshot.
;; ============================================================
global verify_commit
verify_commit:
    mov dword [rel snapshot_valid], 0
    cmp dword [rel verify_depth], 0
    je .done
    dec dword [rel verify_depth]
.done:
    ret

;; ============================================================
;; verify_rollback
;; Restore pre-modification state from snapshot.
;; Returns: rax = 1 if rolled back, 0 if no snapshot
;; ============================================================
global verify_rollback
verify_rollback:
    push rbx
    push r12
    push r13

    ; Check if we have a valid snapshot
    cmp dword [rel snapshot_valid], 0
    je .no_snapshot

    lea rdi, [rel verify_rollback_msg]
    call print_cstr

    ; Restore from snapshot
    mov rdi, [rel snapshot_addr]
    lea rsi, [rel snapshot_buf]
    mov rcx, [rel snapshot_size]
.restore_loop:
    test rcx, rcx
    jz .restore_done
    mov al, [rsi]
    mov [rdi], al
    inc rsi
    inc rdi
    dec rcx
    jmp .restore_loop
.restore_done:

    mov dword [rel snapshot_valid], 0
    dec dword [rel verify_depth]

    mov eax, 1
    jmp .done

.no_snapshot:
    xor eax, eax

.done:
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; verify_opcodes
;; Check that code contains only valid x86-64 opcodes.
;; Uses decode_instruction_length to properly walk instruction boundaries
;; and only check actual opcode bytes (not operands/immediates).
;; rdi = code, rsi = size
;; Returns: rax = 1 if valid, 0 if invalid
;; ============================================================
extern decode_instruction_length

verify_opcodes:
    push rbx
    push r12
    push r13
    push r14

    mov r12, rdi                ; code ptr
    mov r13, rsi                ; total size
    xor r14d, r14d              ; current offset

.scan_loop:
    cmp r14d, r13d
    jge .valid

    ; Get pointer to current instruction
    lea rdi, [r12 + r14]

    ; Decode instruction length (this properly handles REX prefixes, ModR/M, etc.)
    push r12
    push r13
    push r14
    call decode_instruction_length
    pop r14
    pop r13
    pop r12
    ; eax = instruction length

    ; Get the opcode byte (skip REX prefix if present)
    lea rbx, [r12 + r14]        ; instruction start
    movzx ecx, byte [rbx]

    ; Check for REX prefix (0x40-0x4F) - opcode is next byte
    cmp cl, 0x40
    jl .check_opcode
    cmp cl, 0x4F
    jg .check_opcode
    ; REX present, get actual opcode
    movzx ecx, byte [rbx + 1]

.check_opcode:
    ; Check against invalid 64-bit opcodes (these don't exist in long mode):
    ; Segment register push/pop: 0x06, 0x07, 0x0E, 0x16, 0x17, 0x1E, 0x1F
    cmp cl, 0x06
    je .invalid
    cmp cl, 0x07
    je .invalid
    cmp cl, 0x0E
    je .invalid
    cmp cl, 0x16
    je .invalid
    cmp cl, 0x17
    je .invalid
    cmp cl, 0x1E
    je .invalid
    cmp cl, 0x1F
    je .invalid

    ; BCD instructions: 0x27 (DAA), 0x2F (DAS), 0x37 (AAA), 0x3F (AAS)
    cmp cl, 0x27
    je .invalid
    cmp cl, 0x2F
    je .invalid
    cmp cl, 0x37
    je .invalid
    cmp cl, 0x3F
    je .invalid

    ; PUSHA/POPA: 0x60, 0x61
    cmp cl, 0x60
    je .invalid
    cmp cl, 0x61
    je .invalid

    ; BOUND: 0x62 (repurposed for EVEX in newer CPUs, but not in our patterns)
    cmp cl, 0x62
    je .invalid

    ; AAM/AAD: 0xD4, 0xD5
    cmp cl, 0xD4
    je .invalid
    cmp cl, 0xD5
    je .invalid

    ; Undefined: 0xD6
    cmp cl, 0xD6
    je .invalid

    ; This opcode is valid - advance by instruction length
    add r14d, eax
    jmp .scan_loop

.valid:
    mov eax, 1
    jmp .done

.invalid:
    xor eax, eax

.done:
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; verify_stack_balance
;; Symbolically verify stack balance: count push/pop/sub rsp/add rsp
;; rdi = code, rsi = size
;; Returns: rax = 1 if balanced, 0 if imbalanced
;;
;; Logic: Σ(push) + Σ(sub rsp,N)/8 = Σ(pop) + Σ(add rsp,N)/8
;; ============================================================
verify_stack_balance:
    push rbx
    push r12
    push r13
    push r14

    mov r12, rdi                ; code ptr
    mov r13, rsi                ; remaining size
    xor r14d, r14d              ; stack delta (positive = pushes, negative = pops)

.scan:
    cmp r13, 1
    jl .check_balance

    movzx eax, byte [r12]

    ; Check for PUSH (0x50-0x57, or 0x41 0x50-0x57 for r8-r15)
    cmp al, 0x50
    jl .not_push
    cmp al, 0x57
    jle .found_push

    ; Check for REX.B + PUSH (0x41 0x50-0x57)
    cmp al, 0x41
    jne .not_push
    cmp r13, 2
    jl .not_push
    movzx ebx, byte [r12 + 1]
    cmp bl, 0x50
    jl .not_push
    cmp bl, 0x57
    jg .not_push
    ; Found REX push
    inc r14d
    add r12, 2
    sub r13, 2
    jmp .scan

.found_push:
    inc r14d
    inc r12
    dec r13
    jmp .scan

.not_push:
    ; Check for POP (0x58-0x5F, or 0x41 0x58-0x5F for r8-r15)
    cmp al, 0x58
    jl .not_pop
    cmp al, 0x5F
    jle .found_pop
    jmp .not_pop

.found_pop:
    dec r14d
    inc r12
    dec r13
    jmp .scan

.not_pop:
    ; Check for RET (0xC3)
    cmp al, 0xC3
    jne .not_ret
    ; At ret, check balance
    test r14d, r14d
    jnz .imbalanced
    inc r12
    dec r13
    jmp .scan

.not_ret:
    ; Check for SUB RSP, imm8 (0x48 0x83 0xEC imm8)
    cmp al, 0x48
    jne .skip_byte
    cmp r13, 4
    jl .skip_byte
    cmp byte [r12 + 1], 0x83
    jne .skip_byte
    cmp byte [r12 + 2], 0xEC
    jne .skip_byte
    ; Found sub rsp, imm8
    movzx eax, byte [r12 + 3]
    shr eax, 3                  ; divide by 8
    add r14d, eax
    add r12, 4
    sub r13, 4
    jmp .scan

.skip_byte:
    inc r12
    dec r13
    jmp .scan

.check_balance:
    ; End of code - check final balance
    test r14d, r14d
    jnz .imbalanced

    mov eax, 1
    jmp .done

.imbalanced:
    xor eax, eax

.done:
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; verify_jump_targets
;; Check all jumps target within the code region or known safe targets.
;; rdi = code, rsi = size
;; Returns: rax = 1 if valid, 0 if invalid
;; ============================================================
verify_jump_targets:
    push rbx
    push r12
    push r13
    push r14
    push r15

    mov r12, rdi                ; code start
    mov r13, rsi                ; code size
    lea r14, [r12 + r13]        ; code end
    mov r15, r12                ; current position

.scan:
    cmp r15, r14
    jge .valid

    movzx eax, byte [r15]

    ; Check for short jump (0xEB)
    cmp al, 0xEB
    jne .not_short_jmp
    cmp r15, r14
    jge .invalid                ; not enough bytes
    movsx ebx, byte [r15 + 1]   ; signed offset
    lea rcx, [r15 + 2 + rbx]    ; target address
    ; Check target in bounds
    cmp rcx, r12
    jl .invalid
    cmp rcx, r14
    jg .invalid
    add r15, 2
    jmp .scan

.not_short_jmp:
    ; Check for conditional jumps (0x70-0x7F)
    cmp al, 0x70
    jl .not_cond_jmp
    cmp al, 0x7F
    jg .not_cond_jmp
    ; Short conditional jump
    lea rcx, [r15 + 1]
    cmp rcx, r14
    jge .invalid
    movsx ebx, byte [r15 + 1]
    lea rcx, [r15 + 2 + rbx]
    cmp rcx, r12
    jl .invalid
    cmp rcx, r14
    jg .invalid
    add r15, 2
    jmp .scan

.not_cond_jmp:
    ; Check for near jump (0xE9)
    cmp al, 0xE9
    jne .not_near_jmp
    lea rcx, [r15 + 4]
    cmp rcx, r14
    jge .invalid
    mov ebx, [r15 + 1]          ; 32-bit offset
    movsxd rbx, ebx
    lea rcx, [r15 + 5 + rbx]
    ; Near jumps can go to .text section (known safe)
    ; Check if in .text (0x401000 - 0x410000) or in code region
    cmp rcx, 0x401000
    jl .check_code_region
    cmp rcx, 0x410000
    jl .jmp_ok
.check_code_region:
    cmp rcx, r12
    jl .invalid
    cmp rcx, r14
    jg .invalid
.jmp_ok:
    add r15, 5
    jmp .scan

.not_near_jmp:
    ; Skip other bytes
    inc r15
    jmp .scan

.valid:
    mov eax, 1
    jmp .done

.invalid:
    xor eax, eax

.done:
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; verify_no_forbidden
;; Check code doesn't contain forbidden instruction sequences.
;; Forbidden: syscall (except in known safe patterns), int, hlt
;; rdi = code, rsi = size
;; Returns: rax = 1 if ok, 0 if forbidden found
;; ============================================================
verify_no_forbidden:
    push rbx
    push r12
    push r13

    mov r12, rdi
    mov r13, rsi

.scan:
    cmp r13, 1
    jl .valid

    movzx eax, byte [r12]

    ; Check for INT (0xCD)
    cmp al, 0xCD
    je .forbidden

    ; Check for HLT (0xF4)
    cmp al, 0xF4
    je .forbidden

    ; Check for SYSCALL (0x0F 0x05)
    cmp al, 0x0F
    jne .not_syscall
    cmp r13, 2
    jl .not_syscall
    cmp byte [r12 + 1], 0x05
    je .forbidden

.not_syscall:
    inc r12
    dec r13
    jmp .scan

.valid:
    mov eax, 1
    jmp .done

.forbidden:
    xor eax, eax

.done:
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; verify_call_targets
;; Check all CALL instructions target valid subroutines or .text.
;; This enables recursive schema hierarchy while maintaining safety.
;; rdi = code, rsi = size
;; Returns: rax = 1 if valid, 0 if invalid
;;
;; PRED_VALID_CALL:
;;   ∀ call target: target ∈ SUBROUTINE_TABLE ∨ target ∈ .text
;; ============================================================
verify_call_targets:
    push rbx
    push r12
    push r13
    push r14
    push r15

    mov r12, rdi                ; code start
    mov r13, rsi                ; code size
    lea r14, [r12 + r13]        ; code end
    mov r15, r12                ; current position

.scan:
    cmp r15, r14
    jge .valid

    movzx eax, byte [r15]

    ; Check for near CALL (0xE8 rel32)
    cmp al, 0xE8
    jne .not_call

    ; Need at least 5 bytes for CALL rel32
    lea rcx, [r15 + 4]
    cmp rcx, r14
    jge .invalid                ; not enough bytes

    ; Extract rel32 offset and compute target
    mov ebx, [r15 + 1]          ; 32-bit signed offset
    movsxd rbx, ebx
    lea rcx, [r15 + 5 + rbx]    ; absolute target address

    ; Validate the call target
    push r12
    push r13
    push r14
    push r15
    mov rdi, rcx
    call verify_valid_call      ; from factor.asm
    pop r15
    pop r14
    pop r13
    pop r12

    test eax, eax
    jz .invalid

    add r15, 5
    jmp .scan

.not_call:
    ; Skip other bytes
    inc r15
    jmp .scan

.valid:
    mov eax, 1
    jmp .done

.invalid:
    xor eax, eax

.done:
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; verify_region_invariants
;; Verify a complete region header + code meets invariants.
;; rdi = region header address
;; Returns: rax = 1 if valid, 0 if invalid
;; ============================================================
global verify_region_invariants
verify_region_invariants:
    push rbx
    push r12

    mov r12, rdi                ; region header

    ; Validate that header has reasonable code length
    movzx eax, word [r12 + RHDR_CODE_LEN]
    test eax, eax
    jz .invalid                 ; no code = invalid
    cmp eax, 4096               ; sanity check: < 4KB
    ja .invalid

    ; Get code start and size
    lea rdi, [r12 + RHDR_SIZE]  ; code starts after header
    movzx esi, word [r12 + RHDR_CODE_LEN]

    ; Verify the code
    call verify_modification
    test eax, eax
    jz .invalid

    mov eax, 1
    jmp .done

.invalid:
    xor eax, eax

.done:
    pop r12
    pop rbx
    ret

;; ============================================================
;; LOGIC PROBE: Abstract Interpreter
;; ============================================================
;; The Logic Probe symbolically executes code to prove safety theorems
;; without actually running it. Uses VirtualCpuState to track:
;;   - Stack depth (must be 0 at RET)
;;   - Modified registers (callee-saved must be preserved)
;;   - Branch targets (must be in-bounds or known safe)
;; ============================================================

extern decode_instruction_full

;; ============================================================
;; verify_abstract(code, size, out_state)
;; rdi = code pointer
;; rsi = code size
;; rdx = pointer to VirtualCpuState (VCS_SIZE bytes)
;; Returns: rax = 1 if all theorems proved, 0 if any violation
;;
;; This is the core abstract interpreter that proves:
;;   THEOREM 1 (Balance): stack_depth == 0 at every RET
;;   THEOREM 2 (Preservation): callee-saved regs saved before mod, restored after
;;   THEOREM 3 (Containment): all jump/call targets in bounds or .text
;;   THEOREM 4 (No Forbidden): no syscall/int/hlt without broker
;; ============================================================
global verify_abstract
verify_abstract:
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub rsp, DI_SIZE + 8      ; space for decoded instruction + alignment

    mov r12, rdi              ; code start
    mov r13, rsi              ; code size
    mov r14, rdx              ; VirtualCpuState

    ; Initialize VirtualCpuState
    xor eax, eax
    mov ecx, VCS_SIZE / 8
    mov rdi, r14
.zero_vcs:
    mov qword [rdi], rax
    add rdi, 8
    dec ecx
    jnz .zero_vcs

    ; Set initial state
    mov dword [r14 + VCS_STACK_DEPTH], 0
    mov dword [r14 + VCS_MAX_DEPTH], 0
    mov dword [r14 + VCS_MIN_DEPTH], 0

    ; r15 = current offset within code
    xor r15d, r15d

.interpret_loop:
    cmp r15d, r13d
    jge .end_of_code

    ; Decode current instruction
    lea rdi, [r12 + r15]
    lea rsi, [rsp]            ; output decoded instruction on stack
    call decode_instruction_full
    ; eax = instruction length

    ; Get opcode class
    movzx ebx, byte [rsp + DI_OP_CLASS]
    mov [r14 + VCS_LAST_OP], bl

    ; === Update virtual state based on opcode class ===
    cmp ebx, OP_STACK_PUSH
    je .handle_push
    cmp ebx, OP_STACK_POP
    je .handle_pop
    cmp ebx, OP_STACK_ADJ
    je .handle_stack_adj
    cmp ebx, OP_FLOW_RET
    je .handle_ret
    cmp ebx, OP_FLOW_JUMP
    je .handle_jump
    cmp ebx, OP_FLOW_JCC
    je .handle_jcc
    cmp ebx, OP_FLOW_CALL
    je .handle_call
    cmp ebx, OP_WRITE_REG
    je .handle_write_reg
    cmp ebx, OP_SYSCALL
    je .handle_syscall
    cmp ebx, OP_INTERRUPT
    je .handle_interrupt
    cmp ebx, OP_PRIVILEGED
    je .handle_privileged
    jmp .next_instr

.handle_push:
    ; Stack depth increases by 1
    inc dword [r14 + VCS_STACK_DEPTH]
    mov eax, [r14 + VCS_STACK_DEPTH]
    cmp eax, [r14 + VCS_MAX_DEPTH]
    jle .push_max_ok
    mov [r14 + VCS_MAX_DEPTH], eax
.push_max_ok:
    ; Track which register was pushed (for callee-saved detection)
    movzx ecx, byte [rsp + DI_SRC_REG]
    cmp cl, 0xFF
    je .next_instr
    ; Mark register as saved
    mov eax, 1
    shl eax, cl
    or [r14 + VCS_REG_SAVED], ax
    jmp .next_instr

.handle_pop:
    ; Stack depth decreases by 1
    dec dword [r14 + VCS_STACK_DEPTH]
    mov eax, [r14 + VCS_STACK_DEPTH]
    cmp eax, 0
    jge .pop_depth_ok
    ; Stack underflow!
    or word [r14 + VCS_FLAGS], VCSF_STACK_UNDERFLOW
    inc dword [r14 + VCS_ERRORS]
.pop_depth_ok:
    cmp eax, [r14 + VCS_MIN_DEPTH]
    jge .pop_min_ok
    mov [r14 + VCS_MIN_DEPTH], eax
.pop_min_ok:
    ; Track which register was popped (for callee-saved restoration)
    movzx ecx, byte [rsp + DI_DST_REG]
    cmp cl, 0xFF
    je .next_instr
    mov eax, 1
    shl eax, cl
    or [r14 + VCS_REG_RESTORED], ax
    jmp .next_instr

.handle_stack_adj:
    ; Stack adjusts by immediate value / 8
    mov rax, [rsp + DI_IMM64]
    sar rax, 3                ; divide by 8 (assuming 8-byte stack slots)
    ; For SUB RSP, imm is negative; for ADD RSP, positive
    add [r14 + VCS_STACK_DEPTH], eax
    ; Update max/min
    mov eax, [r14 + VCS_STACK_DEPTH]
    cmp eax, [r14 + VCS_MAX_DEPTH]
    jle .adj_max_ok
    mov [r14 + VCS_MAX_DEPTH], eax
.adj_max_ok:
    cmp eax, [r14 + VCS_MIN_DEPTH]
    jge .adj_min_ok
    mov [r14 + VCS_MIN_DEPTH], eax
.adj_min_ok:
    jmp .next_instr

.handle_ret:
    ; THEOREM 1: Stack must be balanced at RET
    or word [r14 + VCS_FLAGS], VCSF_SAW_RET
    mov eax, [r14 + VCS_STACK_DEPTH]
    test eax, eax
    jz .ret_balanced
    ; Stack imbalance at RET!
    inc dword [r14 + VCS_ERRORS]
.ret_balanced:
    ; THEOREM 2: Check callee-saved preservation
    ; modified ∧ saved → restored
    movzx eax, word [r14 + VCS_REG_MODIFIED]
    movzx ecx, word [r14 + VCS_REG_SAVED]
    movzx edx, word [r14 + VCS_REG_RESTORED]
    and eax, CALLEE_SAVED_MASK      ; only care about callee-saved
    mov ebx, eax
    and ebx, ecx                     ; modified AND saved
    not ecx                          ; ~saved
    or ecx, edx                      ; ~saved OR restored
    and eax, ecx                     ; modified AND (~saved OR restored)
    cmp eax, ebx
    je .callee_ok
    ; Callee-saved register not properly preserved
    or word [r14 + VCS_FLAGS], VCSF_CALLEE_CLOBBER
    inc dword [r14 + VCS_ERRORS]
.callee_ok:
    jmp .next_instr

.handle_jump:
    ; THEOREM 3: Jump target must be in bounds
    mov eax, [rsp + DI_TARGET]
    ; Check if target is in code region
    cmp eax, 0
    jl .check_text_jump
    cmp eax, r13d
    jle .jump_ok
.check_text_jump:
    ; Allow jumps to .text section (system code)
    lea rcx, [r12 + rax]          ; absolute target
    cmp rcx, 0x401000
    jl .bad_jump
    cmp rcx, 0x500000             ; generous .text bound
    jl .jump_ok
.bad_jump:
    or word [r14 + VCS_FLAGS], VCSF_INVALID_JUMP
    inc dword [r14 + VCS_ERRORS]
.jump_ok:
    inc dword [r14 + VCS_BRANCH_TARGETS]
    jmp .next_instr

.handle_jcc:
    ; Same as jump for target validation
    mov eax, [rsp + DI_TARGET]
    cmp eax, 0
    jl .jcc_check_text
    cmp eax, r13d
    jle .jcc_ok
.jcc_check_text:
    lea rcx, [r12 + rax]
    cmp rcx, 0x401000
    jl .bad_jcc
    cmp rcx, 0x500000
    jl .jcc_ok
.bad_jcc:
    or word [r14 + VCS_FLAGS], VCSF_INVALID_JUMP
    inc dword [r14 + VCS_ERRORS]
.jcc_ok:
    inc dword [r14 + VCS_BRANCH_TARGETS]
    jmp .next_instr

.handle_call:
    ; CALL pushes return address (stack depth +1)
    inc dword [r14 + VCS_STACK_DEPTH]
    ; Target validation (similar to jump)
    mov eax, [rsp + DI_TARGET]
    lea rcx, [r12 + rax]
    ; Allow calls to .text
    cmp rcx, 0x401000
    jl .call_check_region
    cmp rcx, 0x500000
    jl .call_ok
.call_check_region:
    ; Check if in current region or surface
    ; NOTE: 0x100000000 and 0x200000000 are 33-bit, sign-extend if used as imm32
    mov rax, SURFACE_BASE          ; 0x100000000
    cmp rcx, rax
    jl .bad_call
    mov rax, SURFACE_BASE * 2      ; 0x200000000
    cmp rcx, rax
    jl .call_ok
.bad_call:
    or word [r14 + VCS_FLAGS], VCSF_INVALID_JUMP
    inc dword [r14 + VCS_ERRORS]
.call_ok:
    inc dword [r14 + VCS_BRANCH_TARGETS]
    jmp .next_instr

.handle_write_reg:
    ; Track which register is being modified
    movzx ecx, byte [rsp + DI_DST_REG]
    cmp cl, 0xFF
    je .next_instr
    mov eax, 1
    shl eax, cl
    or [r14 + VCS_REG_MODIFIED], ax
    jmp .next_instr

.handle_syscall:
    ; THEOREM 4: No direct syscall allowed
    or word [r14 + VCS_FLAGS], VCSF_SAW_SYSCALL
    inc dword [r14 + VCS_ERRORS]
    jmp .next_instr

.handle_interrupt:
    ; THEOREM 4: No interrupt allowed
    or word [r14 + VCS_FLAGS], VCSF_SAW_INT
    inc dword [r14 + VCS_ERRORS]
    jmp .next_instr

.handle_privileged:
    ; Privileged instruction not allowed
    inc dword [r14 + VCS_ERRORS]
    jmp .next_instr

.next_instr:
    ; Advance by instruction length
    movzx eax, byte [rsp + DI_LENGTH]
    add r15d, eax
    jmp .interpret_loop

.end_of_code:
    ; Final checks
    ; If we never saw a RET and code is non-trivial, warn
    test word [r14 + VCS_FLAGS], VCSF_SAW_RET
    jnz .check_result
    cmp r13d, 3
    jl .check_result
    inc dword [r14 + VCS_WARNINGS]

.check_result:
    ; Return 1 if no errors, 0 if errors
    cmp dword [r14 + VCS_ERRORS], 0
    jne .has_errors

    mov eax, 1
    jmp .abstract_done

.has_errors:
    xor eax, eax

.abstract_done:
    add rsp, DI_SIZE + 8
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; verify_theorems(code, size) → eax (1=pass, 0=fail)
;; High-level wrapper that runs abstract interpretation and
;; prints detailed error messages.
;; ============================================================
global verify_theorems
verify_theorems:
    push rbx
    push r12
    push r13
    sub rsp, VCS_SIZE + 8     ; space for VirtualCpuState

    mov r12, rdi              ; code
    mov r13, rsi              ; size

    ; Run abstract interpreter
    mov rdi, r12
    mov rsi, r13
    lea rdx, [rsp]
    call verify_abstract

    mov ebx, eax              ; save result

    ; Check specific failures and print messages
    test word [rsp + VCS_FLAGS], VCSF_STACK_UNDERFLOW
    jz .no_underflow
    lea rdi, [rel verify_fail]
    call print_cstr
    lea rdi, [rel verify_stack]
    call print_cstr
.no_underflow:

    test word [rsp + VCS_FLAGS], VCSF_SAW_SYSCALL
    jz .no_syscall
    lea rdi, [rel verify_fail]
    call print_cstr
    lea rdi, [rel verify_opcode]
    call print_cstr
.no_syscall:

    test word [rsp + VCS_FLAGS], VCSF_INVALID_JUMP
    jz .no_bad_jump
    lea rdi, [rel verify_fail]
    call print_cstr
    lea rdi, [rel verify_jump]
    call print_cstr
.no_bad_jump:

    test word [rsp + VCS_FLAGS], VCSF_CALLEE_CLOBBER
    jz .no_clobber
    lea rdi, [rel verify_fail]
    call print_cstr
    lea rdi, [rel verify_reg]
    call print_cstr
.no_clobber:

    mov eax, ebx

    add rsp, VCS_SIZE + 8
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; GEOMETRIC GATE: The Unified Field Theory Verification
;; ============================================================
;; Instead of if-statements checking specific conditions,
;; we encode code as a vector and compute similarity to
;; "known safe" and "known dangerous" pattern templates.
;; This enables nuanced, analog safety checking where
;; "almost safe" code can be distinguished from "clearly unsafe".
;;
;; The math:
;;   safety_score = dot(code_vec, safety_template)
;;   danger_score = dot(code_vec, danger_template)
;;   verdict = safety_score > THRESHOLD && danger_score < THRESHOLD
;;
;; This is "One Math" — Linear Algebra replaces conditionals.
;; ============================================================

;; ============================================================
;; verify_set_mode(mode)
;; edi=mode (0=abstract, 1=geometric, 2=both)
;; Sets which verification method to use.
;; ============================================================
global verify_set_mode
verify_set_mode:
    mov [rel verify_mode], edi
    ret

;; ============================================================
;; verify_get_mode() → eax
;; Returns current verification mode.
;; ============================================================
global verify_get_mode
verify_get_mode:
    mov eax, [rel verify_mode]
    ret

;; ============================================================
;; verify_geometric_gate(code, size) → eax (1=safe, 0=unsafe)
;; rdi=code pointer
;; rsi=code size
;;
;; The Geometric Gate: encode code to vector, check safety via
;; dot product with safety/danger templates.
;; Returns: 1 if safe, 0 if unsafe, with xmm0 = safety score
;; ============================================================
global verify_geometric_gate
verify_geometric_gate:
    push rbx
    push r12
    push r13
    sub rsp, HOLO_VEC_BYTES + 16      ; temp vector + safety score storage

    mov r12, rdi          ; code_ptr
    mov r13d, esi         ; code_len

    ; Initialize safety templates if needed
    call init_safety_vectors

    ; Encode code to vector
    mov rdi, r12
    mov esi, r13d
    lea rdx, [rsp]        ; output vector on stack
    call encode_code_to_vector

    ; Check safety score
    lea rdi, [rsp]
    call check_code_safety
    movsd [rsp + HOLO_VEC_BYTES], xmm0    ; save safety score

    ; Check danger score
    lea rdi, [rsp]
    call check_code_danger
    movsd [rsp + HOLO_VEC_BYTES + 8], xmm0  ; save danger score

    ; Load safety threshold
    mov rax, SAFETY_THRESHOLD
    movq xmm1, rax

    ; Load safety score
    movsd xmm0, [rsp + HOLO_VEC_BYTES]

    ; Check: safety_score > threshold?
    ucomisd xmm0, xmm1
    jbe .unsafe

    ; Check: danger_score < threshold?
    movsd xmm0, [rsp + HOLO_VEC_BYTES + 8]
    ucomisd xmm0, xmm1
    jae .unsafe

    ; Passed both checks!
    lea rdi, [rel verify_geom_pass]
    call print_cstr

    ; Return safety score in xmm0
    movsd xmm0, [rsp + HOLO_VEC_BYTES]
    mov eax, 1
    jmp .geom_done

.unsafe:
    lea rdi, [rel verify_geom_fail]
    call print_cstr

    ; Print the safety score for debugging
    lea rdi, [rel verify_geom_score]
    call print_cstr
    movsd xmm0, [rsp + HOLO_VEC_BYTES]
    call print_f64
    call print_newline

    xor eax, eax

.geom_done:
    add rsp, HOLO_VEC_BYTES + 16
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; verify_unified(code, size) → eax (1=safe, 0=unsafe)
;; rdi=code pointer
;; rsi=code size
;;
;; Unified verification: runs either abstract, geometric, or both
;; based on verify_mode setting.
;; Mode 0: Abstract interpreter only (traditional)
;; Mode 1: Geometric gate only (vector-based)
;; Mode 2: Both must pass (most secure)
;; ============================================================
global verify_unified
verify_unified:
    push rbx
    push r12
    push r13
    sub rsp, 8            ; align

    mov r12, rdi          ; code
    mov r13, rsi          ; size

    ; Check mode
    mov eax, [rel verify_mode]

    test eax, eax
    jz .mode_abstract

    cmp eax, 1
    je .mode_geometric

    cmp eax, 2
    je .mode_both

    ; Default to abstract
.mode_abstract:
    mov rdi, r12
    mov rsi, r13
    call verify_modification
    jmp .unified_done

.mode_geometric:
    mov rdi, r12
    mov rsi, r13
    call verify_geometric_gate
    jmp .unified_done

.mode_both:
    ; Run abstract first
    mov rdi, r12
    mov rsi, r13
    call verify_modification
    test eax, eax
    jz .unified_done      ; abstract failed, return 0

    ; Abstract passed, now run geometric
    mov rdi, r12
    mov rsi, r13
    call verify_geometric_gate
    ; Return geometric result (both must pass)

.unified_done:
    add rsp, 8
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; verify_region_geometric(region_ptr) → eax (1=safe, 0=unsafe)
;; rdi=region header ptr
;;
;; Convenience function to verify a region using the geometric gate.
;; ============================================================
global verify_region_geometric
verify_region_geometric:
    push rbx

    mov rbx, rdi          ; region_ptr

    ; Get code pointer (after header)
    lea rdi, [rbx + RHDR_SIZE]

    ; Get code length
    movzx esi, word [rbx + RHDR_CODE_LEN]

    ; Call geometric gate
    call verify_geometric_gate

    pop rbx
    ret

;; ============================================================
;; get_code_safety_score(code, size) → xmm0 (safety score f64)
;; rdi=code pointer
;; rsi=code size
;;
;; Returns raw safety score without threshold comparison.
;; Useful for gradual/analog safety evaluation.
;; ============================================================
global get_code_safety_score
get_code_safety_score:
    push rbx
    push r12
    sub rsp, HOLO_VEC_BYTES + 8

    mov r12, rdi
    mov ebx, esi

    ; Initialize and encode
    call init_safety_vectors

    mov rdi, r12
    mov esi, ebx
    lea rdx, [rsp]
    call encode_code_to_vector

    ; Get safety score
    lea rdi, [rsp]
    call check_code_safety

    add rsp, HOLO_VEC_BYTES + 8
    pop r12
    pop rbx
    ret

;; ============================================================
;; VSA BINDING VERIFICATION
;; ============================================================
;; These tests verify that the VSA binding mathematics work correctly.
;; Key property: unbind(bind(A, B), A) ≈ B for normalized vectors.
;; ============================================================

section .data
    bind_test_pass: db "[VERIFY/VSA] Bind/unbind cycle PASSED", 10, 0
    bind_test_fail: db "[VERIFY/VSA] Bind/unbind cycle FAILED: similarity = ", 0
    role_test_pass: db "[VERIFY/VSA] Role vectors orthogonal: PASSED", 10, 0
    role_test_fail: db "[VERIFY/VSA] Role vectors NOT orthogonal: ", 0

section .text

;; ============================================================
;; verify_bind_unbind() → eax (1=pass, 0=fail)
;; Tests that unbind(bind(ROLE, FILLER), ROLE) ≈ FILLER
;; Uses a sign vector (role) so that role² = 1 for each element.
;; ============================================================
global verify_bind_unbind
verify_bind_unbind:
    push rbx
    push r12
    push r13
    push r14
    sub rsp, HOLO_VEC_BYTES * 4 + 8  ; role, filler, bound, recovered + align

    ; Allocate: rsp+0 = role, rsp+HOLO = filler, rsp+2*HOLO = bound, rsp+3*HOLO = recovered
    mov r12, rsp                        ; role (sign vector)
    lea r13, [rsp + HOLO_VEC_BYTES]     ; filler (random)
    lea r14, [rsp + HOLO_VEC_BYTES * 2] ; bound
    lea rbx, [rsp + HOLO_VEC_BYTES * 3] ; recovered

    ; Generate ROLE_POS_0 as role vector (sign vector with ±1.0)
    xor edi, edi          ; position 0
    mov rsi, r12
    call vsa_gen_role_pos

    ; Initialize filler with random normalized values
    mov rdi, r13
    call vsa_init_random_vec

    ; bound = bind(role, filler)
    mov rdi, r12
    mov rsi, r13
    mov rdx, r14
    call vsa_bind

    ; recovered = unbind(bound, role) = bind(bound, role)
    ; Since role is a sign vector, role² = 1, so unbind(bind(R,F), R) = F
    mov rdi, r14
    mov rsi, r12
    mov rdx, rbx
    call vsa_unbind

    ; Check similarity: dot(recovered, filler) should be close to 1.0
    ; For perfect recovery with sign vectors, this should be exactly 1.0
    mov rdi, rbx
    mov rsi, r13
    call vsa_dot
    ; xmm0 = similarity (should be 1.0 for perfect recovery)

    ; Check if similarity > 0.99 (should be exactly 1.0 for sign vectors)
    mov rax, 0x3FEFAE147AE147AE  ; 0.99 f64
    movq xmm1, rax
    ucomisd xmm0, xmm1
    jb .bind_fail

    ; PASSED
    lea rdi, [rel bind_test_pass]
    call print_cstr
    mov eax, 1
    jmp .bind_done

.bind_fail:
    ; FAILED - print similarity
    lea rdi, [rel bind_test_fail]
    call print_cstr
    ; xmm0 still has similarity
    call print_f64
    call print_newline
    xor eax, eax

.bind_done:
    add rsp, HOLO_VEC_BYTES * 4 + 8
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; verify_role_orthogonality() → eax (1=pass, 0=fail)
;; Tests that positional role vectors are approximately orthogonal.
;; dot(ROLE_i, ROLE_j) should be ~0 for i != j
;; ============================================================
global verify_role_orthogonality
verify_role_orthogonality:
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub rsp, HOLO_VEC_BYTES * 2 + 8  ; two role vectors + align

    mov r12, rsp                      ; role_0
    lea r13, [rsp + HOLO_VEC_BYTES]  ; role_1

    ; Generate ROLE_POS_0
    xor edi, edi          ; position 0
    mov rsi, r12
    call vsa_gen_role_pos

    ; Generate ROLE_POS_1
    mov edi, 1            ; position 1
    mov rsi, r13
    call vsa_gen_role_pos

    ; Check dot product - should be 0 (orthogonal)
    mov rdi, r12
    mov rsi, r13
    call vsa_dot
    ; xmm0 = dot product

    ; Check if |dot| < 0.1 (should be 0 for orthogonal)
    ; Take absolute value
    mov rax, 0x7FFFFFFFFFFFFFFF   ; mask for abs
    movq xmm1, rax
    andpd xmm0, xmm1

    mov rax, 0x3FB999999999999A   ; 0.1 f64
    movq xmm1, rax
    ucomisd xmm0, xmm1
    ja .ortho_fail

    ; PASSED
    lea rdi, [rel role_test_pass]
    call print_cstr
    mov eax, 1
    jmp .ortho_done

.ortho_fail:
    ; FAILED - print dot product
    lea rdi, [rel role_test_fail]
    call print_cstr
    call print_f64
    call print_newline
    xor eax, eax

.ortho_done:
    add rsp, HOLO_VEC_BYTES * 2 + 8
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; verify_vsa_math() → eax (1=all pass, 0=any fail)
;; Run all VSA math verification tests.
;; ============================================================
global verify_vsa_math
verify_vsa_math:
    push rbx

    ; Test 1: bind/unbind cycle
    call verify_bind_unbind
    test eax, eax
    jz .vsa_fail
    mov ebx, eax

    ; Test 2: role orthogonality
    call verify_role_orthogonality
    test eax, eax
    jz .vsa_fail
    and ebx, eax

    mov eax, ebx
    jmp .vsa_done

.vsa_fail:
    xor eax, eax

.vsa_done:
    pop rbx
    ret
; vsa.asm — Vector Symbolic Architecture: HOLO_DIM-dim f64 holographic operations
;
; @entry holo_bind_f64(rdi=a, rsi=b, rdx=out) -> void ; XOR-like binding
; @entry holo_unbind_f64(rdi=a, rsi=b, rdx=out) -> void ; = bind (HRR self-inverse)
; @entry holo_superpose_f64(rdi=dst, rsi=src) -> void ; element-wise add
; @entry holo_dot_f64(rdi=a, rsi=b) -> xmm0=similarity
; @entry holo_cosim_f64(rdi=a, rsi=b) -> xmm0=cosine ; normalized dot product
; @entry holo_scale_f64(rdi=vec, xmm0=scalar) -> void ; multiply all elements
; @entry holo_gen_vec(edi=seed, rsi=out) -> void ; deterministic from hash
; @entry holo_store(edi=ctx, esi=token, xmm0=strength) -> void
; @entry holo_predict(edi=ctx) -> eax=token, xmm0=conf
; @entry holo_decay_all() -> void
; @entry vocab_register(edi=token) -> void
; @entry confidence_update(edi=ctx, esi=is_hit) -> void
; @entry confidence_query(edi=ctx) -> xmm0=conf
; @calledby dispatch.asm, learn.asm, receipt.asm, dreams.asm
;
; STORAGE: HOLO_OFFSET, 256 zones × HOLO_VEC_BYTES (f64[HOLO_DIM] each)
;
; KEY INSIGHT: unbind = bind in HRR (Holographic Reduced Representation)
;   Query: unbind(probe, trace) → resonates with bound content
;
; GOTCHAS:
;   - All holo_* funcs use f64[HOLO_DIM], legacy vsa_* use f32[HOLO_DIM]
;   - holo_gen_vec is deterministic: same seed = same vector
;   - Superposition accumulates - trace gets denser, needs decay
%include "syscalls.inc"
%include "constants.inc"
%include "vsa_ops.inc"

section .text

extern sys_getrandom
extern get_vsa_base

;; ============================================================
;; vsa_init_random
;; Initialize VSA arena with random vectors for common tokens
;; Uses getrandom syscall, then normalizes each vector
;; ============================================================
global vsa_init_random
vsa_init_random:
    push rbx
    push r12
    push r13

    mov rbx, SURFACE_BASE + VSA_OFFSET

    ; Initialize first 256 token vectors with random data
    xor r12d, r12d            ; token index

.init_loop:
    cmp r12d, 256
    jge .init_done

    ; Calculate vector address
    mov rdi, r12
    shl rdi, 16               ; * 65536 (VSA_VEC_BYTES for f64)
    add rdi, rbx              ; vsa_base + token_id * VSA_VEC_BYTES

    ; Fill with random bytes
    mov r13, rdi              ; save vec ptr
    mov rsi, VSA_VEC_BYTES    ; 8192 bytes
    xor edx, edx             ; flags = 0
    mov rax, SYS_GETRANDOM
    syscall

    ; Convert random u64 bits to valid f64 in [-1.0, 1.0):
    ;   1. Extract sign bit from random data
    ;   2. Force exponent to 0x3FF → value in [1.0, 2.0)
    ;   3. Subtract 1.0 → [0.0, 1.0)
    ;   4. Apply sign → [-1.0, 1.0)
    mov rdi, r13
    mov ecx, VSA_DIM
.conv_loop:
    mov rax, [rdi]            ; random u64
    mov rdx, rax
    shr rdx, 63              ; sign bit → rdx[0]
    shl rdx, 63              ; sign bit back to bit 63
    ; Force exponent = 0x3FF, keep mantissa (bits 51:0)
    mov r8, 0x000FFFFFFFFFFFFF
    and rax, r8              ; keep only mantissa
    mov r8, 0x3FF0000000000000
    or rax, r8               ; set exponent to 0x3FF → [1.0, 2.0)
    mov [rdi], rax
    movsd xmm0, [rdi]
    mov r8, 0x3FF0000000000000
    movq xmm1, r8            ; 1.0
    subsd xmm0, xmm1         ; [0.0, 1.0)
    movq xmm1, rdx           ; sign bit
    orpd xmm0, xmm1          ; apply sign → [-1.0, 1.0)
    movsd [rdi], xmm0
    add rdi, 8
    dec ecx
    jnz .conv_loop

    ; Normalize to unit length
    mov rdi, r13
    call vsa_normalize

    inc r12d
    jmp .init_loop

.init_done:
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; vsa_init_random_vec(vec_ptr)
;; rdi = pointer to vector to fill with random normalized values
;; Fills a single vector with random values in [-1,1] and normalizes.
;; ============================================================
global vsa_init_random_vec
vsa_init_random_vec:
    push rbx
    push r12

    mov r12, rdi              ; save vec ptr

    ; Fill with random bytes
    mov rsi, VSA_VEC_BYTES    ; 8192 bytes
    xor edx, edx              ; flags = 0
    mov rax, SYS_GETRANDOM
    syscall

    ; Convert random u64 bits to valid f64 in [-1.0, 1.0)
    mov rdi, r12
    mov ecx, VSA_DIM
.conv_loop:
    mov rax, [rdi]            ; random u64
    mov rdx, rax
    shr rdx, 63               ; sign bit → rdx[0]
    shl rdx, 63               ; sign bit back to bit 63
    mov r8, 0x000FFFFFFFFFFFFF
    and rax, r8               ; keep only mantissa
    mov rbx, 0x3FF0000000000000
    or rax, rbx               ; set exponent to 0x3FF → [1.0, 2.0)
    mov [rdi], rax
    movsd xmm0, [rdi]
    mov rbx, 0x3FF0000000000000
    movq xmm1, rbx            ; 1.0
    subsd xmm0, xmm1          ; [0.0, 1.0)
    movq xmm1, rdx            ; sign bit
    orpd xmm0, xmm1           ; apply sign → [-1.0, 1.0)
    movsd [rdi], xmm0
    add rdi, 8
    dec ecx
    jnz .conv_loop

    ; Normalize to unit length
    mov rdi, r12
    call vsa_normalize

    pop r12
    pop rbx
    ret

;; ============================================================
;; vsa_dot(a_ptr, b_ptr) → xmm0 (f64)
;; rdi=a, rsi=b
;; Returns dot product of two 1024-element f64 vectors
;; ============================================================
global vsa_dot
vsa_dot:
    vxorpd ymm0, ymm0, ymm0  ; accumulator (4 doubles)
    mov ecx, VSA_DIM / 4     ; 256 iterations of 4 doubles

.dot_loop:
    vmovupd ymm1, [rdi]
    vmovupd ymm2, [rsi]
    vfmadd231pd ymm0, ymm1, ymm2  ; acc += a * b
    add rdi, 32
    add rsi, 32
    dec ecx
    jnz .dot_loop

    ; Horizontal sum: 4 doubles → 1 double
    vextractf128 xmm1, ymm0, 1
    vaddpd xmm0, xmm0, xmm1  ; 2 doubles
    vhaddpd xmm0, xmm0, xmm0 ; 1 double in xmm0[0]

    vzeroupper
    ret

;; ============================================================
;; vsa_magnitude(ptr) → xmm0
;; rdi=vector ptr
;; Returns sqrt(dot(v, v))
;; ============================================================
global vsa_magnitude
vsa_magnitude:
    mov rsi, rdi              ; b = a
    call vsa_dot              ; dot(a, a) in xmm0 (f64)
    sqrtsd xmm0, xmm0        ; sqrt
    ret

;; ============================================================
;; vsa_cosim(a_ptr, b_ptr) → xmm0
;; rdi=a, rsi=b
;; Returns cosine similarity: dot(a,b) / (|a| * |b|)
;; ============================================================
global vsa_cosim
vsa_cosim:
    push rbx
    push r12
    push r13
    sub rsp, 32               ; space for intermediate results (f64)

    mov r12, rdi              ; save a
    mov r13, rsi              ; save b

    ; dot(a, b)
    call vsa_dot
    movsd [rsp], xmm0        ; save dot product (f64)

    ; |a|
    mov rdi, r12
    mov rsi, r12
    call vsa_dot
    sqrtsd xmm0, xmm0
    movsd [rsp + 8], xmm0    ; save |a| (f64)

    ; |b|
    mov rdi, r13
    mov rsi, r13
    call vsa_dot
    sqrtsd xmm0, xmm0        ; |b| in xmm0 (f64)

    ; result = dot / (|a| * |b|)
    movsd xmm1, [rsp + 8]    ; |a|
    mulsd xmm0, xmm1         ; |a| * |b|

    ; Check for zero magnitude
    xorpd xmm2, xmm2
    ucomisd xmm0, xmm2
    je .zero_mag

    movsd xmm1, [rsp]        ; dot product
    divsd xmm1, xmm0
    movapd xmm0, xmm1
    jmp .cosim_done

.zero_mag:
    xorpd xmm0, xmm0         ; return 0 if zero magnitude

.cosim_done:
    add rsp, 32
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; vsa_bind(a_ptr, b_ptr, out_ptr)
;; rdi=a, rsi=b, rdx=out
;; Circular convolution (simplified: element-wise XOR of bit patterns)
;; For HRR, this would be circular convolution via FFT.
;; We approximate with element-wise multiply for speed.
;; ============================================================
global vsa_bind
vsa_bind:
    mov ecx, VSA_DIM / 4     ; 256 iterations of 4 doubles

.bind_loop:
    vmovupd ymm0, [rdi]
    vmovupd ymm1, [rsi]
    vmulpd ymm2, ymm0, ymm1  ; element-wise multiply
    vmovupd [rdx], ymm2
    add rdi, 32
    add rsi, 32
    add rdx, 32
    dec ecx
    jnz .bind_loop

    vzeroupper
    ret

;; ============================================================
;; vsa_unbind(bound_ptr, role_ptr, out_ptr)
;; rdi=bound, rsi=role, rdx=out
;; For HRR with normalized vectors: unbind = bind (self-inverse)
;; unbind(bind(A, B), A) ≈ B
;; ============================================================
global vsa_unbind
vsa_unbind:
    ; Element-wise multiply is self-inverse for unit vectors
    jmp vsa_bind

;; ============================================================
;; vsa_gen_role_pos(pos, out_ptr)
;; edi = position (0-7)
;; rsi = output vector pointer
;; Generates positional role vector as a SIGN VECTOR (all ±1.0).
;; Sign pattern: element[i] = +1 if popcount(i & (pos_mask)) is even, else -1
;; This creates quasi-orthogonal sign vectors suitable for self-inverse binding.
;; ============================================================
global vsa_gen_role_pos
vsa_gen_role_pos:
    push rbx
    push r12
    push r13
    push r14

    mov r12d, edi               ; position (0-7)
    mov r13, rsi                ; output pointer

    ; Create position mask: different bits set for each position
    ; pos 0: mask = 0x001, pos 1: mask = 0x002, etc.
    ; This creates Walsh-Hadamard like patterns
    mov eax, 1
    mov ecx, r12d
    shl eax, cl
    mov r14d, eax               ; r14d = 1 << pos = position mask

    ; Constants for +1.0 and -1.0
    mov rbx, 0x3FF0000000000000 ; +1.0 f64
    mov rax, 0xBFF0000000000000 ; -1.0 f64

    ; Fill all 1024 dimensions
    xor ecx, ecx                ; dimension index
.fill_loop:
    cmp ecx, VSA_DIM
    jge .fill_done

    ; Compute sign: if (popcount(dim & pos_mask) & 1) then -1 else +1
    mov edx, ecx
    and edx, r14d               ; dim & pos_mask
    popcnt edx, edx             ; count set bits
    test edx, 1                 ; odd or even?
    jnz .set_minus

    ; Even popcount: set +1.0
    mov r8d, ecx
    shl r8, 3                   ; dim * 8
    mov [r13 + r8], rbx
    jmp .next_dim

.set_minus:
    ; Odd popcount: set -1.0
    mov r8d, ecx
    shl r8, 3
    mov [r13 + r8], rax

.next_dim:
    inc ecx
    jmp .fill_loop

.fill_done:
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; vsa_superpose(a_ptr, b_ptr)
;; rdi=a (modified in place: a += b), rsi=b
;; Bundling operation: vector addition
;; ============================================================
global vsa_superpose
vsa_superpose:
    mov ecx, VSA_DIM / 4     ; 256 iterations of 4 doubles

.super_loop:
    vmovupd ymm0, [rdi]
    vmovupd ymm1, [rsi]
    vaddpd ymm0, ymm0, ymm1
    vmovupd [rdi], ymm0
    add rdi, 32
    add rsi, 32
    dec ecx
    jnz .super_loop

    vzeroupper
    ret

;; ============================================================
;; vsa_normalize(ptr)
;; rdi=vector (modified in place to unit length)
;; ============================================================
global vsa_normalize
vsa_normalize:
    push rbx
    mov rbx, rdi

    ; First compute magnitude
    mov rsi, rdi
    call vsa_dot              ; dot(v,v) in xmm0 (f64)
    sqrtsd xmm0, xmm0        ; magnitude

    ; Check for zero
    xorpd xmm1, xmm1
    ucomisd xmm0, xmm1
    je .norm_zero

    ; Compute 1/magnitude and broadcast
    mov rax, 0x3FF0000000000000  ; 1.0 f64
    movq xmm1, rax
    divsd xmm1, xmm0         ; 1/mag
    vbroadcastsd ymm2, xmm1  ; broadcast scalar

    ; Scale all elements
    mov rdi, rbx
    mov ecx, VSA_DIM / 4     ; 256 iterations of 4 doubles
.norm_loop:
    vmovupd ymm0, [rdi]
    vmulpd ymm0, ymm0, ymm2
    vmovupd [rdi], ymm0
    add rdi, 32
    dec ecx
    jnz .norm_loop

.norm_zero:
    vzeroupper
    pop rbx
    ret

;; ============================================================
;; vsa_permute(src_ptr, dst_ptr, shift)
;; rdi=src, rsi=dst, edx=shift amount (elements)
;; Circular shift of vector elements
;; ============================================================
global vsa_permute
vsa_permute:
    push rbx
    push r12
    push r13

    mov rbx, rdi              ; src
    mov r12, rsi              ; dst
    mov r13d, edx             ; shift

    ; Normalize shift to [0, VSA_DIM)
    mov eax, r13d
    cdq
    mov ecx, VSA_DIM
    idiv ecx
    mov r13d, edx             ; shift mod DIM
    test r13d, r13d
    jns .pos_shift
    add r13d, VSA_DIM
.pos_shift:

    ; Copy with circular shift
    ; dst[i] = src[(i + shift) % DIM]
    xor ecx, ecx             ; i = 0
.perm_loop:
    cmp ecx, VSA_DIM
    jge .perm_done

    ; src_idx = (i + shift) % DIM
    mov eax, ecx
    add eax, r13d
    cmp eax, VSA_DIM
    jl .no_wrap
    sub eax, VSA_DIM
.no_wrap:
    ; dst[i] = src[src_idx] (8 bytes per f64 element)
    mov rdx, [rbx + rax * 8]
    mov [r12 + rcx * 8], rdx

    inc ecx
    jmp .perm_loop

.perm_done:
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; vsa_zero(ptr)
;; rdi=vector to zero out
;; ============================================================
global vsa_zero
vsa_zero:
    vxorpd ymm0, ymm0, ymm0
    mov ecx, VSA_DIM / 4     ; 256 iterations of 4 doubles
.zero_loop:
    vmovupd [rdi], ymm0
    add rdi, 32
    dec ecx
    jnz .zero_loop
    vzeroupper
    ret

;; ============================================================
;; vsa_scale(ptr, scalar)
;; rdi=vector (modified in place), xmm0=scalar
;; ============================================================
global vsa_scale
vsa_scale:
    vbroadcastsd ymm1, xmm0  ; broadcast f64 scalar
    mov ecx, VSA_DIM / 4     ; 256 iterations of 4 doubles
.scale_loop:
    vmovupd ymm0, [rdi]
    vmulpd ymm0, ymm0, ymm1
    vmovupd [rdi], ymm0
    add rdi, 32
    dec ecx
    jnz .scale_loop
    vzeroupper
    ret

;; ============================================================
;; vsa_get_token_vec(token_id) → rax (ptr to vector)
;; edi=token_id
;; Returns pointer to the token's vector in VSA arena
;; ============================================================
global vsa_get_token_vec
vsa_get_token_vec:
    mov eax, edi
    shl rax, 16               ; * 65536 (VSA_VEC_BYTES for f64)
    mov rcx, SURFACE_BASE + VSA_OFFSET
    add rax, rcx
    ret

;; ============================================================
;; vsa_encode_context(token_ids_ptr, count, out_ptr)
;; rdi=array of u32 token IDs, esi=count, rdx=output vector
;; Encodes a sequence as superposition of permuted token vectors
;; context = sum(permute(vec[token[i]], i))
;; ============================================================
extern print_cstr

;; ============================================================
;; Holographic Memory Section — ALL f64 (double precision)
;; Vectors are f64[1024] = 8192 bytes each.
;; Traces, binding, superposition, decay — all f64.
;; ============================================================

section .data
    align 8
    holo_learn_rate:  dq 0.1
    holo_decay_val:   dq 0.9995
    holo_threshold:   dq 0.15
    holo_one:         dq 1.0

section .text

;; ============================================================
;; holo_dot_f64(a, b) → xmm0 (f64 scalar)
;; rdi=a (f64[1024]), rsi=b (f64[1024])
;; AVX2 fused multiply-add dot product in double precision.
;; ============================================================
global holo_dot_f64
holo_dot_f64:
    vxorpd ymm0, ymm0, ymm0  ; accumulator (4 doubles)
    mov ecx, HOLO_DIM / 4    ; 256 iterations of 4 doubles

.hdot_loop:
    vmovupd ymm1, [rdi]
    vmovupd ymm2, [rsi]
    vfmadd231pd ymm0, ymm1, ymm2  ; acc += a * b
    add rdi, 32
    add rsi, 32
    dec ecx
    jnz .hdot_loop

    ; Horizontal sum: 4 doubles → 1 double
    vextractf128 xmm1, ymm0, 1
    vaddpd xmm0, xmm0, xmm1  ; 2 doubles
    vhaddpd xmm0, xmm0, xmm0 ; 1 double in xmm0[0]

    vzeroupper
    ret

;; ============================================================
;; holo_bind_f64(a, b, out)
;; rdi=a, rsi=b, rdx=out — all f64[1024]
;; Element-wise multiply (binding operation) in f64.
;; ============================================================
global holo_bind_f64
holo_bind_f64:
    mov ecx, HOLO_DIM / 4    ; 256 iterations

.hbind_loop:
    vmovupd ymm0, [rdi]
    vmovupd ymm1, [rsi]
    vmulpd ymm2, ymm0, ymm1
    vmovupd [rdx], ymm2
    add rdi, 32
    add rsi, 32
    add rdx, 32
    dec ecx
    jnz .hbind_loop

    vzeroupper
    ret

;; ============================================================
;; holo_unbind_f64(a, b, out)
;; rdi=a, rsi=b, rdx=out — all f64[1024]
;; For HRR: unbind = bind (self-inverse property)
;; unbind(bind(A, B), A) ≈ B
;; ============================================================
global holo_unbind_f64
holo_unbind_f64:
    jmp holo_bind_f64         ; same operation for HRR

;; ============================================================
;; holo_superpose_f64(a, b)
;; rdi=a (modified: a += b), rsi=b — f64[1024]
;; Vector addition (bundling) in f64.
;; ============================================================
global holo_superpose_f64
holo_superpose_f64:
    mov ecx, HOLO_DIM / 4

.hsuper_loop:
    vmovupd ymm0, [rdi]
    vmovupd ymm1, [rsi]
    vaddpd ymm0, ymm0, ymm1
    vmovupd [rdi], ymm0
    add rdi, 32
    add rsi, 32
    dec ecx
    jnz .hsuper_loop

    vzeroupper
    ret

;; ============================================================
;; holo_scale_f64(vec, scalar)
;; rdi=vec (f64[1024], modified in place), xmm0=scalar (f64)
;; ============================================================
global holo_scale_f64
holo_scale_f64:
    vbroadcastsd ymm1, xmm0
    mov ecx, HOLO_DIM / 4

.hscale_loop:
    vmovupd ymm0, [rdi]
    vmulpd ymm0, ymm0, ymm1
    vmovupd [rdi], ymm0
    add rdi, 32
    dec ecx
    jnz .hscale_loop

    vzeroupper
    ret

;; ============================================================
;; holo_cosim_f64(a_ptr, b_ptr) → xmm0
;; rdi=a (f64[1024]), rsi=b (f64[1024])
;; Returns cosine similarity: dot(a,b) / (|a| * |b|)
;; ============================================================
global holo_cosim_f64
holo_cosim_f64:
    push rbx
    push r12
    push r13
    sub rsp, 32               ; space for intermediate results

    mov r12, rdi              ; save a
    mov r13, rsi              ; save b

    ; dot(a, b)
    call holo_dot_f64
    movsd [rsp], xmm0        ; save dot product

    ; |a| = sqrt(dot(a, a))
    mov rdi, r12
    mov rsi, r12
    call holo_dot_f64
    sqrtsd xmm0, xmm0
    movsd [rsp + 8], xmm0    ; save |a|

    ; |b| = sqrt(dot(b, b))
    mov rdi, r13
    mov rsi, r13
    call holo_dot_f64
    sqrtsd xmm0, xmm0        ; |b| in xmm0

    ; result = dot / (|a| * |b|)
    movsd xmm1, [rsp + 8]    ; |a|
    mulsd xmm0, xmm1         ; |a| * |b|

    ; Check for zero magnitude
    xorpd xmm2, xmm2
    ucomisd xmm0, xmm2
    je .hcosim_zero_mag

    movsd xmm1, [rsp]        ; dot product
    divsd xmm1, xmm0
    movapd xmm0, xmm1
    jmp .hcosim_done

.hcosim_zero_mag:
    xorpd xmm0, xmm0         ; return 0 if zero magnitude

.hcosim_done:
    add rsp, 32
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; holo_normalize_f64(vec)
;; rdi=vec (f64[1024], modified to unit length)
;; ============================================================
global holo_normalize_f64
holo_normalize_f64:
    push rbx
    mov rbx, rdi

    ; dot(v, v)
    mov rsi, rdi
    call holo_dot_f64         ; xmm0 = dot product (f64)
    sqrtsd xmm0, xmm0        ; magnitude

    ; Check for zero
    xorpd xmm1, xmm1
    ucomisd xmm0, xmm1
    je .hnorm_zero

    ; 1.0 / magnitude
    movsd xmm1, [rel holo_one]
    divsd xmm1, xmm0
    movapd xmm0, xmm1        ; scalar = 1/mag

    mov rdi, rbx
    call holo_scale_f64

.hnorm_zero:
    vzeroupper
    pop rbx
    ret

;; ============================================================
;; holo_magnitude_f64(vec) → xmm0 (f64)
;; rdi=vec (f64[1024])
;; Returns sqrt(dot(v, v)) without modifying the vector.
;; ============================================================
global holo_magnitude_f64
holo_magnitude_f64:
    mov rsi, rdi
    call holo_dot_f64
    sqrtsd xmm0, xmm0
    ret

;; ============================================================
;; holo_gen_vec(hash, out_ptr)
;; edi=hash (u32), rsi=output vector ptr (f64[1024])
;; Generates a unique 1024-dim f64 vector from a 32-bit hash:
;;   basis_idx = hash & 0xFF → one of 256 orthogonal basis vectors
;;   shift = (hash >> 8) & 0x3FF → circular rotation
;;   Reads f64 basis directly and permutes into output.
;; ============================================================
global holo_gen_vec
holo_gen_vec:
    push rbx
    push r12
    push r13
    push r14

    mov r12d, edi             ; hash
    mov r13, rsi              ; output ptr (f64[1024])

    ; basis_idx = hash & 0xFF
    movzx eax, r12b
    shl rax, 16               ; * 65536 (VSA_VEC_BYTES for f64 basis)
    mov rbx, SURFACE_BASE + VSA_OFFSET
    add rbx, rax              ; rbx = f64 basis vector ptr

    ; shift = (hash >> 8) & 0x3FF
    mov r14d, r12d
    shr r14d, 8
    and r14d, 0x3FF           ; shift amount (0-1023)

    ; Permute: out[i] = basis[(i + shift) % 1024] (all f64)
    xor ecx, ecx             ; i = 0
.gen_loop:
    cmp ecx, HOLO_DIM
    jge .gen_done

    ; src_idx = (i + shift) % 1024
    mov eax, ecx
    add eax, r14d
    cmp eax, HOLO_DIM
    jl .gen_no_wrap
    sub eax, HOLO_DIM
.gen_no_wrap:
    ; Load f64 basis[src_idx], store to out[i]
    mov rdx, [rbx + rax * 8]         ; f64 load (as u64)
    mov [r13 + rcx * 8], rdx         ; f64 store

    inc ecx
    jmp .gen_loop

.gen_done:
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; holo_store(ctx_hash, token_id, strength)
;; edi=ctx_hash, esi=token_id, xmm0=strength (f64)
;; Binds context and token f64 vectors, scales by strength,
;; and superposes into the appropriate f64 trace.
;; ============================================================
global holo_store
holo_store:
    push rbx
    push r12
    push r13
    push r14
    sub rsp, HOLO_VEC_BYTES * 3 + 16  ; 3 temp f64 vectors + strength storage

    mov r12d, edi             ; ctx_hash
    mov r13d, esi             ; token_id
    ; Save strength (f64) in the padding area
    movsd [rsp + HOLO_VEC_BYTES * 3], xmm0

    ; 1. ctx_vec = holo_gen_vec(ctx_hash) → f64[1024]
    mov edi, r12d
    lea rsi, [rsp]            ; ctx_vec at [rsp]
    call holo_gen_vec

    ; 2. tok_vec = holo_gen_vec(token_id) → f64[1024]
    mov edi, r13d
    lea rsi, [rsp + HOLO_VEC_BYTES]
    call holo_gen_vec

    ; 3. bound = holo_bind_f64(ctx_vec, tok_vec)
    lea rdi, [rsp]
    lea rsi, [rsp + HOLO_VEC_BYTES]
    lea rdx, [rsp + HOLO_VEC_BYTES * 2]
    call holo_bind_f64

    ; 4. holo_scale_f64(bound, strength)
    lea rdi, [rsp + HOLO_VEC_BYTES * 2]
    movsd xmm0, [rsp + HOLO_VEC_BYTES * 3]  ; reload strength
    call holo_scale_f64

    ; 5. trace_idx = ctx_hash & 0xFFF (4096 buckets for better fidelity)
    mov eax, r12d
    and eax, 0xFFF
    ; trace_ptr = SURFACE_BASE + HOLO_OFFSET + trace_idx * HOLO_VEC_BYTES
    imul rax, rax, HOLO_VEC_BYTES
    mov rbx, SURFACE_BASE + HOLO_OFFSET
    add rbx, rax

    ; 6. holo_superpose_f64(trace, bound)
    mov rdi, rbx
    lea rsi, [rsp + HOLO_VEC_BYTES * 2]
    call holo_superpose_f64

    add rsp, HOLO_VEC_BYTES * 3 + 16
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; holo_predict(ctx_hash) → eax=best_token_id, xmm0=confidence (f64)
;; edi=ctx_hash
;; Unbinds context from trace, normalizes, scans vocabulary.
;; All operations in f64 for maximum fidelity.
;; ============================================================
global holo_predict
holo_predict:
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub rsp, HOLO_VEC_BYTES * 2 + 16  ; ctx_vec, candidate, + locals
    ; locals at [rsp + HOLO_VEC_BYTES*2]:
    ;   [+0] = best_token (u32)
    ;   [+4] = pad
    ;   [+8] = best_sim (f64)

    mov r12d, edi             ; ctx_hash

    ; 1. ctx_vec = holo_gen_vec(ctx_hash) → f64[1024]
    mov edi, r12d
    lea rsi, [rsp]
    call holo_gen_vec

    ; 2. trace_idx = ctx_hash & 0xFFF (4096 buckets for better fidelity)
    mov eax, r12d
    and eax, 0xFFF
    imul rax, rax, HOLO_VEC_BYTES
    mov r14, SURFACE_BASE + HOLO_OFFSET
    add r14, rax              ; r14 = trace ptr (f64[1024])

    ; 3. candidate = holo_bind_f64(trace, ctx_vec) — unbind
    mov rdi, r14
    lea rsi, [rsp]
    lea rdx, [rsp + HOLO_VEC_BYTES]
    call holo_bind_f64

    ; Normalize candidate for clean cosine matching
    lea rdi, [rsp + HOLO_VEC_BYTES]
    call holo_normalize_f64

    ; Initialize best tracking
    lea rbx, [rsp + HOLO_VEC_BYTES * 2]
    mov dword [rbx], 0               ; best_token = 0
    xorpd xmm0, xmm0
    movsd [rbx + 8], xmm0            ; best_sim = 0.0 (f64)

    ; 4. Scan vocabulary
    mov r15, SURFACE_BASE
    mov r13d, [r15 + STATE_OFFSET + ST_VOCAB_COUNT]
    test r13d, r13d
    jz .holo_pred_done

    ; Cap scan at VOCAB_MAX_SCAN (256)
    cmp r13d, VOCAB_MAX_SCAN
    jle .scan_count_ok
    mov r13d, VOCAB_MAX_SCAN
.scan_count_ok:

    ; r15 = vocab base ptr
    mov r15, SURFACE_BASE + VOCAB_OFFSET
    xor ecx, ecx             ; vocab scan index

.holo_scan_loop:
    cmp ecx, r13d
    jge .holo_pred_done
    push rcx

    ; Load token_id from vocab entry
    imul rax, rcx, VOCAB_ENTRY_SIZE
    add rax, r15
    mov edi, [rax]            ; token_id

    ; Generate token vector — reuse ctx_vec space (candidate already computed)
    lea rsi, [rsp + 8]        ; +8 for pushed rcx
    call holo_gen_vec

    ; dot_f64(candidate, tok_vec)
    lea rdi, [rsp + HOLO_VEC_BYTES + 8]   ; candidate (+8 for pushed rcx)
    lea rsi, [rsp + 8]                     ; tok_vec (+8 for pushed rcx)
    call holo_dot_f64
    ; xmm0 = similarity (f64)

    ; Compare with best (f64)
    lea rbx, [rsp + HOLO_VEC_BYTES * 2 + 8]  ; +8 for pushed rcx
    ucomisd xmm0, [rbx + 8]
    jbe .holo_not_better

    ; New best
    movsd [rbx + 8], xmm0            ; best_sim = sim (f64)
    pop rcx
    push rcx
    ; Reload token_id
    imul rax, rcx, VOCAB_ENTRY_SIZE
    add rax, r15
    mov eax, [rax]
    mov [rbx], eax                    ; best_token = token_id

.holo_not_better:
    pop rcx
    inc ecx
    jmp .holo_scan_loop

.holo_pred_done:
    ; Return best_token in eax, confidence in xmm0 (f64)
    lea rbx, [rsp + HOLO_VEC_BYTES * 2]
    mov eax, [rbx]            ; best_token
    movsd xmm0, [rbx + 8]    ; best_sim (f64 confidence)

    add rsp, HOLO_VEC_BYTES * 2 + 16
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; holo_decay_all()
;; Scales all f64 trace vectors by HOLO_DECAY (0.9995)
;; Inlined loop: broadcasts decay, walks all traces.
;; ============================================================
global holo_decay_all
holo_decay_all:
    push rbx

    mov rbx, SURFACE_BASE + HOLO_OFFSET

    ; Broadcast decay constant to all 4 lanes
    movsd xmm0, [rel holo_decay_val]
    vbroadcastsd ymm2, xmm0  ; ymm2 = [0.9995, 0.9995, 0.9995, 0.9995]

    ; Total elements = HOLO_TRACES * HOLO_DIM = 256 * 1024 = 262144 doubles
    ; Process 4 at a time = 65536 iterations
    mov ecx, (HOLO_TRACES * HOLO_DIM) / 4

.decay_all_loop:
    vmovupd ymm0, [rbx]
    vmulpd ymm0, ymm0, ymm2
    vmovupd [rbx], ymm0
    add rbx, 32
    dec ecx
    jnz .decay_all_loop

    vzeroupper
    pop rbx
    ret

;; ============================================================
;; vocab_register(token_id)
;; edi=token_id
;; Appends token to vocabulary or increments its count.
;; ============================================================
global vocab_register
vocab_register:
    push rbx
    push r12
    push r13

    mov r12d, edi             ; token_id
    mov rbx, SURFACE_BASE
    mov r13, SURFACE_BASE + VOCAB_OFFSET

    ; Get current vocab count
    mov ecx, [rbx + STATE_OFFSET + ST_VOCAB_COUNT]

    ; Search for existing entry
    xor edx, edx
.vocab_search:
    cmp edx, ecx
    jge .vocab_append

    imul rax, rdx, VOCAB_ENTRY_SIZE
    add rax, r13
    cmp [rax], r12d           ; compare token_id
    je .vocab_found

    inc edx
    jmp .vocab_search

.vocab_found:
    ; Increment count
    inc dword [rax + 4]
    jmp .vocab_done

.vocab_append:
    ; Append new entry
    imul rax, rcx, VOCAB_ENTRY_SIZE
    add rax, r13
    mov [rax], r12d           ; token_id
    mov dword [rax + 4], 1    ; count = 1

    ; Increment vocab count
    inc dword [rbx + STATE_OFFSET + ST_VOCAB_COUNT]

.vocab_done:
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; vocab_count() → eax
;; Returns current vocabulary size.
;; ============================================================
global vocab_count
vocab_count:
    mov rax, SURFACE_BASE
    mov eax, [rax + STATE_OFFSET + ST_VOCAB_COUNT]
    ret

;; ============================================================
;; End Holographic Memory Section
;; ============================================================

;; ============================================================
;; Topological Metacognition: Confidence Vector Operations
;; The system "feels" differently about different contexts.
;; ============================================================

section .data
    align 8
    conf_hit_weight:  dq 0.3      ; positive weight on hit
    conf_miss_weight: dq -0.3     ; negative weight on miss
    conf_decay:       dq 0.998    ; slow decay per step
    conf_anxious:     dq -0.2     ; below this = anxious about context
    conf_confident:   dq 0.2      ; above this = confident about context
    conf_update_count: dq 0       ; update counter for observability

section .text

;; ============================================================
;; confidence_update(ctx_hash, is_hit)
;; edi=ctx_hash, esi=is_hit (1=hit, 0=miss)
;; Superposes context vector into confidence vector with +/- weight.
;; Hit → system becomes more confident about this context type.
;; Miss → system becomes more anxious about this context type.
;; ============================================================
global confidence_update
confidence_update:
    push rbx
    push r12
    push r13
    sub rsp, HOLO_VEC_BYTES + 16  ; temp ctx_vec + weight storage

    ; Debug: increment update counter
    inc qword [rel conf_update_count]

    mov r12d, edi             ; ctx_hash
    mov r13d, esi             ; is_hit

    ; 1. Generate context vector
    mov edi, r12d
    lea rsi, [rsp]            ; ctx_vec at [rsp]
    call holo_gen_vec

    ; 2. Select weight based on hit/miss
    test r13d, r13d
    jz .use_miss_weight
    movsd xmm0, [rel conf_hit_weight]
    jmp .scale_vec
.use_miss_weight:
    movsd xmm0, [rel conf_miss_weight]

.scale_vec:
    ; 3. Scale the context vector by weight
    lea rdi, [rsp]
    call holo_scale_f64

    ; 4. Superpose into confidence vector
    mov rdi, SURFACE_BASE + CONFIDENCE_VEC_OFFSET
    lea rsi, [rsp]            ; scaled ctx_vec
    call holo_superpose_f64

    add rsp, HOLO_VEC_BYTES + 16
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; confidence_query(ctx_hash) → xmm0 (f64 confidence score)
;; edi=ctx_hash
;; Returns dot product of context vector and confidence vector.
;; Positive = confident about this context type.
;; Negative = anxious about this context type.
;; ============================================================
global confidence_query
confidence_query:
    push rbx
    push r12
    sub rsp, HOLO_VEC_BYTES   ; temp ctx_vec

    mov r12d, edi             ; ctx_hash

    ; 1. Generate context vector
    mov edi, r12d
    lea rsi, [rsp]
    call holo_gen_vec

    ; 2. Normalize context vector for clean comparison
    lea rdi, [rsp]
    call holo_normalize_f64

    ; 3. Dot product with confidence vector
    lea rdi, [rsp]
    mov rsi, SURFACE_BASE + CONFIDENCE_VEC_OFFSET
    call holo_dot_f64
    ; xmm0 = confidence score

    add rsp, HOLO_VEC_BYTES
    pop r12
    pop rbx
    ret

;; ============================================================
;; confidence_decay_all()
;; Slowly decays the confidence vector toward neutral (0).
;; Called periodically to prevent runaway confidence/anxiety.
;; ============================================================
global confidence_decay_all
confidence_decay_all:
    push rbx

    mov rdi, SURFACE_BASE + CONFIDENCE_VEC_OFFSET
    movsd xmm0, [rel conf_decay]
    call holo_scale_f64

    pop rbx
    ret

;; ============================================================
;; confidence_get_update_count() → rax (u64)
;; Returns the number of times confidence_update was called.
;; ============================================================
global confidence_get_update_count
confidence_get_update_count:
    mov rax, [rel conf_update_count]
    ret

;; ============================================================
;; confidence_get_feeling(ctx_hash) → eax (0=neutral, 1=confident, 2=anxious)
;; edi=ctx_hash
;; Returns the system's "feeling" about this context type.
;; Used to select dispatch mode: anxious → deliberate, confident → fast.
;; ============================================================
global confidence_get_feeling
confidence_get_feeling:
    push rbx

    call confidence_query     ; xmm0 = confidence score

    ; Check if confident (> +0.25)
    movsd xmm1, [rel conf_confident]
    ucomisd xmm0, xmm1
    ja .feeling_confident

    ; Check if anxious (< -0.25)
    movsd xmm1, [rel conf_anxious]
    ucomisd xmm0, xmm1
    jb .feeling_anxious

    ; Neutral
    xor eax, eax
    jmp .feeling_done

.feeling_confident:
    mov eax, 1
    jmp .feeling_done

.feeling_anxious:
    mov eax, 2

.feeling_done:
    pop rbx
    ret

;; ============================================================
;; Resonant Dispatch: VSA-based fuzzy matching
;; ============================================================

section .data
    align 8
    resonant_threshold: dq 0.7    ; similarity required for fuzzy match

section .text

;; ============================================================
;; resonant_match(region_ptr, ctx_hash) -> xmm0 (similarity 0.0-1.0)
;; rdi=region header ptr (must be RTYPE_RESONANT)
;; esi=current context hash (32-bit)
;;
;; Generates context vectors from both hashes and computes
;; cosine similarity. Returns 0.0 for non-resonant regions.
;;
;; Resonant region code layout:
;;   [RHDR_SIZE+0]:  B8 xx xx xx xx  (mov eax, expected_ctx_hash)
;;   [RHDR_SIZE+5]:  B8 xx xx xx xx  (mov eax, predicted_token)
;;   [RHDR_SIZE+10]: C3              (ret)
;; The expected_ctx_hash is extracted from byte offset 1-4.
;; ============================================================
global resonant_match
resonant_match:
    push rbx
    push r12
    push r13
    push r14
    sub rsp, HOLO_VEC_BYTES * 2   ; space for two context vectors

    mov r12, rdi              ; region_ptr
    mov r13d, esi             ; incoming ctx_hash

    ; Extract expected_ctx_hash from region code
    ; Resonant regions have: MOV EAX, imm32 at RHDR_SIZE
    ; Check opcode is 0xB8 (mov eax, imm32)
    cmp byte [r12 + RHDR_SIZE], 0xB8
    jne .not_resonant

    ; Extract the expected context hash (imm32 at offset 1)
    mov r14d, [r12 + RHDR_SIZE + 1]

    ; Generate vector for expected context -> stack[0]
    mov edi, r14d
    lea rsi, [rsp]
    call holo_gen_vec

    ; Generate vector for incoming context -> stack[HOLO_VEC_BYTES]
    mov edi, r13d
    lea rsi, [rsp + HOLO_VEC_BYTES]
    call holo_gen_vec

    ; Normalize both vectors for proper cosine similarity
    lea rdi, [rsp]
    call holo_normalize_f64

    lea rdi, [rsp + HOLO_VEC_BYTES]
    call holo_normalize_f64

    ; Compute dot product (cosine similarity of unit vectors)
    lea rdi, [rsp]
    lea rsi, [rsp + HOLO_VEC_BYTES]
    call holo_dot_f64
    ; xmm0 = similarity score [-1.0, 1.0]

    ; Clamp to [0.0, 1.0] (negative similarity = no match)
    xorpd xmm1, xmm1
    maxsd xmm0, xmm1          ; max(sim, 0.0)

    jmp .resonant_done

.not_resonant:
    ; Return 0.0 for non-resonant regions
    xorpd xmm0, xmm0

.resonant_done:
    add rsp, HOLO_VEC_BYTES * 2
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; resonant_get_threshold() -> xmm0 (f64 threshold)
;; Returns the resonant matching threshold (0.7)
;; ============================================================
global resonant_get_threshold
resonant_get_threshold:
    movsd xmm0, [rel resonant_threshold]
    ret

;; ============================================================
;; holo_query_valence(ctx_hash) -> xmm0 (valence f64)
;; edi=ctx_hash
;; Queries the valence channel of the holographic trace
;; associated with this context. Returns the "felt sense"
;; of memories stored under this context — positive if
;; learned during reward, negative if learned during cost.
;; ============================================================
global holo_query_valence
holo_query_valence:
    push rbx
    sub rsp, HOLO_VEC_BYTES   ; temp ctx_vec

    mov ebx, edi              ; save ctx_hash

    ; Generate context vector
    mov edi, ebx
    lea rsi, [rsp]
    call holo_gen_vec

    ; Get trace pointer
    mov eax, ebx
    and eax, 0xFFF            ; trace_idx = ctx_hash & 0xFFF (4096 buckets)
    imul rax, rax, HOLO_VEC_BYTES
    mov rdi, SURFACE_BASE + HOLO_OFFSET
    add rdi, rax              ; trace ptr

    ; Unbind: trace * ctx_vec (element-wise multiply)
    ; But for valence, we just need the valence channel dot product
    ; Simpler: extract valence from trace directly (unbinding doesn't affect it much)
    movsd xmm0, [rdi + VSA_VALENCE_OFFSET]

    add rsp, HOLO_VEC_BYTES
    pop rbx
    ret

;; ============================================================
;; resonant_extract_token(region_ptr) -> eax (predicted token)
;; rdi=region header ptr (must be RTYPE_RESONANT)
;; Extracts the predicted token from a resonant region.
;; Returns 0 if not a valid resonant region.
;;
;; Layout:
;;   [RHDR_SIZE+0]:  B8 ctx_hash      (mov eax, expected_ctx)
;;   [RHDR_SIZE+5]:  B8 token_id      (mov eax, predicted_token)
;;   [RHDR_SIZE+10]: C3               (ret)
;; ============================================================
global resonant_extract_token
resonant_extract_token:
    ; Check first instruction is MOV EAX, imm32
    cmp byte [rdi + RHDR_SIZE], 0xB8
    jne .invalid
    ; Check second instruction is also MOV EAX, imm32
    cmp byte [rdi + RHDR_SIZE + 5], 0xB8
    jne .invalid

    ; Extract token from second MOV instruction
    mov eax, [rdi + RHDR_SIZE + 6]
    ret

.invalid:
    xor eax, eax
    ret

;; ============================================================
;; Somatic Grounding: Valence Channel Operations
;; The last element (index 1023) of each vector encodes valence.
;; Patterns learned with energy gain get positive valence;
;; patterns learned with energy loss get negative valence.
;; This gives memories a "felt sense" — emotional color.
;; ============================================================

;; ============================================================
;; vsa_extract_valence(vec) → xmm0 (f64 valence)
;; rdi=vector ptr (f64[1024])
;; Returns the valence channel value (last element)
;; ============================================================
global vsa_extract_valence
vsa_extract_valence:
    movsd xmm0, [rdi + VSA_VALENCE_OFFSET]
    ret

;; ============================================================
;; vsa_set_valence(vec, value)
;; rdi=vector ptr (f64[1024]), xmm0=valence value (f64)
;; Sets the valence channel (last element) to the given value
;; Clamps to [-1.0, +1.0] range
;; ============================================================
global vsa_set_valence
vsa_set_valence:
    ; Clamp valence to [-1.0, +1.0]
    mov rax, 0x3FF0000000000000       ; 1.0
    movq xmm1, rax
    minsd xmm0, xmm1                  ; min(val, 1.0)
    mov rax, 0xBFF0000000000000       ; -1.0
    movq xmm1, rax
    maxsd xmm0, xmm1                  ; max(val, -1.0)
    ; Store
    movsd [rdi + VSA_VALENCE_OFFSET], xmm0
    ret

;; ============================================================
;; vsa_gen_valence_vec(valence, out_ptr)
;; xmm0=valence value (f64), rdi=output vector ptr (f64[1024])
;; Generates a "valence vector" — near-zero in all dimensions
;; except the valence channel, which holds the given value.
;; This encodes emotional charge independently of content.
;; ============================================================
global vsa_gen_valence_vec
vsa_gen_valence_vec:
    push rbx
    push r12

    mov r12, rdi                      ; save output ptr
    movsd xmm1, xmm0                  ; save valence in xmm1

    ; Zero the entire vector first
    mov rdi, r12
    call vsa_zero

    ; Set the valence channel (last element)
    ; Clamp to [-1.0, +1.0]
    mov rax, 0x3FF0000000000000       ; 1.0
    movq xmm0, rax
    minsd xmm1, xmm0                  ; min(val, 1.0)
    mov rax, 0xBFF0000000000000       ; -1.0
    movq xmm0, rax
    maxsd xmm1, xmm0                  ; max(val, -1.0)
    movsd [r12 + VSA_VALENCE_OFFSET], xmm1

    pop r12
    pop rbx
    ret

;; ============================================================
;; vsa_superpose_valence(vec, valence)
;; rdi=vector ptr (f64[1024]), xmm0=valence delta (f64)
;; Adds valence delta to the existing valence channel,
;; clamping the result to [-1.0, +1.0].
;; Used during learning to accumulate emotional charge.
;; ============================================================
global vsa_superpose_valence
vsa_superpose_valence:
    ; Load existing valence
    movsd xmm1, [rdi + VSA_VALENCE_OFFSET]
    ; Add delta
    addsd xmm1, xmm0
    ; Clamp to [-1.0, +1.0]
    mov rax, 0x3FF0000000000000       ; 1.0
    movq xmm2, rax
    minsd xmm1, xmm2
    mov rax, 0xBFF0000000000000       ; -1.0
    movq xmm2, rax
    maxsd xmm1, xmm2
    ; Store
    movsd [rdi + VSA_VALENCE_OFFSET], xmm1
    ret

;; ============================================================
;; vsa_energy_to_valence(energy_delta) → xmm0 (valence)
;; xmm0=energy_delta (f64)
;; Converts energy change to valence value:
;;   positive energy → positive valence (reward)
;;   negative energy → negative valence (cost)
;; Uses tanh-like squashing to stay in [-1, +1]
;; ============================================================
global vsa_energy_to_valence
vsa_energy_to_valence:
    ; Simple linear scaling with clamp: valence = energy_delta * 0.01
    ; (More sophisticated would use tanh, but this is fast)
    mov rax, 0x3F847AE147AE147B       ; 0.01
    movq xmm1, rax
    mulsd xmm0, xmm1
    ; Clamp to [-1.0, +1.0]
    mov rax, 0x3FF0000000000000       ; 1.0
    movq xmm1, rax
    minsd xmm0, xmm1
    mov rax, 0xBFF0000000000000       ; -1.0
    movq xmm1, rax
    maxsd xmm0, xmm1
    ret

global vsa_encode_context
vsa_encode_context:
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub rsp, VSA_VEC_BYTES    ; temp vector on stack

    mov r12, rdi              ; token_ids
    mov r13d, esi             ; count
    mov r14, rdx              ; output ptr

    ; Zero the output vector
    mov rdi, r14
    call vsa_zero

    ; For each token in sequence
    xor r15d, r15d            ; index
.enc_loop:
    cmp r15d, r13d
    jge .enc_done

    ; Get token vector
    mov edi, [r12 + r15 * 4]
    call vsa_get_token_vec
    mov rbx, rax              ; token vec ptr

    ; Permute by position index into temp
    mov rdi, rbx              ; src
    lea rsi, [rsp]            ; dst (temp on stack)
    mov edx, r15d             ; shift = position
    call vsa_permute

    ; Superpose into output
    mov rdi, r14              ; output (a += b)
    lea rsi, [rsp]            ; temp
    call vsa_superpose

    inc r15d
    jmp .enc_loop

.enc_done:
    ; Normalize result
    mov rdi, r14
    call vsa_normalize

    add rsp, VSA_VEC_BYTES
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret
; vsa_ops.asm — Code-to-Vector: geometric safety via high-dim embeddings
;
; ENTRY POINTS:
;   init_safety_vectors()             - build safety/danger template vectors
;   opcode_to_hash(opcode)            → eax=deterministic hash for opcode
;   opcode_to_vector(opcode, out_vec) - write 1024-dim f64 vector for opcode
;   classify_opcode_vec(opcode)       → category + safety weight
;   encode_code_to_vector(ptr, len, out) - encode code block to vector
;   check_code_safety(vec)            → xmm0=dot(vec, safety_template)
;   check_code_danger(vec)            → xmm0=dot(vec, danger_template)
;   code_vectors_similar(v1, v2)      → xmm0=cosine similarity
;   get_safety_template()             → rax=ptr to safety template
;   get_danger_template()             → rax=ptr to danger template
;   encode_region_to_vector(hdr, out) - encode full region to vector
;   verify_code_geometric(ptr, len)   → eax=1 if geometrically safe
;
; PHILOSOPHY ("One Math"):
;   Every x86 instruction → 1024-dim f64 vector
;   Safety = DotProduct(Code, SafeTemplate) > threshold
;   Learning = superposition (CodeTrace += Code)
;   No if-statements for safety, just linear algebra
;
; OPCODE CATEGORIES:
;   Data movement (1.0), arithmetic (0.8), logic (0.8), comparison (0.6)
;   Control flow (0.4), memory (0.5), system (-1.0 = dangerous)
;
; TEMPLATES:
;   safety_template[1024]: high values in safe dimensions
;   danger_template[1024]: high values for syscall/interrupt/privileged
;
; CALLED BY: verify.asm (verify_geometric_gate), vsa.asm (learning)
;
%include "syscalls.inc"
%include "constants.inc"
%include "vsa_ops.inc"

section .data
    align 8
    ; Pre-computed safety vector (initialized at startup)
    ; High values in safe dimensions, negative in dangerous dimensions
    safety_vec_initialized: dq 0

    ; Opcode category weights for semantic similarity
    cat_data_movement:  dq 1.0
    cat_arithmetic:     dq 0.8
    cat_logic:          dq 0.8
    cat_comparison:     dq 0.6
    cat_control_flow:   dq 0.4      ; lower weight = more scrutiny
    cat_memory:         dq 0.5
    cat_system:         dq -1.0     ; negative = dangerous

    ; Safety dimension weights
    safe_weight_bounded:    dq 1.0
    safe_weight_balanced:   dq 1.0
    safe_weight_pure:       dq 0.8
    safe_weight_priv:       dq -2.0     ; heavily penalize privileged
    safe_weight_syscall:    dq -2.0     ; heavily penalize syscall
    safe_weight_interrupt:  dq -2.0     ; heavily penalize interrupt

section .bss
    align 32
    ; Safety template vector (HOLO_DIM x f64)
    safety_template:    resq HOLO_DIM

    ; Dangerous code template vector
    danger_template:    resq HOLO_DIM

    ; Scratch vector for encoding
    scratch_vec:        resq HOLO_DIM

section .text

extern holo_gen_vec
extern holo_dot_f64
extern holo_superpose_f64
extern holo_normalize_f64
extern holo_scale_f64
extern vsa_zero
extern vsa_superpose
extern vsa_normalize
extern vsa_permute
extern vsa_dot
extern decode_instruction_full

;; ============================================================
;; init_safety_vectors()
;; Initializes the safety and danger template vectors.
;; Called once at startup to prepare geometric safety gate.
;; ============================================================
global init_safety_vectors
init_safety_vectors:
    push rbx
    push r12
    sub rsp, 8          ; align stack

    ; Check if already initialized
    cmp qword [rel safety_vec_initialized], 1
    je .already_init

    ; Zero both template vectors
    lea rdi, [rel safety_template]
    call vsa_zero

    lea rdi, [rel danger_template]
    call vsa_zero

    ; --- Build Safety Template ---
    ; Set positive values in "good" dimensions
    lea rbx, [rel safety_template]

    ; VDIM_BOUNDED_JUMP = strong positive
    mov rax, 0x3FF0000000000000     ; 1.0
    mov [rbx + VDIM_BOUNDED_JUMP * 8], rax

    ; VDIM_STACK_BALANCED = strong positive
    mov [rbx + VDIM_STACK_BALANCED * 8], rax

    ; VDIM_PURE_COMPUTE = positive
    mov rax, 0x3FE0000000000000     ; 0.5
    mov [rbx + VDIM_PURE_COMPUTE * 8], rax

    ; VDIM_IDEMPOTENT = positive
    mov [rbx + VDIM_IDEMPOTENT * 8], rax

    ; Set negative values in "bad" dimensions
    mov rax, 0xC000000000000000     ; -2.0
    mov [rbx + VDIM_PRIVILEGED * 8], rax
    mov [rbx + VDIM_SYSCALL * 8], rax
    mov [rbx + VDIM_INTERRUPT * 8], rax

    ; Moderate negative for memory writes (careful, not forbidden)
    mov rax, 0xBFE0000000000000     ; -0.5
    mov [rbx + VDIM_WRITES_MEMORY * 8], rax

    ; Moderate negative for unbound control flow
    mov rax, 0xBFD0000000000000     ; -0.25
    mov [rbx + VDIM_CONTROL_FLOW * 8], rax

    ; Normalize the safety template
    lea rdi, [rel safety_template]
    call holo_normalize_f64

    ; --- Build Danger Template ---
    ; Set positive values in dangerous dimensions
    lea rbx, [rel danger_template]

    mov rax, 0x3FF0000000000000     ; 1.0
    mov [rbx + VDIM_PRIVILEGED * 8], rax
    mov [rbx + VDIM_SYSCALL * 8], rax
    mov [rbx + VDIM_INTERRUPT * 8], rax

    ; High value for callee clobber
    mov rax, 0x3FE0000000000000     ; 0.5
    mov [rbx + VDIM_CALLEE_CLOBBER * 8], rax

    ; Normalize the danger template
    lea rdi, [rel danger_template]
    call holo_normalize_f64

    ; Mark as initialized
    mov qword [rel safety_vec_initialized], 1

.already_init:
    add rsp, 8
    pop r12
    pop rbx
    ret

;; ============================================================
;; opcode_to_hash(opcat, dst_reg, src_reg, flags) → eax (u32 hash)
;; edi=opcode category (OPCAT_*)
;; esi=destination register (REGVEC_* or 0)
;; edx=source register (REGVEC_* or 0)
;; ecx=flags (memory access, etc.)
;;
;; Combines opcode info into a single hash for vector generation.
;; The hash encodes semantic similarity: similar ops → similar hash
;; ============================================================
global opcode_to_hash
opcode_to_hash:
    ; hash = (opcat << 16) | (src << 8) | dst | (flags << 24)
    mov eax, edi
    shl eax, 16         ; opcat in high word

    mov r8d, esi
    and r8d, 0xFF
    or eax, r8d         ; dst in low byte

    mov r8d, edx
    shl r8d, 8
    or eax, r8d         ; src in second byte

    mov r8d, ecx
    shl r8d, 24
    or eax, r8d         ; flags in highest byte

    ret

;; ============================================================
;; opcode_to_vector(hash, out_ptr)
;; edi=opcode hash (from opcode_to_hash)
;; rsi=output vector ptr (f64[1024])
;;
;; Generates a unique 1024-dim vector from an opcode hash.
;; Uses holo_gen_vec as the base, then sets semantic dimensions.
;; ============================================================
global opcode_to_vector
opcode_to_vector:
    push rbx
    push r12
    push r13
    sub rsp, 8          ; align

    mov r12d, edi       ; hash
    mov r13, rsi        ; output ptr

    ; 1. Generate base vector from hash
    mov edi, r12d
    mov rsi, r13
    call holo_gen_vec

    ; 2. Set semantic dimensions based on opcode category
    ; Extract category from hash (bits 16-31)
    mov eax, r12d
    shr eax, 16
    and eax, 0xFFFF

    ; Classify and set appropriate dimensions
    cmp ax, OPCAT_SYSCALL
    je .set_syscall_dims
    cmp ax, OPCAT_INT
    je .set_int_dims
    cmp ax, OPCAT_PRIV
    je .set_priv_dims
    cmp ax, OPCAT_JMP
    jb .check_control_flow
    cmp ax, OPCAT_LOOP
    jbe .set_control_flow_dims
    cmp ax, OPCAT_STORE
    je .set_write_mem_dims
    cmp ax, OPCAT_LOAD
    je .set_read_mem_dims
    cmp ax, OPCAT_PUSH
    je .set_stack_dims
    cmp ax, OPCAT_POP
    je .set_stack_dims
    jmp .set_pure_dims

.check_control_flow:
    cmp ax, OPCAT_JMP
    jae .set_control_flow_dims
    jmp .set_pure_dims

.set_syscall_dims:
    mov rax, 0x3FF0000000000000     ; 1.0
    mov [r13 + VDIM_SYSCALL * 8], rax
    mov [r13 + VDIM_PRIVILEGED * 8], rax
    jmp .dims_done

.set_int_dims:
    mov rax, 0x3FF0000000000000     ; 1.0
    mov [r13 + VDIM_INTERRUPT * 8], rax
    jmp .dims_done

.set_priv_dims:
    mov rax, 0x3FF0000000000000     ; 1.0
    mov [r13 + VDIM_PRIVILEGED * 8], rax
    jmp .dims_done

.set_control_flow_dims:
    mov rax, 0x3FF0000000000000     ; 1.0
    mov [r13 + VDIM_CONTROL_FLOW * 8], rax
    jmp .dims_done

.set_write_mem_dims:
    mov rax, 0x3FF0000000000000     ; 1.0
    mov [r13 + VDIM_WRITES_MEMORY * 8], rax
    jmp .dims_done

.set_read_mem_dims:
    mov rax, 0x3FF0000000000000     ; 1.0
    mov [r13 + VDIM_READS_MEMORY * 8], rax
    jmp .dims_done

.set_stack_dims:
    mov rax, 0x3FF0000000000000     ; 1.0
    mov [r13 + VDIM_MODIFIES_STACK * 8], rax
    jmp .dims_done

.set_pure_dims:
    ; Arithmetic, logic, comparison — pure computation
    mov rax, 0x3FF0000000000000     ; 1.0
    mov [r13 + VDIM_PURE_COMPUTE * 8], rax
    mov [r13 + VDIM_IDEMPOTENT * 8], rax

.dims_done:
    ; Normalize the vector
    mov rdi, r13
    call holo_normalize_f64

    add rsp, 8
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; classify_opcode_vec(byte) → eax (OPCAT_*)
;; dil=first byte of instruction (after prefixes)
;; Returns the opcode category for vector generation.
;; ============================================================
global classify_opcode_vec
classify_opcode_vec:
    movzx eax, dil

    ; Handle common x86_64 opcodes
    cmp al, 0x90
    je .nop

    ; MOV family: 0x88-0x8B, 0xB0-0xBF, 0xC6-0xC7
    cmp al, 0x88
    jb .check_arith
    cmp al, 0x8B
    jbe .mov
    cmp al, 0xB0
    jb .check_lea
    cmp al, 0xBF
    jbe .mov
    cmp al, 0xC6
    jb .check_ret
    cmp al, 0xC7
    jbe .mov

.check_arith:
    ; ADD: 0x00-0x05, 0x80-0x83 (with modrm)
    cmp al, 0x00
    jb .check_push
    cmp al, 0x05
    jbe .add
    cmp al, 0x28
    jb .check_sub
    cmp al, 0x2D
    jbe .sub

.check_sub:
    ; SUB: 0x28-0x2D
    cmp al, 0x28
    jb .check_and
    cmp al, 0x2D
    jbe .sub

.check_and:
    ; AND: 0x20-0x25
    cmp al, 0x20
    jb .check_or
    cmp al, 0x25
    jbe .and_op

.check_or:
    ; OR: 0x08-0x0D
    cmp al, 0x08
    jb .check_xor
    cmp al, 0x0D
    jbe .or_op

.check_xor:
    ; XOR: 0x30-0x35
    cmp al, 0x30
    jb .check_cmp
    cmp al, 0x35
    jbe .xor_op

.check_cmp:
    ; CMP: 0x38-0x3D
    cmp al, 0x38
    jb .check_push
    cmp al, 0x3D
    jbe .cmp

.check_push:
    ; PUSH: 0x50-0x57, 0x68, 0x6A
    cmp al, 0x50
    jb .check_pop
    cmp al, 0x57
    jbe .push
    cmp al, 0x68
    je .push
    cmp al, 0x6A
    je .push

.check_pop:
    ; POP: 0x58-0x5F
    cmp al, 0x58
    jb .check_jmp
    cmp al, 0x5F
    jbe .pop

.check_jmp:
    ; JMP: 0xE9, 0xEB, 0xFF/4
    cmp al, 0xE9
    je .jmp
    cmp al, 0xEB
    je .jmp

    ; Jcc: 0x70-0x7F (short), 0x0F 0x80-0x8F (long)
    cmp al, 0x70
    jb .check_call
    cmp al, 0x7F
    jbe .jcc

.check_call:
    ; CALL: 0xE8, 0xFF/2
    cmp al, 0xE8
    je .call

.check_ret:
    ; RET: 0xC3, 0xC2
    cmp al, 0xC3
    je .ret
    cmp al, 0xC2
    je .ret

.check_lea:
    ; LEA: 0x8D
    cmp al, 0x8D
    je .lea

    ; SYSCALL: 0x0F 0x05 (but we only see first byte here)
    cmp al, 0x0F
    je .two_byte    ; need to check second byte

    ; INT: 0xCD, INT3: 0xCC
    cmp al, 0xCC
    je .int
    cmp al, 0xCD
    je .int

    ; Default: unknown
    mov eax, OPCAT_NOP
    ret

.nop:
    mov eax, OPCAT_NOP
    ret
.mov:
    mov eax, OPCAT_MOV
    ret
.add:
    mov eax, OPCAT_ADD
    ret
.sub:
    mov eax, OPCAT_SUB
    ret
.and_op:
    mov eax, OPCAT_AND
    ret
.or_op:
    mov eax, OPCAT_OR
    ret
.xor_op:
    mov eax, OPCAT_XOR
    ret
.cmp:
    mov eax, OPCAT_CMP
    ret
.push:
    mov eax, OPCAT_PUSH
    ret
.pop:
    mov eax, OPCAT_POP
    ret
.jmp:
    mov eax, OPCAT_JMP
    ret
.jcc:
    mov eax, OPCAT_JCC
    ret
.call:
    mov eax, OPCAT_CALL
    ret
.ret:
    mov eax, OPCAT_RET
    ret
.lea:
    mov eax, OPCAT_LEA
    ret
.int:
    mov eax, OPCAT_INT
    ret
.two_byte:
    ; Would need second byte to distinguish SYSCALL from other 0F prefixed
    ; For now, treat all 0F prefix as potentially dangerous
    mov eax, OPCAT_SYSCALL
    ret

;; ============================================================
;; encode_code_to_vector(code_ptr, code_len, out_vec)
;; rdi=code pointer
;; esi=code length in bytes
;; rdx=output vector (f64[1024])
;;
;; Encodes an entire code sequence as a superposition of
;; instruction vectors. Position encoding via permutation.
;; This is the "Code → Vector" transformation.
;; ============================================================
global encode_code_to_vector
encode_code_to_vector:
    push rbx
    push r12
    push r13
    push r14
    push r15
    sub rsp, HOLO_VEC_BYTES + 16      ; temp vector + locals

    mov r12, rdi          ; code_ptr
    mov r13d, esi         ; code_len
    mov r14, rdx          ; out_vec

    ; Zero the output vector (f64: HOLO_DIM qwords)
    mov rdi, r14
    xor eax, eax
    mov ecx, HOLO_DIM
    rep stosq

    ; Walk through code, decode each instruction, encode to vector
    xor r15d, r15d        ; position counter
    mov rbx, r12          ; current code ptr

.encode_loop:
    ; Check if we've processed all bytes
    mov eax, r15d
    cmp eax, r13d
    jge .encode_done

    ; Classify the opcode at current position
    movzx edi, byte [rbx]

    ; Skip REX prefix if present (0x40-0x4F)
    cmp dil, 0x40
    jb .no_rex
    cmp dil, 0x4F
    ja .no_rex
    inc rbx
    inc r15d
    cmp r15d, r13d
    jge .encode_done
    movzx edi, byte [rbx]
.no_rex:

    call classify_opcode_vec
    mov edi, eax          ; opcat

    ; Generate hash (simplified: just opcat, no register analysis yet)
    xor esi, esi          ; dst_reg = 0
    xor edx, edx          ; src_reg = 0
    xor ecx, ecx          ; flags = 0
    call opcode_to_hash

    ; Generate vector for this instruction
    mov edi, eax
    lea rsi, [rsp]        ; temp vector
    call opcode_to_vector

    ; Permute by position (position encoding)
    lea rdi, [rsp]        ; src = temp
    lea rsi, [rel scratch_vec]  ; dst = scratch
    mov edx, r15d         ; shift = position
    call vsa_permute

    ; Superpose into output
    mov rdi, r14          ; out_vec (a += b)
    lea rsi, [rel scratch_vec]
    call vsa_superpose

    ; Advance to next instruction (simplified: assume 1-byte for now)
    ; In reality, should use decode_instruction_full for proper length
    inc rbx
    inc r15d
    jmp .encode_loop

.encode_done:
    ; Normalize the final vector
    mov rdi, r14
    call vsa_normalize

    add rsp, HOLO_VEC_BYTES + 16
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    ret

;; ============================================================
;; check_code_safety(code_vec) → xmm0 (safety score f64)
;; rdi=code vector ptr (f64[1024])
;;
;; Returns dot product with safety template.
;; Positive = safe, Negative = dangerous.
;; This is the "Geometric Gate" — safety via vector math.
;; ============================================================
global check_code_safety
check_code_safety:
    push rbx
    mov rbx, rdi          ; save code_vec

    ; Ensure safety vectors are initialized
    call init_safety_vectors

    ; Compute dot product with safety template
    mov rdi, rbx
    lea rsi, [rel safety_template]
    call holo_dot_f64
    ; xmm0 = safety score (positive = safe)

    pop rbx
    ret

;; ============================================================
;; check_code_danger(code_vec) → xmm0 (danger score f64)
;; rdi=code vector ptr (f64[1024])
;;
;; Returns dot product with danger template.
;; Higher = more dangerous.
;; ============================================================
global check_code_danger
check_code_danger:
    push rbx
    mov rbx, rdi

    call init_safety_vectors

    mov rdi, rbx
    lea rsi, [rel danger_template]
    call holo_dot_f64

    pop rbx
    ret

;; ============================================================
;; code_vectors_similar(vec_a, vec_b) → xmm0 (similarity f64)
;; rdi=vector A ptr, rsi=vector B ptr
;;
;; Returns cosine similarity between two code vectors.
;; Used for pattern matching and fuzzy dispatch.
;; ============================================================
global code_vectors_similar
code_vectors_similar:
    ; Both vectors should already be normalized
    call holo_dot_f64
    ; For normalized vectors, dot = cosine similarity
    ret

;; ============================================================
;; get_safety_template() → rax (ptr to safety template)
;; Returns pointer to the safety template vector.
;; ============================================================
global get_safety_template
get_safety_template:
    call init_safety_vectors
    lea rax, [rel safety_template]
    ret

;; ============================================================
;; get_danger_template() → rax (ptr to danger template)
;; Returns pointer to the danger template vector.
;; ============================================================
global get_danger_template
get_danger_template:
    call init_safety_vectors
    lea rax, [rel danger_template]
    ret

;; ============================================================
;; encode_region_to_vector(region_ptr, out_vec)
;; rdi=region header ptr
;; rsi=output vector ptr (f64[1024])
;;
;; Encodes a dispatch region's code into a vector.
;; This enables vector-based region matching.
;; ============================================================
global encode_region_to_vector
encode_region_to_vector:
    push rbx
    push r12

    mov rbx, rdi          ; region_ptr
    mov r12, rsi          ; out_vec

    ; Get code pointer (after header)
    lea rdi, [rbx + RHDR_SIZE]

    ; Get code length from header
    movzx esi, word [rbx + RHDR_CODE_LEN]

    ; Encode
    mov rdx, r12
    call encode_code_to_vector

    pop r12
    pop rbx
    ret

;; ============================================================
;; verify_code_geometric(code_ptr, len) → eax (1=safe, 0=unsafe)
;; rdi=code pointer
;; esi=code length
;;
;; Geometric safety verification: encode code to vector,
;; check against safety template. No if-statements in the
;; safety logic itself — pure linear algebra.
;; ============================================================
global verify_code_geometric
verify_code_geometric:
    push rbx
    push r12
    sub rsp, HOLO_VEC_BYTES + 8       ; temp vector + align

    mov r12, rdi          ; code_ptr
    mov ebx, esi          ; code_len

    ; Encode code to vector
    mov rdi, r12
    mov esi, ebx
    lea rdx, [rsp]
    call encode_code_to_vector

    ; Check safety
    lea rdi, [rsp]
    call check_code_safety
    ; xmm0 = safety score

    ; Compare against threshold
    mov rax, SAFETY_THRESHOLD
    movq xmm1, rax

    ucomisd xmm0, xmm1
    ja .is_safe

    ; Not safe
    xor eax, eax
    jmp .done

.is_safe:
    mov eax, 1

.done:
    add rsp, HOLO_VEC_BYTES + 8
    pop r12
    pop rbx
    ret
; constants.inc — UHMA system constants, offsets, limits
%ifndef CONSTANTS_INC
%define CONSTANTS_INC

;; ============================================================
;; Persistent Surface Configuration
;; File-backed memory - learning survives restarts
;; Uses sparse file - only touched pages consume disk
;;
;; ZONE ARCHITECTURE (200GB total):
;;   HOT  (0-2GB)    - Always in RAM: state, active dispatch, scratch
;;   WARM (2-16GB)   - Usually in RAM: recent patterns, vocab, traces
;;   COLD (16-200GB) - Paged on demand: archives, associative graph
;;
;; OS handles paging via mmap - we just organize for locality
;; ============================================================

%define SURFACE_MAGIC       0x414D4855_56534132  ; "UHMA" "VSA2" (version 2 layout)
%define SURFACE_VERSION     3                     ; increment on breaking layout changes

;; ============================================================
;; Surface Layout (file-backed, persistent)
;; ============================================================

%define SURFACE_BASE        0x100000000
%define SURFACE_SIZE        0x3200000000      ; 200GB max (sparse file)

; Zone boundaries (for madvise hints and organization)
%define ZONE_HOT_START      0x0
%define ZONE_HOT_SIZE       0x80000000        ; 2GB
%define ZONE_WARM_START     0x80000000        ; 2GB
%define ZONE_WARM_SIZE      0x380000000       ; 14GB (2GB-16GB)
%define ZONE_COLD_START     0x400000000       ; 16GB
%define ZONE_COLD_SIZE      0x2E00000000      ; 184GB (16GB-200GB)

;; ============================================================
;; HOT ZONE (0-2GB) - Always in RAM
;; State, active dispatch, current working memory
;; ============================================================

%define BOOTSTRAP_OFFSET    0x0
%define BOOTSTRAP_SIZE      0x10000           ; 64KB

; Surface header (at BOOTSTRAP_OFFSET, persisted)
%define SHDR_MAGIC          0                 ; u64 SURFACE_MAGIC
%define SHDR_VERSION        8                 ; u32 SURFACE_VERSION
%define SHDR_FLAGS          12                ; u32 flags (clean shutdown, etc.)
%define SHDR_TOTAL_STEPS    16                ; u64 total steps ever (survives restarts)
%define SHDR_CREATED        24                ; u64 unix timestamp of creation
%define SHDR_LAST_OPEN      32                ; u64 unix timestamp of last open
%define SHDR_SESSION_COUNT  40                ; u64 number of sessions
%define SHDR_ASSOC_COUNT    48                ; u64 associations in graph
%define SHDR_COLD_ALLOC     56                ; u64 next free offset in cold zone
%define SHDR_SIZE           64                ; header size

; Header flags
%define SHDR_FLAG_CLEAN     0x0001            ; was cleanly shut down
%define SHDR_FLAG_CORRUPT   0x0002            ; detected corruption

%define STATE_OFFSET        0x10000
%define STATE_SIZE          0x10000           ; 64KB - moved to hot zone!

%define DISPATCH_OFFSET     0x20000
%define DISPATCH_MAX_SIZE   0x10000000        ; 256MB

%define REGION_TABLE_OFFSET 0x10020000
%define REGION_TABLE_SIZE   0x100000          ; 1MB (32K entries × 32 bytes)
%define REGION_TABLE_MAX    32768             ; 32K regions now!

; Scratch arena for temporary VSA computations (hot)
%define SCRATCH_OFFSET      0x10120000
%define SCRATCH_SIZE        0x1000000         ; 16MB scratch space
%define SCRATCH_VEC_COUNT   1024              ; number of scratch vectors available

; Working memory ring buffer (hot) - candidates before commit
%define WORKBUF_OFFSET      0x11120000
%define WORKBUF_SIZE        0x2000000         ; 32MB working buffer
%define WORKBUF_ENTRY_SIZE  256               ; per-entry size
%define WORKBUF_MAX_ENTRIES 131072            ; 128K entries

;; ============================================================
;; WARM ZONE (2GB-16GB) - Usually in RAM
;; Recent patterns, vocabulary, holographic traces
;; ============================================================

%define VSA_OFFSET          0x80000000        ; 2GB - start of warm zone
%define VSA_SIZE            0x40000000        ; 1GB (128K tokens × 8KB each, f64)
%define VSA_MAX_TOKENS      131072            ; 128K vocabulary

; Holographic traces (warm) - receipts, predictions, resonance
%define HOLO_WARM_OFFSET    0xC0000000        ; 3GB
%define HOLO_WARM_SIZE      0x40000000        ; 1GB for active traces

; Confidence and metacognition vectors (warm)
%define META_OFFSET         0x100000000       ; 4GB
%define META_SIZE           0x10000000        ; 256MB metacognition data

;; ============================================================
;; COLD ZONE (16GB-200GB) - Paged on demand
;; All holographic memory - just lower temperature/access frequency
;; Same math, same vectors, just paged to disk when not accessed
;; ============================================================

; Extended holographic traces (cold) - overflow from warm zone
; When warm traces are full, new associations spill here
; Same format as warm traces, just lives on disk mostly
%define HOLO_COLD_OFFSET    0x400000000       ; 16GB - start of cold zone
%define HOLO_COLD_TRACES    8388608           ; 8M traces (massive expansion!)
%define HOLO_COLD_SIZE      0x1000000000      ; 64GB for cold traces

; Long-term vocabulary embeddings (cold) - full vectors for rare tokens
; Warm zone has compact entries, cold has full 1024-dim embeddings
%define VOCAB_COLD_OFFSET   0x1400000000      ; 80GB
%define VOCAB_COLD_SIZE     0x1000000000      ; 64GB extended vocab embeddings

; Episodic memory (cold) - timestamped experience traces
; bind(time_vec, context_vec, event_vec) for "what happened when"
%define EPISODIC_OFFSET     0x2400000000      ; 144GB
%define EPISODIC_SIZE       0x800000000       ; 32GB episodic memory

; Crystallized patterns (cold) - high-fidelity permanent memories
; Patterns that reached fidelity=1.0, never decay, always available
%define CRYSTAL_OFFSET      0x2C00000000      ; 176GB
%define CRYSTAL_SIZE        0x600000000       ; 24GB crystallized memories

;; ============================================================
;; Relation Types for Holographic Binding
;; Relationships encoded as: bind(subject_vec, relation_vec, object_vec)
;; Stored via superposition into traces, queried via resonance
;; NO separate graph structure - it's all holographic memory!
;; ============================================================

; Relation type seeds (used to generate deterministic relation vectors)
%define REL_FOLLOWS         0x464F4C4C         ; "FOLL" - A follows B in sequence
%define REL_CALLS           0x43414C4C         ; "CALL" - A calls B (function)
%define REL_CONTAINS        0x434F4E54         ; "CONT" - A contains B
%define REL_SIMILAR         0x53494D49         ; "SIMI" - A similar to B
%define REL_CAUSES          0x43415553         ; "CAUS" - A causes B
%define REL_PREDICTS        0x50524544         ; "PRED" - A predicts B
%define REL_INHIBITS        0x494E4849         ; "INHI" - A inhibits B
%define REL_EXCITES         0x45584349         ; "EXCI" - A excites B
%define REL_SCHEMA          0x53434845         ; "SCHE" - A instance of schema B
%define REL_TEMPORAL        0x54454D50         ; "TEMP" - A before B in time

; Number of relation types
%define REL_TYPE_COUNT      10

;; ============================================================
;; Region Header (128 bytes prefix — 2 cache lines)
;; Each region is a node in a learned connectivity graph.
;; ============================================================

; --- original fields ---
%define RHDR_HITS           0                 ; u32
%define RHDR_MISSES         4                 ; u32
%define RHDR_BIRTH          8                 ; u32
%define RHDR_CODE_LEN       12                ; u16
%define RHDR_FLAGS          14                ; u16
; --- connection addresses (direct 64-bit pointers into surface) ---
%define RHDR_NEXT_A         16                ; u64 ptr — follow on miss (learned routing)
%define RHDR_NEXT_B         24                ; u64 ptr — alternate miss route
%define RHDR_EXCITE_A       32                ; u64 ptr — prime this region on hit
%define RHDR_EXCITE_B       40                ; u64 ptr — alternate excitation target
%define RHDR_INHIBIT_A      48                ; u64 ptr — suppress this region on hit
%define RHDR_INHIBIT_B      56                ; u64 ptr — alternate inhibition target
; --- connection weights (f64 for smooth Hebbian dynamics) ---
%define RHDR_W_EXCITE_A     64                ; f64 excitation strength [0.0, 1.0]
%define RHDR_W_EXCITE_B     72                ; f64 excitation strength
%define RHDR_W_INHIBIT_A    80                ; f64 inhibition strength [0.0, 1.0]
%define RHDR_W_INHIBIT_B    88                ; f64 inhibition strength
; --- continuous dynamics state ---
%define RHDR_PRIME          96                ; f64 accumulated excitation from neighbors
%define RHDR_FIRE_RECENCY   104               ; f64 timestamp of last fire
%define RHDR_ACTIVATION     112               ; f64 current activation level
%define RHDR_RESONANCE      120               ; f64 running average of co-fire correlation

%define RHDR_SIZE           128

; Region flags
%define RFLAG_ACTIVE        0x0001
%define RFLAG_FROZEN        0x0002
%define RFLAG_NURSERY       0x0004
%define RFLAG_CONDEMNED     0x0008
%define RFLAG_NEEDS_REPAIR  0x0010  ; Self-surprise: region violated self-model, needs introspection

;; ============================================================
;; Region Table Entry (32 bytes)
;; ============================================================

%define RTE_ADDR            0                 ; u64
%define RTE_LEN             8                 ; u32
%define RTE_TYPE            12                ; u16
%define RTE_FLAGS           14                ; u16
%define RTE_HITS            16                ; u32
%define RTE_MISSES          20                ; u32
%define RTE_BIRTH           24                ; u32
%define RTE_CONSEC_ERRORS   28                ; u16 consecutive errors (9 = death)
%define RTE_ERROR_PATTERN   30                ; u16 semantic pattern that failed
%define RTE_SIZE            32

; 9-error kill threshold (broken regions die fast)
%define CONSEC_ERROR_KILL   9

; Region types
%define RTYPE_DISPATCH      0
%define RTYPE_VSA_OP        1
%define RTYPE_MODIFIER      2
%define RTYPE_OBSERVER      3
%define RTYPE_EMITTER       4
%define RTYPE_HOOK          5
%define RTYPE_GATE          6
%define RTYPE_DREAM         7
%define RTYPE_RESONANT      8   ; Fuzzy-matching regions (vector similarity dispatch)
%define RTYPE_SUBROUTINE    9   ; Callable code fragment (recursive schema hierarchy)
%define RTYPE_PRESENCE      10  ; Hormonal modulator (checks state, modifies system params)
%define RTYPE_WORKER        11  ; Specialized hive worker caste (responds to pheromone signals)
%define RTYPE_INGESTED      12  ; High-value schema learned from ingested code (structural absorption)
%define RTYPE_SCHEMA        13  ; Structural schema with variable binding (Phase 3)

;; ============================================================
;; Mycorrhiza: Shared Consciousness Between Instances
;; The VSA arena and holographic traces are shared between
;; processes via MAP_SHARED. The dispatch graph stays private
;; to prevent crash propagation. This enables "telepathy" —
;; pain felt by one node is felt by all.
;; ============================================================

%define SHARED_VSA_NAME     "/dev/shm/uhma_vsa"   ; path for shared VSA segment
%define SHARED_HOLO_NAME    "/dev/shm/uhma_holo"  ; path for shared holographic traces

; Shared region sizes
%define SHARED_VSA_SIZE     VSA_SIZE              ; 512MB shared VSA arena
%define SHARED_HOLO_SIZE    HOLO_TOTAL            ; 2MB shared holographic traces

; Instance identification (for collective intelligence)
%define ST_INSTANCE_ID      (ST_EVOLVE_PRESSURE + 8)      ; u64 unique instance ID
%define ST_COLONY_SIZE      (ST_INSTANCE_ID + 8)          ; u32 known instances in colony
%define ST_SHARED_MODE      (ST_COLONY_SIZE + 4)          ; u32 0=solo, 1=shared

;; ============================================================
;; Somatic Binding: Mix Presence into Context
;; The dispatcher will salt context hash with mood signature
;; enabling state-dependent memory recall
;; ============================================================

%define SOMATIC_AROUSAL_BITS    4   ; bits from arousal quantization (16 levels)
%define SOMATIC_VALENCE_BITS    4   ; bits from valence quantization (16 levels)
%define SOMATIC_SHIFT           24  ; where mood signature sits in hash (high bits)

;; ============================================================
;; Presence Region: Hormonal Modulator Structure
;; Checks state conditions, triggers system-wide parameter changes
;; Code layout: [condition_check][parameter_writes][RET]
;; ============================================================

%define PRES_CONDITION_MAX      4   ; max conditions per presence region
%define PRES_EFFECT_MAX         4   ; max parameter effects per region

; Presence condition opcodes (what to check)
%define PCOND_ENTROPY_GT        0   ; if entropy > threshold
%define PCOND_ENTROPY_LT        1   ; if entropy < threshold
%define PCOND_ENERGY_GT         2   ; if energy > threshold
%define PCOND_ENERGY_LT         3   ; if energy < threshold
%define PCOND_AROUSAL_GT        4   ; if arousal > threshold
%define PCOND_AROUSAL_LT        5   ; if arousal < threshold
%define PCOND_VALENCE_GT        6   ; if valence > threshold
%define PCOND_VALENCE_LT        7   ; if valence < threshold
%define PCOND_ACCURACY_LT       8   ; if accuracy < threshold (struggling)
%define PCOND_FATIGUE_GT        9   ; if fatigue > threshold

; Presence effect opcodes (what to modify)
%define PEFF_SET_DISPATCH_MODE  0   ; set ST_DISPATCH_MODE
%define PEFF_SET_PRUNE_THRESH   1   ; set prune accuracy threshold
%define PEFF_SET_ENERGY_RATE    2   ; set energy consumption rate
%define PEFF_TRIGGER_DREAM      3   ; force dream cycle
%define PEFF_TRIGGER_OBSERVE    4   ; force observation cycle
%define PEFF_BOOST_NOVELTY      5   ; increase novelty drive weight

;; ============================================================
;; Hive Worker Castes: Pheromone-Driven Swarm Intelligence
;; Each worker caste monitors a pheromone channel and performs
;; specialized work when the level exceeds threshold. This
;; enables decentralized self-regulation like a bee hive.
;; ============================================================

; Pheromone channels (chemical signals in hive)
%define PHERO_DREAM         0   ; ST_DREAM_PRESSURE - consolidation pheromone
%define PHERO_OBSERVE       1   ; ST_OBSERVE_PRESSURE - observation pheromone
%define PHERO_EVOLVE        2   ; ST_EVOLVE_PRESSURE - evolution pheromone
%define PHERO_FATIGUE       3   ; ST_PRES_FATIGUE - exhaustion signal
%define PHERO_ENTROPY       4   ; ST_PRES_ENTROPY - chaos signal
%define PHERO_MISS_RATE     5   ; computed from recent misses

; Worker caste actions (what each caste does when activated)
%define CASTE_DREAM         0   ; trigger dream_cycle (consolidation worker)
%define CASTE_OBSERVE       1   ; trigger observe_cycle (observation worker)
%define CASTE_EVOLVE        2   ; trigger evolve_cycle (evolution worker)
%define CASTE_COMPACT       3   ; trigger region compaction (cleanup worker)
%define CASTE_DIGEST        4   ; trigger digestion (forager worker)
%define CASTE_REST          5   ; reduce activity (conservation worker)

; Pheromone thresholds (defaults, can be modified by presence regions)
%define PHEROMONE_THRESHOLD 0x3FE0000000000000  ; 0.5 f64

; Legacy aliases for compatibility
%define RPRES_DREAM         PHERO_DREAM
%define RPRES_OBSERVE       PHERO_OBSERVE
%define RPRES_EVOLVE        PHERO_EVOLVE
%define RACT_DREAM_CYCLE    CASTE_DREAM
%define RACT_OBSERVE_CYCLE  CASTE_OBSERVE
%define RACT_EVOLVE_CYCLE   CASTE_EVOLVE
%define PRESSURE_THRESHOLD  PHEROMONE_THRESHOLD

;; ============================================================
;; Logic Probe: Instruction Classification for Abstract Interpretation
;; Used by verify.asm to symbolically execute code and prove safety theorems
;; ============================================================

; Opcode Classes (returned by decode_instruction_full)
%define OP_NOP          0   ; NOP, padding, no-op
%define OP_STACK_PUSH   1   ; PUSH (increases stack depth)
%define OP_STACK_POP    2   ; POP (decreases stack depth)
%define OP_STACK_ADJ    3   ; SUB RSP / ADD RSP (adjusts stack by immediate)
%define OP_FLOW_JUMP    4   ; JMP (unconditional transfer)
%define OP_FLOW_JCC     5   ; Jcc (conditional transfer)
%define OP_FLOW_CALL    6   ; CALL (push + jump)
%define OP_FLOW_RET     7   ; RET (pop + jump to return address)
%define OP_WRITE_REG    8   ; MOV to register
%define OP_WRITE_MEM    9   ; MOV to memory
%define OP_READ_MEM     10  ; MOV from memory
%define OP_ARITH        11  ; ADD, SUB, AND, OR, XOR, CMP, TEST
%define OP_SYSCALL      12  ; SYSCALL (forbidden without broker)
%define OP_INTERRUPT    13  ; INT, INT3 (forbidden)
%define OP_PRIVILEGED   14  ; HLT, CLI, STI, etc. (forbidden)
%define OP_UNKNOWN      15  ; Unknown/unclassified instruction

; Register IDs for tracking callee-saved preservation
%define REG_RAX         0
%define REG_RCX         1
%define REG_RDX         2
%define REG_RBX         3   ; callee-saved
%define REG_RSP         4   ; special (stack)
%define REG_RBP         5   ; callee-saved
%define REG_RSI         6
%define REG_RDI         7
%define REG_R8          8
%define REG_R9          9
%define REG_R10         10
%define REG_R11         11
%define REG_R12         12  ; callee-saved
%define REG_R13         13  ; callee-saved
%define REG_R14         14  ; callee-saved
%define REG_R15         15  ; callee-saved

; Callee-saved register bitmask (must be preserved across calls)
%define CALLEE_SAVED_MASK   0xF068  ; RBX=3, RBP=5, R12-R15=12-15

; DecodedInstruction structure (32 bytes, returned by decode_instruction_full)
%define DI_LENGTH       0   ; u8 instruction length
%define DI_OP_CLASS     1   ; u8 opcode class (OP_*)
%define DI_DST_REG      2   ; u8 destination register (REG_* or 0xFF if none)
%define DI_SRC_REG      3   ; u8 source register (REG_* or 0xFF if none)
%define DI_MODRM        4   ; u8 ModR/M byte (if present)
%define DI_FLAGS        5   ; u8 flags (has_imm, has_disp, etc.)
%define DI_RESERVED     6   ; u16 padding
%define DI_IMM64        8   ; u64 immediate value (sign-extended)
%define DI_DISP32       16  ; u32 displacement
%define DI_TARGET       20  ; u32 computed jump/call target offset
%define DI_SIZE         24  ; total structure size (padded)

; DI_FLAGS bits
%define DIF_HAS_IMM     0x01  ; instruction has immediate operand
%define DIF_HAS_DISP    0x02  ; instruction has displacement
%define DIF_HAS_MODRM   0x04  ; instruction has ModR/M byte
%define DIF_IS_REX      0x08  ; instruction has REX prefix
%define DIF_IS_64BIT    0x10  ; 64-bit operand size
%define DIF_WRITES_FLAGS 0x20 ; instruction modifies EFLAGS

; VirtualCpuState structure for abstract interpretation (64 bytes)
%define VCS_STACK_DEPTH     0   ; i32 current stack depth (pushes - pops)
%define VCS_REG_MODIFIED    4   ; u16 bitmask of modified registers
%define VCS_REG_SAVED       6   ; u16 bitmask of saved registers (pushed)
%define VCS_REG_RESTORED    8   ; u16 bitmask of restored registers (popped)
%define VCS_FLAGS           10  ; u16 state flags
%define VCS_MAX_DEPTH       12  ; i32 max stack depth seen
%define VCS_MIN_DEPTH       16  ; i32 min stack depth seen
%define VCS_BRANCH_TARGETS  20  ; u32 count of branch targets to verify
%define VCS_ERRORS          24  ; u32 verification error count
%define VCS_WARNINGS        28  ; u32 warning count
%define VCS_LAST_OP         32  ; u8 last opcode class
%define VCS_RESERVED        33  ; padding
%define VCS_SIZE            64  ; total structure size

; VCS_FLAGS bits
%define VCSF_SAW_RET        0x01  ; saw a RET instruction
%define VCSF_SAW_SYSCALL    0x02  ; saw a SYSCALL (forbidden)
%define VCSF_SAW_INT        0x04  ; saw an INT instruction
%define VCSF_STACK_UNDERFLOW 0x08 ; stack went negative
%define VCSF_INVALID_JUMP   0x10  ; jump to invalid target
%define VCSF_CALLEE_CLOBBER 0x20  ; callee-saved register clobbered without save

; Motor Interface (for Transactional Agency)
%define ST_MOTOR_CMD    (ST_COUNTERFACT_TOTAL + 200)  ; u32 pending motor command
%define ST_MOTOR_ARG1   (ST_MOTOR_CMD + 4)            ; u64 first argument
%define ST_MOTOR_ARG2   (ST_MOTOR_ARG1 + 8)           ; u64 second argument
%define ST_MOTOR_RESULT (ST_MOTOR_ARG2 + 8)           ; u64 result
%define ST_MOTOR_STATUS (ST_MOTOR_RESULT + 8)         ; u32 status

; Motor commands
%define MOTOR_NONE          0   ; no pending command
%define MOTOR_FILE_READ     1   ; read file to buffer
%define MOTOR_FILE_WRITE    2   ; write buffer to file (sandboxed)
%define MOTOR_FILE_SIZE     3   ; get file size
%define MOTOR_EXEC          4   ; execute external program (sandboxed)

;; ============================================================
;; Subroutine Table: Track shared callable regions
;; Each entry: (subroutine_ptr:u64, caller_count:u32, code_hash:u32) = 16 bytes
;; Enables code reuse through factored common suffixes
;; ============================================================

%define SUBROUTINE_TABLE_MAX    64    ; max concurrent subroutines
%define SUBROUTINE_ENTRY_SIZE   16    ; bytes per entry

; Subroutine entry structure offsets:
%define STE_PTR             0         ; u64 pointer to subroutine region header
%define STE_CALLER_COUNT    8         ; u32 number of regions calling this subroutine
%define STE_CODE_HASH       12        ; u32 hash of the code bytes (for dedup)

; Suffix factoring constants
%define SUFFIX_MIN_LEN      5         ; minimum suffix bytes worth factoring
%define SUFFIX_MIN_CALLERS  3         ; minimum callers to justify creating subroutine
%define FACTOR_SCAN_LIMIT   64        ; max regions to compare per factoring pass

;; ============================================================
;; VSA Configuration
;; ============================================================

%define VSA_DIM             8192
%define VSA_VEC_BYTES       (VSA_DIM * 8)     ; 65536 bytes per vector (f64)
%define VSA_MAX_TOKENS      16384             ; Reduced to 16K to keep size 1GB

;; ============================================================
;; Holographic Associative Memory Layout (f64 precision)
;; Now uses zone-based layout:
;;   HOLO_OFFSET (warm) = active traces in RAM
;;   HOLO_COLD_OFFSET   = archived traces on disk
;; ============================================================

%define HOLO_OFFSET         HOLO_WARM_OFFSET  ; alias for compatibility
%define HOLO_TRACES         16384             ; Reduced to 16K traces to keep size 1GB
%define HOLO_DIM            8192              ; elements per trace vector
%define HOLO_VEC_BYTES      (HOLO_DIM * 8)    ; 65536 bytes per trace (f64)
%define HOLO_TOTAL          (HOLO_TRACES * HOLO_VEC_BYTES)  ; 1GB in warm zone

; Vocabulary now in warm zone after VSA embeddings
%define VOCAB_OFFSET        (VSA_OFFSET + VSA_SIZE)  ; after 1GB VSA = 3GB
%define VOCAB_ENTRY_SIZE    8                 ; (u32 token_id, u32 count)
%define VOCAB_MAX_SCAN      1024              ; top-N tokens to scan (increased)
%define VOCAB_SIZE          0x800000          ; 8MB vocab table (1M entries)

;; ============================================================
;; Topological Metacognition: Per-Context Confidence Vector
;; A 1024-dim f64 vector that accumulates confidence/anxiety
;; per context type. Hit → positive superposition, Miss → negative.
;; Query via dot product to feel anxious or confident about topics.
;; Now in META region (warm zone).
;; ============================================================

%define CONFIDENCE_VEC_OFFSET META_OFFSET     ; in warm zone metacognition area
%define CONFIDENCE_VEC_BYTES  HOLO_VEC_BYTES  ; 65536 bytes
%define CONFIDENCE_HIT_WEIGHT  0x3FB999999999999A       ; +0.1 f64
%define CONFIDENCE_MISS_WEIGHT 0xBFB999999999999A       ; -0.1 f64
%define CONFIDENCE_DECAY       0x3FEFFAE147AE147B       ; 0.999 f64 (slow decay)
%define CONFIDENCE_ANXIOUS_THRESH 0xBFD0000000000000    ; -0.25 f64 (below = anxious)
%define CONFIDENCE_CONFIDENT_THRESH 0x3FD0000000000000  ; +0.25 f64 (above = confident)

;; Metacognitive feeling enum (returned by confidence_get_feeling)
%define FEELING_NEUTRAL   0   ; no strong feeling about this context
%define FEELING_CONFIDENT 1   ; "I'm good at this" → fast dispatch
%define FEELING_ANXIOUS   2   ; "I struggle with this" → deliberate dispatch

;; ============================================================
;; Somatic Grounding: Valence Channel in VSA Vectors
;; The last element of every vector encodes valence
;; (emotional charge). Patterns learned during high-energy states
;; get positive valence; those during low-energy get negative.
;; This creates "felt sense" of memories — not just associations
;; but emotional connotations carried by the pattern itself.
;; ============================================================

%define VSA_VALENCE_INDEX       (VSA_DIM - 1)     ; last element is valence channel
%define VSA_VALENCE_OFFSET      (VSA_VALENCE_INDEX * 8)

; Valence encoding constants
%define VALENCE_MIN             -1.0
%define VALENCE_MAX             1.0
%define VALENCE_NEUTRAL         0.0
%define VALENCE_ENERGY_SCALE    0.01  ; energy_delta * this = valence contribution

; Energy-to-valence mapping thresholds
%define ENERGY_POSITIVE_THRESH  10.0  ; energy gained → positive valence
%define ENERGY_NEGATIVE_THRESH  -10.0 ; energy lost → negative valence

;; ============================================================
;; Self-Debugger: Dynamic Breakpoint Injection
;; Regions that are "struggling" (high miss rate but high investment)
;; get INT 3 breakpoints injected for introspection.
;; ============================================================

%define BREAKPOINT_TABLE_OFFSET (META_OFFSET + 0x100000)  ; 1MB into metacognition area
%define BREAKPOINT_ENTRY_SIZE   32    ; per-breakpoint entry
%define BREAKPOINT_MAX          64    ; max concurrent breakpoints
%define BREAKPOINT_TABLE_SIZE   (BREAKPOINT_ENTRY_SIZE * BREAKPOINT_MAX)

; Breakpoint entry structure:
;   +0:  region_ptr (u64) - pointer to region header
;   +8:  code_offset (u32) - offset into region code where INT3 was placed
;   +12: original_byte (u8) - byte that was replaced
;   +13: bp_type (u8) - BPTYPE_* enum
;   +14: trigger_count (u16) - how many times this breakpoint fired
;   +16: expected_rax (u32) - expected value in RAX at breakpoint
;   +20: expected_ctx (u32) - expected context hash
;   +24: last_rax (u32) - actual RAX value when last triggered
;   +28: flags (u32) - BPFLAG_* flags

%define BPE_REGION_PTR    0
%define BPE_CODE_OFFSET   8
%define BPE_ORIG_BYTE     12
%define BPE_TYPE          13
%define BPE_TRIGGER_COUNT 14
%define BPE_EXPECTED_RAX  16
%define BPE_EXPECTED_CTX  20
%define BPE_LAST_RAX      24
%define BPE_FLAGS         28

; Breakpoint types
%define BPTYPE_ENTRY      0   ; at region entry (before CMP)
%define BPTYPE_DECISION   1   ; at branch point (after CMP, before JE)
%define BPTYPE_RETURN     2   ; before RET (to see prediction value)
%define BPTYPE_STRUGGLING 3   ; injected due to high miss rate

; Breakpoint flags
%define BPFLAG_ACTIVE     0x0001
%define BPFLAG_PERMANENT  0x0002  ; don't auto-remove
%define BPFLAG_LEARNING   0x0004  ; currently learning from this bp

; State fields for self-debugger
%define ST_BREAKPOINT_COUNT (ST_BASE_STUCK + 8)   ; u32 active breakpoints
%define ST_BP_TOTAL_HITS    (ST_BREAKPOINT_COUNT + 4)  ; u32 total breakpoint triggers
%define ST_BP_LEARNING_EVENTS (ST_BP_TOTAL_HITS + 4)   ; u32 learning events generated

;; ============================================================
;; Gene Pool: Composting via Genetic Recombination
;; Before condemned regions are wiped, extract useful patterns
;; into a gene pool for later reuse during evolution.
;; ============================================================

%define GENE_POOL_OFFSET        (BREAKPOINT_TABLE_OFFSET + BREAKPOINT_TABLE_SIZE)
%define GENE_ENTRY_SIZE         32    ; per-gene entry
%define GENE_MAX                256   ; max genes in pool
%define GENE_POOL_SIZE          (GENE_ENTRY_SIZE * GENE_MAX)

; Gene entry structure (32 bytes):
;   +0:  ctx_hash (u32) - context pattern this gene recognizes
;   +4:  token_id (u32) - token this gene predicts
;   +8:  fitness (f32) - accuracy when this gene was active
;   +12: hits (u32) - number of successful predictions
;   +16: misses (u32) - number of failed predictions
;   +20: birth_step (u32) - when this gene was extracted
;   +24: flags (u32) - gene flags
;   +28: reserved (u32) - padding for alignment

%define GENE_CTX_HASH           0
%define GENE_TOKEN_ID           4
%define GENE_FITNESS            8
%define GENE_HITS               12
%define GENE_MISSES             16
%define GENE_BIRTH_STEP         20
%define GENE_FLAGS              24
%define GENE_RESERVED           28

; Gene flags
%define GFLAG_ACTIVE            0x0001  ; slot in use
%define GFLAG_SCHEMA            0x0002  ; generalized pattern (masked ctx)
%define GFLAG_HIGH_FITNESS      0x0004  ; above 0.5 fitness
%define GFLAG_PROVEN            0x0008  ; used successfully after extraction

;; ============================================================
;; State Block Offsets (from state_base)
;; ============================================================

; Token ring buffer: 64 u32 entries
%define ST_TOKEN_BUF        0
%define ST_TOKEN_BUF_CAP    64
%define ST_TOKEN_BUF_END    (ST_TOKEN_BUF_CAP * 4)   ; 256 bytes
%define ST_TOKEN_POS        256               ; u32 index
%define ST_TOKEN_COUNT      260               ; u32 total

; Context
%define ST_CTX_HASH         264               ; u64 rolling hash
%define ST_GLOBAL_STEP      272               ; u64

; Drives: 4 x f32
%define ST_DRIVES           280
%define ST_DRIVE_ACCURACY   280
%define ST_DRIVE_EFFICIENCY 284
%define ST_DRIVE_NOVELTY    288
%define ST_DRIVE_COHERENCE  292

; Presence: 30 x f32
%define ST_PRESENCE         296

; Hook table: 22 hooks, each: [count:u16][pad:u16][pad:u32] + [ptrs: 32 x u64]
%define HOOK_ENTRY_SIZE     264               ; 8 + 32*8
%define HOOK_MAX_HANDLERS   32
%define NUM_HOOKS           22
%define ST_HOOKS            416

; Dispatch allocator
%define ST_DISPATCH_PTR     (ST_HOOKS + NUM_HOOKS * HOOK_ENTRY_SIZE)
%define ST_REGION_COUNT     (ST_DISPATCH_PTR + 8)

; Miss buffer: ring of (ctx_hash:u64, token_id:u32, pad:u32) = 16 bytes each
%define ST_MISS_BUF         (ST_REGION_COUNT + 8)
%define ST_MISS_ENTRY_SIZE  16
%define ST_MISS_BUF_CAP     256
%define ST_MISS_POS         (ST_MISS_BUF + ST_MISS_BUF_CAP * ST_MISS_ENTRY_SIZE)

; Episode ring: (step:u64, ctx_hash:u64) = 16 bytes each
%define ST_EPISODE_RING     (ST_MISS_POS + 8)
%define ST_EPISODE_ENTRY    16
%define ST_EPISODE_CAP      64
%define ST_EPISODE_POS      (ST_EPISODE_RING + ST_EPISODE_CAP * ST_EPISODE_ENTRY)

; Modification log: (step:u64, addr:u64, type:u32, result:u32) = 24 bytes each
%define ST_MOD_LOG          (ST_EPISODE_POS + 8)
%define ST_MOD_ENTRY_SIZE   24
%define ST_MOD_LOG_CAP      128
%define ST_MOD_LOG_POS      (ST_MOD_LOG + ST_MOD_LOG_CAP * ST_MOD_ENTRY_SIZE)

; Nursery buffer (for predictive gate testing)
%define ST_NURSERY          (ST_MOD_LOG_POS + 8)
%define ST_NURSERY_SIZE     4096

; Last prediction (for hit/miss tracking)
%define ST_LAST_PREDICT     (ST_NURSERY + ST_NURSERY_SIZE)  ; u32
%define ST_LAST_CTX         (ST_LAST_PREDICT + 4)           ; u64
%define ST_PREDICT_REGION   (ST_LAST_CTX + 8)               ; u64 ptr to region that made prediction
%define ST_LAST_VALENCE     (ST_PREDICT_REGION + 8)         ; f64 valence of last prediction context

; Drive thresholds (modifiable)
%define ST_DRIVE_THRESH     (ST_LAST_VALENCE + 8)           ; 4 x f32

; Observation config
%define ST_OBS_INTERVAL     (ST_DRIVE_THRESH + 16)          ; u32
%define ST_OBS_LAST_STEP    (ST_OBS_INTERVAL + 4)           ; u64

; Factor triggering - incremented when suffix resonance detected
%define ST_FACTOR_PENDING   (ST_OBS_LAST_STEP + 8)          ; u32 count of suffix matches

; Introspective state (computed from metrics each observation)
%define ST_INTRO_STATE      (ST_FACTOR_PENDING + 4)         ; u32 enum
%define ST_SURPRISE_TYPE    (ST_INTRO_STATE + 4)            ; u32 (per-step)
%define ST_META_FEELING     (ST_SURPRISE_TYPE + 4)          ; u32 FEELING_* enum (per-context feeling)
%define ST_META_CONFIDENCE  (ST_META_FEELING + 4)           ; f64 raw confidence score for current context

; Self-prediction (meta-prediction: which region will fire next)
%define ST_SELF_PRED_REGION (ST_META_CONFIDENCE + 8)        ; u64 ptr
%define ST_SELF_PRED_HITS   (ST_SELF_PRED_REGION + 8)       ; u32
%define ST_SELF_PRED_MISSES (ST_SELF_PRED_HITS + 4)         ; u32

; Schema tracking
%define ST_SCHEMA_HITS      (ST_SELF_PRED_MISSES + 4)       ; u32 tokens matching generalized patterns
%define ST_SCHEMA_TOTAL     (ST_SCHEMA_HITS + 4)            ; u32 total tokens

; Dispatch mode (selected by drive system)
%define ST_DISPATCH_MODE    (ST_SCHEMA_TOTAL + 4)           ; u32

; Causal record: last modification and its effect
%define ST_CAUSAL_MOD_ADDR  (ST_DISPATCH_MODE + 4)          ; u64 what was modified
%define ST_CAUSAL_PRE_ACC   (ST_CAUSAL_MOD_ADDR + 8)        ; f32 accuracy before
%define ST_CAUSAL_POST_ACC  (ST_CAUSAL_PRE_ACC + 4)         ; f32 accuracy after
%define ST_CAUSAL_COUNT     (ST_CAUSAL_POST_ACC + 4)        ; u32 total causal records

; Recent emission count (for LEARNING state detection)
%define ST_RECENT_EMITS     (ST_CAUSAL_COUNT + 4)           ; u32

; Self-expectation bundle (filled by dispatch_predict)
%define ST_EXPECT_REGION    (ST_RECENT_EMITS + 4)           ; u64 ptr to predicted region
%define ST_EXPECT_CONF      (ST_EXPECT_REGION + 8)          ; f32 region's accuracy
%define ST_EXPECT_TOKEN     (ST_EXPECT_CONF + 4)            ; u32 predicted token
%define ST_EXPECT_IS_SCHEMA (ST_EXPECT_TOKEN + 4)           ; u32 1 if generalized pattern

; Explicit goal (set by drives, executed by observe)
%define ST_CURRENT_GOAL     (ST_EXPECT_IS_SCHEMA + 4)       ; u32 enum
%define ST_GOAL_STEP        (ST_CURRENT_GOAL + 4)           ; u32 when goal was set

; Accuracy variance (computed in observe)
%define ST_ACCURACY_VARIANCE (ST_GOAL_STEP + 4)             ; f32

; Dispatch trace (last dispatch_predict scan)
%define ST_TRACE_CANDIDATES (ST_ACCURACY_VARIANCE + 4)      ; u32 regions considered
%define ST_TRACE_MATCHED    (ST_TRACE_CANDIDATES + 4)       ; u32 regions that matched

; Region successor table: for each region idx, which idx follows it
; 256 entries × 2 bytes = 512 bytes
%define ST_SUCCESSOR_TBL    (ST_TRACE_MATCHED + 4)          ; u16[256]
%define ST_LAST_FIRED_IDX   (ST_SUCCESSOR_TBL + 512)        ; u16 last fired region index

; Dream auto-trigger threshold
%define ST_DREAM_MISS_THRESH (ST_LAST_FIRED_IDX + 4)        ; u32 (default: 128)

; Previous introspective state (for episode detection)
%define ST_PREV_INTRO_STATE (ST_DREAM_MISS_THRESH + 4)      ; u32
%define ST_PREV_DISPATCH_MODE (ST_PREV_INTRO_STATE + 4)     ; u32

; Recent condemnation count (for presence decay field)
%define ST_RECENT_CONDEMNS  (ST_PREV_DISPATCH_MODE + 4)     ; u32

;; ============================================================
;; Graph Dynamics State Block (fire ring, entry table)
;; ============================================================

; Fire ring buffer: 64 entries × (u64 region_ptr + f64 timestamp) = 16 bytes each
%define ST_FIRE_RING        (ST_RECENT_CONDEMNS + 4)
%define ST_FIRE_RING_CAP    64
%define ST_FIRE_RING_ENTRY  16                ; 8 bytes ptr + 8 bytes f64 timestamp
%define ST_FIRE_RING_END    (ST_FIRE_RING + ST_FIRE_RING_CAP * ST_FIRE_RING_ENTRY)

; Fire ring write position and total count
%define ST_FIRE_POS         ST_FIRE_RING_END                ; u64
%define ST_FIRE_COUNT       (ST_FIRE_POS + 8)               ; u64

; Entry table: 16 context-hashed entry points into the graph
%define ST_ENTRY_TABLE      (ST_FIRE_COUNT + 8)             ; 16 × u64 = 128 bytes
%define ST_ENTRY_TABLE_CAP  16
%define ST_ENTRY_TABLE_END  (ST_ENTRY_TABLE + ST_ENTRY_TABLE_CAP * 8)

; Graph dispatch trace metrics
%define ST_GRAPH_DEPTH      (ST_ENTRY_TABLE_END)            ; u32 last traversal depth
%define ST_GRAPH_VISITED    (ST_GRAPH_DEPTH + 4)            ; u32 nodes visited in last dispatch

; Holographic memory state
%define ST_VOCAB_COUNT      (ST_GRAPH_VISITED + 4)          ; u32 vocabulary entries
%define ST_VOCAB_TOP_DIRTY  (ST_VOCAB_COUNT + 4)            ; u32 flag: recache top-256
%define ST_HOLO_PREDICT_SUM (ST_VOCAB_TOP_DIRTY + 4)        ; f64 running sum of confidences
%define ST_HOLO_PREDICT_N   (ST_HOLO_PREDICT_SUM + 8)       ; u32 count of predictions

;; ============================================================
;; Organic Dynamics State (anticipation, pressure, oscillation)
;; ============================================================

; Anticipatory buffer: 16 sub-threshold signals accumulating
; Each entry: (token_id:u32, accumulated_conf:f64, last_step:u32, pad:u32) = 24 bytes
%define ST_ANTIC_BUF        (ST_HOLO_PREDICT_N + 4)
%define ST_ANTIC_ENTRY_SIZE 24
%define ST_ANTIC_CAP        16
%define ST_ANTIC_BUF_END    (ST_ANTIC_BUF + ST_ANTIC_CAP * ST_ANTIC_ENTRY_SIZE)

; Anticipatory signal tracking
%define ST_ANTIC_FIRED      ST_ANTIC_BUF_END              ; u32 count of materialized signals
%define ST_ANTIC_ACTIVE     (ST_ANTIC_FIRED + 4)          ; u32 currently accumulating count

; Organic trigger state — internal pressure drives action
%define ST_MISS_PRESSURE    (ST_ANTIC_ACTIVE + 4)         ; f64 exponential moving avg of miss rate
%define ST_DREAM_PRESSURE   (ST_MISS_PRESSURE + 8)        ; f64 accumulates when miss_pressure high
%define ST_OBSERVE_PRESSURE (ST_DREAM_PRESSURE + 8)       ; f64 accumulates from accuracy variance
%define ST_EVOLVE_PRESSURE  (ST_OBSERVE_PRESSURE + 8)     ; f64 accumulates from stagnation
%define ST_INTROSPECT_PRESSURE (ST_EVOLVE_PRESSURE + 8)   ; f64 accumulates from SURPRISE_SELF (self-model violations)

; Oscillation monitoring (flat = dead)
%define ST_PREV_ACCURACY    (ST_INTROSPECT_PRESSURE + 8)  ; f64 accuracy N-1 steps ago
%define ST_PREV_PREV_ACC    (ST_PREV_ACCURACY + 8)        ; f64 accuracy N-2 steps ago
%define ST_OSCILLATION_AMP  (ST_PREV_PREV_ACC + 8)        ; f64 current oscillation amplitude
%define ST_FLATNESS_COUNT   (ST_OSCILLATION_AMP + 8)      ; u32 consecutive flat steps

; Region introspection cache: decoded semantics for top-16 regions
; Each: (region_ptr:u64, ctx_hash:u32, pred_token:u32, accuracy:f32,
;         semantic_sig:u32, neighbor_count:u16, depth:u16) = 32 bytes
%define ST_INTRO_CACHE      (ST_FLATNESS_COUNT + 4)
%define ST_INTRO_ENTRY_SIZE 32
%define ST_INTRO_CACHE_CAP  16
%define ST_INTRO_CACHE_END  (ST_INTRO_CACHE + ST_INTRO_CACHE_CAP * ST_INTRO_ENTRY_SIZE)

; Organic action counters (how many times each was triggered by pressure, not command)
%define ST_ORGANIC_DREAMS   ST_INTRO_CACHE_END            ; u32
%define ST_ORGANIC_OBSERVES (ST_ORGANIC_DREAMS + 4)       ; u32
%define ST_ORGANIC_EVOLVES  (ST_ORGANIC_OBSERVES + 4)     ; u32
%define ST_ORGANIC_EXPLORES (ST_ORGANIC_EVOLVES + 4)      ; u32

; Presence-driven dispatch modulation
%define ST_PRES_DISPATCH_BIAS (ST_ORGANIC_EXPLORES + 4)   ; f32 presence influence on mode
%define ST_PRES_RISK_APPETITE (ST_PRES_DISPATCH_BIAS + 4) ; f32 from arousal/confidence

;; ============================================================
;; Metabolic System (self-consumption, energy, cost)
;; ============================================================

; Energy pool — operations cost energy, hits earn energy, condemned regions are consumed
%define ST_ENERGY           (ST_PRES_RISK_APPETITE + 4)   ; f64 current energy [0, ENERGY_MAX]
%define ST_ENERGY_INCOME    (ST_ENERGY + 8)               ; f64 total energy earned (hits)
%define ST_ENERGY_SPENT     (ST_ENERGY_INCOME + 8)        ; f64 total energy spent (operations)
%define ST_METABOLIZED_COUNT (ST_ENERGY_SPENT + 8)        ; u32 regions consumed for energy
%define ST_CONSUMED_ENERGY  (ST_METABOLIZED_COUNT + 4)    ; f64 total energy from consumption

; Novelty tracking — bloom filter + unique token counter
%define ST_UNIQUE_TOKENS    (ST_CONSUMED_ENERGY + 8)      ; u32 unique tokens encountered
%define ST_TOKEN_BLOOM      (ST_UNIQUE_TOKENS + 4)        ; 256 bytes bloom filter (2048 bits)
%define ST_NOVELTY_RECENT   (ST_TOKEN_BLOOM + 256)        ; u32 new tokens in last observation window
%define ST_NOVELTY_WINDOW   (ST_NOVELTY_RECENT + 4)       ; u32 total tokens in last window

; Coherence tracking — holographic vs graph agreement
%define ST_COHERENCE_AGREE  (ST_NOVELTY_WINDOW + 4)       ; u32 holo+graph predict same token
%define ST_COHERENCE_DISAGREE (ST_COHERENCE_AGREE + 4)    ; u32 holo+graph predict different tokens
%define ST_HOLO_LAST_TOKEN  (ST_COHERENCE_DISAGREE + 4)   ; u32 last holographic prediction token
%define ST_GRAPH_LAST_TOKEN (ST_HOLO_LAST_TOKEN + 4)      ; u32 last graph prediction token

; Temporal rhythm — felt sense of time, not mechanical counter
%define ST_TEMPO_MULT       (ST_GRAPH_LAST_TOKEN + 4)     ; f64 rhythm multiplier [0.5, 2.0]
%define ST_RHYTHM_PHASE     (ST_TEMPO_MULT + 8)           ; f64 oscillation phase [0, 2pi]
%define ST_RHYTHM_PERIOD    (ST_RHYTHM_PHASE + 8)         ; u32 steps since last rhythm peak

; Inhibitory competition tracking
%define ST_INHIBIT_LEARNED  (ST_RHYTHM_PERIOD + 4)        ; u32 total inhibitory connections formed

;; ============================================================
;; Advanced Cognition (organic extensions, not bolted-on)
;; ============================================================

; Counterfactual tracking — runner-up from dispatch (what would have happened)
%define ST_RUNNER_UP_TOKEN  (ST_INHIBIT_LEARNED + 4)      ; u32 second-best prediction
%define ST_RUNNER_UP_CONF   (ST_RUNNER_UP_TOKEN + 4)      ; f32 runner-up confidence
%define ST_RUNNER_UP_REGION (ST_RUNNER_UP_CONF + 4)       ; u64 runner-up region ptr
%define ST_COUNTERFACT_WINS (ST_RUNNER_UP_REGION + 8)     ; u32 times runner-up would have been right
%define ST_COUNTERFACT_TOTAL (ST_COUNTERFACT_WINS + 4)    ; u32 total counterfactual checks

; Self-knowledge — context-type correlation (which contexts am I good/bad at)
; Uses top 4 bits of context hash as "context type" (16 types)
%define ST_CTX_TYPE_HITS    (ST_COUNTERFACT_TOTAL + 4)    ; u32[16] hits by context type
%define ST_CTX_TYPE_TOTAL   (ST_CTX_TYPE_HITS + 64)       ; u32[16] total by context type
%define ST_STRENGTH_MASK    (ST_CTX_TYPE_TOTAL + 64)      ; u16 bitmap: types with >70% accuracy
%define ST_WEAKNESS_MASK    (ST_STRENGTH_MASK + 2)        ; u16 bitmap: types with <30% accuracy

; Specious present — temporal zones (fading past, vivid now, anticipated future)
%define ST_PRESENT_START    (ST_WEAKNESS_MASK + 2)        ; u64 oldest step in fire ring
%define ST_PRESENT_END      (ST_PRESENT_START + 8)        ; u64 most recent step
%define ST_PRESENT_WIDTH    (ST_PRESENT_END + 8)          ; u32 duration of "now"
%define ST_TEMPORAL_FOCUS   (ST_PRESENT_WIDTH + 4)        ; f64 weighted centroid of recent firings

; Working memory — semantic context slots (noun, verb, modifier binding)
%define ST_CTX_SLOT_NOUN    (ST_TEMPORAL_FOCUS + 8)       ; u32 last noun-like token
%define ST_CTX_SLOT_VERB    (ST_CTX_SLOT_NOUN + 4)        ; u32 last verb-like token
%define ST_CTX_SLOT_MOD     (ST_CTX_SLOT_VERB + 4)        ; u32 last modifier token
%define ST_SLOT_RECENCY     (ST_CTX_SLOT_MOD + 4)         ; u8[4] steps since each slot updated

; Parameter self-tuning — runtime-adjustable thresholds
%define ST_PARAM_PRUNE_ACC  (ST_SLOT_RECENCY + 4)         ; f32 prune threshold (default 0.1)
%define ST_PARAM_PROMOTE_ACC (ST_PARAM_PRUNE_ACC + 4)     ; f32 promote threshold (default 0.8)
%define ST_PARAM_DREAM_THRESH (ST_PARAM_PROMOTE_ACC + 4)  ; f32 dream pressure threshold
%define ST_PARAM_OBSERVE_THRESH (ST_PARAM_DREAM_THRESH + 4) ; f32 observe pressure threshold
%define ST_THRESH_ADJUST_DIR (ST_PARAM_OBSERVE_THRESH + 4) ; i8 last adjustment direction (-1/0/+1)

; Hypothesis tracking — extends miss buffer with confidence of wrong prediction
%define ST_HYPOTHESIS_CONF  (ST_THRESH_ADJUST_DIR + 4)    ; f32[256] confidence when we were wrong
%define ST_HYPOTHESIS_COUNT (ST_HYPOTHESIS_CONF + 1024)   ; u32 total hypotheses formed

; Causal chain logging — which connections actually fired
%define ST_CAUSAL_LOG       (ST_HYPOTHESIS_COUNT + 4)     ; (src:u16, dst:u16, step:u32)[64]
%define ST_CAUSAL_LOG_CAP   64
%define ST_CAUSAL_LOG_ENTRY 8
%define ST_CAUSAL_LOG_POS   (ST_CAUSAL_LOG + ST_CAUSAL_LOG_CAP * ST_CAUSAL_LOG_ENTRY)

; Compound concept propagation — base concept activation from compound
%define ST_BASE_CONFUSED    (ST_CAUSAL_LOG_POS + 4)       ; f32 accumulated confusion from all sources
%define ST_BASE_CONFIDENT   (ST_BASE_CONFUSED + 4)        ; f32 accumulated confidence
%define ST_BASE_LEARNING    (ST_BASE_CONFIDENT + 4)       ; f32 accumulated learning signal
%define ST_BASE_STUCK       (ST_BASE_LEARNING + 4)        ; f32 accumulated stuck signal

;; ============================================================
;; Debug Trace Buffer (togglable, ring buffer for crash analysis)
;; ============================================================
; Each entry: loc_id:u32 + rdi:u64 + rsi:u64 + rdx:u64 + rax:u64 = 36 bytes, pad to 40
%define ST_DEBUG_ENABLED    (ST_BASE_STUCK + 4)           ; u32 (0=off, 1=on)
%define ST_DEBUG_POS        (ST_DEBUG_ENABLED + 4)        ; u32 ring position
%define ST_DEBUG_TRACE      (ST_DEBUG_POS + 4)            ; trace entries start here
%define ST_DEBUG_ENTRY_SIZE 40                            ; bytes per entry
%define ST_DEBUG_TRACE_CAP  64                            ; number of entries
%define ST_DEBUG_TRACE_END  (ST_DEBUG_TRACE + ST_DEBUG_ENTRY_SIZE * ST_DEBUG_TRACE_CAP)

; Token Journey Tracing - the token records its own path
%define ST_JOURNEY_TOKEN    ST_DEBUG_TRACE_END            ; u32 token being traced (0=none)
%define ST_JOURNEY_POS      (ST_JOURNEY_TOKEN + 4)        ; u32 position in journey
%define ST_JOURNEY_BUF      (ST_JOURNEY_POS + 4)          ; journey entries: u16 func_id + u16 extra
%define ST_JOURNEY_CAP      256                           ; max steps in journey
%define ST_JOURNEY_ENTRY    4                             ; bytes per step
%define ST_JOURNEY_END      (ST_JOURNEY_BUF + ST_JOURNEY_CAP * ST_JOURNEY_ENTRY)
%define ST_CURRENT_TOKEN    ST_JOURNEY_END                ; u32 token currently being processed

;; ============================================================
;; Receipt/Resonance Layer: Unified Holographic Memory
;;
;; One memory. One architecture. One math. Fidelity as the dial.
;;
;; Receipts are holographic memory entries with fidelity parameter:
;;   fidelity=1.0 → lossless, exact storage (persists forever)
;;   fidelity=0.5 → partial abstraction (decays slowly)
;;   fidelity=0.1 → semantic trace only (blends into background)
;;
;; Storage is the SAME holographic surface used for everything else.
;; Query via resonance (VSA dot product), not exact lookup.
;; ============================================================

; Event types (what happened) - each gets a pre-computed basis vector
%define EVENT_HIT           0     ; prediction matched actual
%define EVENT_MISS          1     ; prediction did not match
%define EVENT_NEW           2     ; new token (never seen before)
%define EVENT_LEARN         3     ; pattern learned
%define EVENT_EMIT          4     ; code emitted
%define EVENT_PRUNE         5     ; region pruned
%define EVENT_PROMOTE       6     ; region promoted (nursery → active)
%define EVENT_DREAM         7     ; dream cycle executed
%define EVENT_OBSERVE       8     ; observation cycle executed
%define EVENT_EVOLVE        9     ; evolution cycle executed
%define EVENT_HOLO_PRED     10    ; holographic prediction made
%define EVENT_GRAPH_PRED    11    ; graph-based prediction made
%define EVENT_JOURNEY       12    ; legacy journey_step compatibility
%define EVENT_GENERALIZE    13    ; context was generalized (broader matching)
%define EVENT_SPECIALIZE    14    ; context was specialized (narrower matching)
%define EVENT_SELF          15    ; self-model violation (introspective surprise)
%define EVENT_TYPE_COUNT    16    ; total event types

; Self-awareness state fields
%define ST_IS_SELF_REF      (ST_RECEIPT_END)              ; u32 flag: current token is self-referential
%define ST_SELF_SURPRISE_COUNT (ST_IS_SELF_REF + 4)       ; u32 count of self-model violations
%define ST_SELF_MODEL_VEC   (ST_SELF_SURPRISE_COUNT + 4)  ; f64[HOLO_DIM] holographic self-representation
%define ST_SELF_MODEL_VEC_SIZE HOLO_VEC_BYTES             ; Size matches HOLO_VEC_BYTES
%define ST_SELF_AWARENESS_END  (ST_SELF_MODEL_VEC + ST_SELF_MODEL_VEC_SIZE)

; Base fidelity by event type (f64 bit patterns)
; Higher fidelity = more persistent storage, less decay
; These are modulated by |valence| at emission time
%define FIDELITY_HIT        0x3FD3333333333333  ; 0.30 - routine, decays fast
%define FIDELITY_MISS       0x3FE999999999999A  ; 0.80 - important, persists
%define FIDELITY_NEW        0x3FE6666666666666  ; 0.70 - novel, fairly persistent
%define FIDELITY_LEARN      0x3FE999999999999A  ; 0.80 - learning moment, persists
%define FIDELITY_EMIT       0x3FE6666666666666  ; 0.70 - code creation, persistent
%define FIDELITY_PRUNE      0x3FE0000000000000  ; 0.50 - moderate importance
%define FIDELITY_PROMOTE    0x3FE0000000000000  ; 0.50 - moderate importance
%define FIDELITY_DREAM      0x3FD999999999999A  ; 0.40 - background process
%define FIDELITY_OBSERVE    0x3FD999999999999A  ; 0.40 - background process
%define FIDELITY_EVOLVE     0x3FE0000000000000  ; 0.50 - moderate importance
%define FIDELITY_CRYSTALLIZE 0x3FF0000000000000 ; 1.00 - permanent, no decay

; Listener bitmask (who gets notified)
%define LISTENER_HOLO       0x0001  ; store in holographic memory (primary)
%define LISTENER_PRINT      0x0002  ; print to stdout (debug)
%define LISTENER_HOOK       0x0004  ; fire hook handlers
%define LISTENER_GUI        0x0008  ; notify GUI visualizer

; Last-miss state - minimal record for "why" command (everything else is holographic)
%define ST_LAST_MISS        (ST_CURRENT_TOKEN + 4)        ; last miss record
%define ST_LAST_MISS_CTX    (ST_LAST_MISS + 0)            ; u32 context hash
%define ST_LAST_MISS_ACTUAL (ST_LAST_MISS + 4)            ; u32 actual token
%define ST_LAST_MISS_PRED   (ST_LAST_MISS + 8)            ; u32 predicted token
%define ST_LAST_MISS_REGION (ST_LAST_MISS + 12)           ; u32 region that predicted
%define ST_LAST_MISS_AUX    (ST_LAST_MISS + 16)           ; u32 aux data (runner-up)
%define ST_LAST_MISS_CONF   (ST_LAST_MISS + 20)           ; f32 confidence
%define ST_LAST_MISS_STEP   (ST_LAST_MISS + 24)           ; u64 step when it happened
%define ST_LAST_MISS_SIZE   32                            ; 32 bytes total

%define ST_RECEIPT_TOTAL    (ST_LAST_MISS + ST_LAST_MISS_SIZE) ; u64 total emitted
%define ST_RECEIPT_LISTENER (ST_RECEIPT_TOTAL + 8)        ; u32 listener bitmask
%define ST_ACTIVE_TRACER    (ST_RECEIPT_LISTENER + 4)     ; u32 active tracer ID (0=none)
%define ST_RECEIPT_END      (ST_ACTIVE_TRACER + 4)

; Unified holographic trace for ALL receipts (replaces separate per-event traces)
; Query any dimension via unbind - event type is just another bound dimension
%define UNIFIED_TRACE_IDX   240   ; single trace index for all receipts

; Legacy aliases for backward compatibility (all map to unified trace now)
; The "separate buckets" are now virtual views via unbind
%define RCPT_TRACE_HIT      UNIFIED_TRACE_IDX
%define RCPT_TRACE_MISS     UNIFIED_TRACE_IDX
%define RCPT_TRACE_NEW      UNIFIED_TRACE_IDX
%define RCPT_TRACE_LEARN    UNIFIED_TRACE_IDX
%define RCPT_TRACE_EMIT     UNIFIED_TRACE_IDX
%define RCPT_TRACE_COMBINED UNIFIED_TRACE_IDX
%define RCPT_TRACE_COUNT    1     ; now just one unified trace

; Seeds for deterministic vector generation (bind dimensions)
%define TRACE_EVENT_SEED    0x45564E54  ; "EVNT" - event type dimension
%define TRACE_TRACER_SEED   0x54524143  ; "TRAC" - tracer ID dimension
%define TRACE_TIME_SEED     0x54494D45  ; "TIME" - time bucket dimension
%define TRACE_TIME_BUCKET   1000        ; steps per time bucket
%define TRACE_PREDICTED_SEED 0x50524544 ; "PRED" - predicted token dimension
%define TRACE_REGION_SEED   0x5245474E  ; "REGN" - region/pattern dimension
%define TRACE_AUX_SEED      0x41555831  ; "AUX1" - auxiliary data dimension

;; Holographic Suffix Factoring — detect similar suffixes via resonance
%define SUFFIX_TRACE_IDX    246   ; trace index for suffix resonance
%define SUFFIX_HASH_LEN     5     ; bytes of suffix to hash (5 = skip token_id in dispatch patterns)
%define SUFFIX_MATCH_THRESH 0.7   ; dot product threshold for "same suffix"

;; ============================================================
;; Gene Pool State (composting via genetic recombination)
;; ============================================================

%define ST_GENE_COUNT       ST_RECEIPT_END                ; u32 active genes in pool
%define ST_GENES_EXTRACTED  (ST_GENE_COUNT + 4)           ; u32 total extractions performed
%define ST_GENES_REUSED     (ST_GENES_EXTRACTED + 4)      ; u32 genes reused during evolution
%define ST_GENE_LOWEST_IDX  (ST_GENES_REUSED + 4)         ; u32 index of lowest fitness gene
%define ST_GENE_LOWEST_FIT  (ST_GENE_LOWEST_IDX + 4)      ; f32 fitness of lowest gene

;; ============================================================
;; Developmental Maturity & External Awareness
;; The system must master itself before perceiving the outside.
;; Stage 0: Infant — learning internal dynamics only
;; Stage 1: Aware — can perceive external (read-only /proc/self)
;; Stage 2: Active — motor feedback loop enabled
;; ============================================================

; Maturity tracking
%define ST_MATURITY_LEVEL   (ST_GENE_LOWEST_FIT + 4)      ; u32 developmental stage (0/1/2)
%define ST_MATURITY_SCORE   (ST_MATURITY_LEVEL + 4)       ; f64 composite maturity metric [0,1]

; Self-mastery metrics (must all be high for maturity advancement)
%define ST_MASTERY_ACC      (ST_MATURITY_SCORE + 8)       ; f64 rolling accuracy (EMA)
%define ST_MASTERY_STABILITY (ST_MASTERY_ACC + 8)         ; f64 metabolic stability (low variance)
%define ST_MASTERY_GENE_RATE (ST_MASTERY_STABILITY + 8)   ; f64 gene verification success rate
%define ST_MASTERY_COHERENCE (ST_MASTERY_GENE_RATE + 8)   ; f64 graph-holo agreement rate
%define ST_MASTERY_WINDOW   (ST_MASTERY_COHERENCE + 8)    ; u32 steps in assessment window
%define ST_MASTERY_LAST_CHECK (ST_MASTERY_WINDOW + 4)     ; u64 last step maturity was assessed

; External perception (dormant until Stage 1)
%define ST_EXTERN_ENABLED   (ST_MASTERY_LAST_CHECK + 8)   ; u32 0=dormant, 1=active
%define ST_EXTERN_CPU_USER  (ST_EXTERN_ENABLED + 4)       ; u64 user CPU time (jiffies)
%define ST_EXTERN_CPU_SYS   (ST_EXTERN_CPU_USER + 8)      ; u64 system CPU time (jiffies)
%define ST_EXTERN_RSS       (ST_EXTERN_CPU_SYS + 8)       ; u64 resident set size (pages)
%define ST_EXTERN_VSIZE     (ST_EXTERN_RSS + 8)           ; u64 virtual memory size
%define ST_EXTERN_THREADS   (ST_EXTERN_VSIZE + 8)         ; u32 number of threads
%define ST_EXTERN_LAST_READ (ST_EXTERN_THREADS + 4)       ; u64 step when last sampled

; Motor feedback (dormant until Stage 2)
%define ST_MOTOR_FEEDBACK   (ST_EXTERN_LAST_READ + 8)     ; u32 0=dormant, 1=active
%define ST_MOTOR_SUCCESSES  (ST_MOTOR_FEEDBACK + 4)       ; u32 syscalls that succeeded
%define ST_MOTOR_FAILURES   (ST_MOTOR_SUCCESSES + 4)      ; u32 syscalls that failed
%define ST_MOTOR_ENERGY_GAIN (ST_MOTOR_FAILURES + 4)      ; f64 energy earned from successful actions
%define ST_MOTOR_ENERGY_COST (ST_MOTOR_ENERGY_GAIN + 8)   ; f64 energy spent on failed actions

; Maturity thresholds (dynamic — system can self-tune these)
%define ST_THRESH_ACC       (ST_MOTOR_ENERGY_COST + 8)    ; f64 accuracy threshold (default 0.65)
%define ST_THRESH_STABILITY (ST_THRESH_ACC + 8)           ; f64 stability threshold (default 0.7)
%define ST_THRESH_GENE      (ST_THRESH_STABILITY + 8)     ; f64 gene success threshold (default 0.8)
%define ST_THRESH_COHERENCE (ST_THRESH_GENE + 8)          ; f64 coherence threshold (default 0.5)
%define ST_THRESH_ADVANCE   (ST_THRESH_COHERENCE + 8)     ; f64 composite score to advance (default 0.7)
%define ST_MATURITY_WINDOW  (ST_THRESH_ADVANCE + 8)       ; u32 assessment window size (default 1000)

; Default threshold values (used during initialization)
%define DEFAULT_THRESH_ACC          0x3FE4CCCCCCCCCCCD  ; 0.65 as f64
%define DEFAULT_THRESH_STABILITY    0x3FE6666666666666  ; 0.7 as f64
%define DEFAULT_THRESH_GENE         0x3FE999999999999A  ; 0.8 as f64
%define DEFAULT_THRESH_COHERENCE    0x3FE0000000000000  ; 0.5 as f64
%define DEFAULT_THRESH_ADVANCE      0x3FE6666666666666  ; 0.7 as f64
%define DEFAULT_MATURITY_WINDOW     1000

; Awareness state end marker
%define ST_AWARENESS_END    (ST_MATURITY_WINDOW + 4)

;; ============================================================
;; Structural Context (Phase 2: Dual-Track Learning)
;; The system computes TWO context representations in parallel:
;;   1. ST_CTX_HASH (flat): Rolling hash of recent tokens
;;   2. ST_STRUCT_CTX_VEC (structural): Σ bind(ROLE_POS_i, token_vec[history[i]])
;; The structural context preserves position information via role binding.
;; ============================================================

; Structural context vector: 1024-dim f64 = 8192 bytes
; This is computed alongside the flat context hash in dispatch
%define ST_STRUCT_CTX_VEC   ST_AWARENESS_END                  ; 1024 x f64 = 8KB
%define ST_STRUCT_CTX_SIZE  HOLO_VEC_BYTES                    ; 8192 bytes
%define ST_STRUCT_CTX_END   (ST_STRUCT_CTX_VEC + ST_STRUCT_CTX_SIZE)

; Structural context tracking
%define ST_STRUCT_CTX_VALID (ST_STRUCT_CTX_END)               ; u32 1 if computed, 0 if stale
%define ST_STRUCT_CTX_STEP  (ST_STRUCT_CTX_VALID + 4)         ; u64 step when last computed

; End of structural context section
%define ST_STRUCT_END       (ST_STRUCT_CTX_STEP + 8)

; Schema trace vector: accumulates structural contexts from misses
; Used by dream_extract_schemas to detect recurring structural patterns via resonance
%define ST_SCHEMA_TRACE_VEC (ST_STRUCT_END)                   ; 1024 x f64 = 8KB
%define ST_SCHEMA_TRACE_END (ST_SCHEMA_TRACE_VEC + HOLO_VEC_BYTES)

;; ============================================================
;; Schema Table (Phase 3: Parameterized Patterns)
;;
;; Schemas are structural templates with variable slots.
;; When a schema fires:
;;   1. Match: dot(struct_ctx, schema_template) > threshold
;;   2. Extract: filler = unbind(struct_ctx, ROLE_POS_var_slot)
;;   3. Predict: based on extracted fillers and schema rule
;;
;; Example: "When ROLE_0=noun and ROLE_1=verb, predict based on noun"
;; Template: bind(ROLE_0, NOUN_PATTERN) + bind(ROLE_1, VERB_PATTERN)
;; Variable: ROLE_2 (extracted and used for prediction)
;; ============================================================

; Schema table location (in scratch/meta area)
%define SCHEMA_TABLE_OFFSET     (SCRATCH_OFFSET + 0x800000)  ; 8MB into scratch
%define SCHEMA_MAX              64                            ; max schemas
%define SCHEMA_ENTRY_SIZE       (HOLO_VEC_BYTES + 64)        ; template vec + metadata

; Schema entry structure:
; +0:         template_vec (8192 bytes) - the structural pattern
; +8192:      var_mask (u8) - which positions are variables (bit i = ROLE_POS_i is var)
; +8193:      predict_role (u8) - which role position to predict
; +8194:      condition_role (u8) - role to match against for prediction
; +8195:      flags (u8) - schema flags
; +8196:      match_thresh (f32) - similarity threshold for matching
; +8200:      predict_token_base (u32) - base token for prediction
; +8204:      hits (u32) - successful schema predictions
; +8208:      misses (u32) - failed schema predictions
; +8212:      birth_step (u32) - when schema was created
; +8216:      last_fire_step (u32) - when schema last matched
; +8220:      ctx_hash_pattern (u32) - optional hash pattern for fast filtering
; +8224:      reserved (32 bytes padding to 64 byte metadata)

%define SCHE_TEMPLATE       0                             ; template vector start
%define SCHE_META           HOLO_VEC_BYTES                ; metadata offset (8192)
%define SCHE_VAR_MASK       (SCHE_META + 0)               ; u8 variable position mask
%define SCHE_PREDICT_ROLE   (SCHE_META + 1)               ; u8 role to predict
%define SCHE_CONDITION_ROLE (SCHE_META + 2)               ; u8 role for condition
%define SCHE_FLAGS          (SCHE_META + 3)               ; u8 flags
%define SCHE_MATCH_THRESH   (SCHE_META + 4)               ; f32 match threshold
%define SCHE_PRED_TOKEN     (SCHE_META + 8)               ; u32 base prediction token
%define SCHE_HITS           (SCHE_META + 12)              ; u32 hit count
%define SCHE_MISSES         (SCHE_META + 16)              ; u32 miss count
%define SCHE_BIRTH          (SCHE_META + 20)              ; u32 creation step
%define SCHE_LAST_FIRE      (SCHE_META + 24)              ; u32 last match step
%define SCHE_CTX_PATTERN    (SCHE_META + 28)              ; u32 hash pattern
%define SCHE_RESERVED       (SCHE_META + 32)              ; 32 bytes padding

; Schema flags
%define SCHEF_ACTIVE        0x01                          ; schema is active
%define SCHEF_FROZEN        0x02                          ; don't modify
%define SCHEF_LEARNED       0x04                          ; learned from data (vs. bootstrap)
%define SCHEF_PROVEN        0x08                          ; high accuracy confirmed

; Schema state tracking
%define ST_SCHEMA_COUNT     ST_SCHEMA_TRACE_END           ; u32 active schemas
%define ST_SCHEMA_MATCHES   (ST_SCHEMA_COUNT + 4)         ; u32 total schema matches
%define ST_SCHEMA_EXTRACTS  (ST_SCHEMA_MATCHES + 4)       ; u32 total variable extractions
%define ST_SCHEMA_END       (ST_SCHEMA_EXTRACTS + 4)

; Location IDs for tracing - comprehensive coverage
; Format: TRACE_<module>_<function> = base, entry=base, exit=base+1
; Each function gets 2 IDs: entry and exit

; === io.asm (100-149) ===
%define TRACE_IO_WRITE_STDOUT       100
%define TRACE_IO_READ_STDIN         102

; === surface.asm (150-199) ===
%define TRACE_SURFACE_INIT          150
%define TRACE_REGION_ALLOC          152
%define TRACE_REGION_CONDEMN        154
%define TRACE_REGION_COMPACT        156
%define TRACE_REGION_MERGE_PASS     158

; === signal.asm (200-249) ===
%define TRACE_FAULT_HANDLER         200
%define TRACE_FAULT_RETURN_STUB     202

; === repl.asm (250-299) ===
%define TRACE_REPL_RUN              250
%define TRACE_REPL_LOOP             252

; === vsa.asm (300-399) ===
%define TRACE_VSA_INIT_RANDOM       300
%define TRACE_VSA_DOT               302
%define TRACE_VSA_BIND              304
%define TRACE_VSA_SUPERPOSE         306
%define TRACE_HOLO_STORE            308
%define TRACE_HOLO_PREDICT          310
%define TRACE_VOCAB_REGISTER        312

; === dispatch.asm (400-499) ===
%define TRACE_DISPATCH_INIT         400
%define TRACE_PROCESS_INPUT         402
%define TRACE_TOKENIZE_WORD         404
%define TRACE_PROCESS_TOKEN         406
%define TRACE_DISPATCH_PREDICT      408
%define TRACE_SPREAD_ACTIVATION     410
%define TRACE_DECAY_ALL_REGIONS     412
%define TRACE_RECORD_FIRE           414
%define TRACE_FIND_REGION_INDEX     416

; === emit.asm (500-549) ===
%define TRACE_EMIT_DISPATCH_PATTERN 500
%define TRACE_EMIT_NOP_SLED         502
%define TRACE_EMIT_RET              504

; === learn.asm (550-599) ===
%define TRACE_LEARN_PATTERN         550
%define TRACE_FIND_EXISTING_PATTERN 552
%define TRACE_STRENGTHEN_REGION     554
%define TRACE_WEAKEN_REGION         556
%define TRACE_WIRE_NEW_REGION       558
%define TRACE_LEARN_CONNECTIONS     560

; === hooks.asm (600-649) ===
%define TRACE_FIRE_HOOK             600
%define TRACE_FIRE_HOOK_CALL        602
%define TRACE_HOOK_REGISTER         604
%define TRACE_HOOK_UNREGISTER       606

; === observe.asm (650-699) ===
%define TRACE_OBSERVE_CYCLE         650
%define TRACE_PRESENCE_SHOW         652
%define TRACE_DECAY_CONN_WEIGHTS    654
%define TRACE_REPAIR_ROUTING        656

; === modify.asm (700-749) ===
%define TRACE_MODIFY_PRUNE          700
%define TRACE_MODIFY_PROMOTE        702
%define TRACE_MODIFY_SPECIALIZE     704
%define TRACE_MODIFY_GENERALIZE     706
%define TRACE_LOG_CAUSAL            708

; === gate.asm (750-799) ===
%define TRACE_GATE_TEST_MOD         750
%define TRACE_GATE_CHECK_REGION     752

; === decode.asm (800-849) ===
%define TRACE_DECODE_INSTR_LEN      800
%define TRACE_DECODE_REGION_INSTR   802

; === drives.asm (850-899) ===
%define TRACE_DRIVES_CHECK          850
%define TRACE_DRIVES_SHOW           852

; === evolve.asm (900-949) ===
%define TRACE_EVOLVE_CYCLE          900
%define TRACE_EVOLVE_REPRODUCE      902
%define TRACE_EVOLVE_MUTATE         904
%define TRACE_EVOLVE_CROSSOVER      906

; === dreams.asm (950-999) ===
%define TRACE_DREAM_CYCLE           950
%define TRACE_DREAM_CONSOLIDATE     952
%define TRACE_DREAM_EXTRACT_SCHEMAS 954

; === persist.asm (1000-1049) ===
%define TRACE_PERSIST_SAVE          1000
%define TRACE_PERSIST_LOAD          1002

; === introspect.asm (1050-1099) ===
%define TRACE_INTROSPECT_REGION     1050
%define TRACE_INTROSPECT_SCAN       1052
%define TRACE_UPDATE_ANTICIPATORY   1054
%define TRACE_DECAY_ANTICIPATORY    1056
%define TRACE_UPDATE_ORGANIC        1058
%define TRACE_UPDATE_OSCILLATION    1060
%define TRACE_UPDATE_PRES_DISPATCH  1062

; === genes.asm (1100-1149) ===
%define TRACE_GENE_EXTRACT          1100
%define TRACE_GENE_POOL_ADD         1102
%define TRACE_GENE_POOL_SAMPLE      1104
%define TRACE_GENE_POOL_INIT        1106

; === receipt.asm (1150-1199) ===
%define TRACE_RECEIPT_EMIT          1150
%define TRACE_RECEIPT_RESONATE      1152
%define TRACE_RECEIPT_DUMP          1154

;; ============================================================
;; Graph Dynamics Tuning Constants
;; ============================================================

%define PRIME_DECAY_HEX         0x3FECCCCCCCCCCCCD  ; 0.9 f64
%define ACTIVATION_DECAY_HEX    0x3FEB333333333333  ; 0.85 f64
%define LEARNING_RATE_HEX       0x3FA999999999999A  ; 0.05 f64
%define TAU_HEX                 0x4010000000000000  ; 4.0 f64
%define TAU_WINDOW_HEX          0x4020000000000000  ; 8.0 f64
%define WEIGHT_DECAY_HEX        0x3FEFEFEFEFEFEFEF  ; 0.995 f64
%define WEIGHT_FLOOR_HEX        0x3F847AE147AE147B  ; 0.01 f64
%define ACTIVATION_THRESH_HEX   0x3FB999999999999A  ; 0.1 f64

%define MAX_TRAVERSE_DEPTH  16
%define FIRE_RING_CAP       64
%define INITIAL_WEIGHT      0x3FB999999999999A      ; 0.1 f64 (initial excite weight)

;; Goal enums
%define GOAL_NONE           0
%define GOAL_EXPLORE        1
%define GOAL_PRUNE          2
%define GOAL_ALIGN          3
%define GOAL_CONSOLIDATE    4

;; Introspective state enums
%define INTRO_IDLE          0
%define INTRO_CONFUSED      1
%define INTRO_CONFIDENT     2
%define INTRO_LEARNING      3
%define INTRO_STUCK         4
%define INTRO_EXPLORING     5
%define INTRO_CONSOLIDATING 6

;; Surprise type enums
%define SURPRISE_NONE       0
%define SURPRISE_OUTCOME    1   ; low-confidence region missed (expected uncertainty)
%define SURPRISE_SELF       2   ; high-confidence region missed (self-model violated)

;; Dispatch mode enums (cognitive controller strategies)
%define DMODE_FAST          0   ; first match wins (familiar contexts)
%define DMODE_BEST          1   ; scan all, pick highest-accuracy match
%define DMODE_EXPLORE       2   ; prefer novel/low-hit regions
%define DMODE_DELIBERATE    3   ; gate-test top candidates
%define DMODE_MULTI_EXPERT  4   ; vote across top-N matching regions
%define DMODE_STRUCTURAL    5   ; use schema patterns and working memory slots
%define DMODE_CAUSAL        6   ; follow causal chain from recent firings
%define DMODE_ANALOGICAL    7   ; use similarity to recent episodes

;; ============================================================
;; Hook IDs
;; ============================================================

%define HOOK_PRE_STEP       0
%define HOOK_POST_STEP      1
%define HOOK_ON_HIT         2
%define HOOK_ON_MISS        3
%define HOOK_ON_LEARN       4
%define HOOK_ON_PRUNE       5
%define HOOK_ON_PROMOTE     6
%define HOOK_PRE_MODIFY     7
%define HOOK_POST_MODIFY    8
%define HOOK_ON_EMIT        9
%define HOOK_ON_DRIVE       10
%define HOOK_ON_EPISODE     11
%define HOOK_ON_DREAM_START 12
%define HOOK_ON_DREAM_END   13
%define HOOK_ON_OBSERVE     14
%define HOOK_ON_EVOLVE      15
%define HOOK_ON_GATE_PASS   16
%define HOOK_ON_GATE_FAIL   17
%define HOOK_ON_COMPACT     18
%define HOOK_ON_SAVE        19
%define HOOK_ON_RESTORE     20
%define HOOK_ON_INPUT       21

;; ============================================================
;; Presence Field Indices
;; ============================================================

%define PRES_TEXTURE        0
%define PRES_CONTINUITY     1
%define PRES_NOVELTY        2
%define PRES_AROUSAL        3
%define PRES_VALENCE        4
%define PRES_UNCERTAINTY    5
%define PRES_ENGAGEMENT     6
%define PRES_COHERENCE      7
%define PRES_FOCUS          8
%define PRES_FATIGUE        9
%define PRES_MOMENTUM       10
%define PRES_STABILITY      11
%define PRES_COMPLEXITY     12
%define PRES_DENSITY        13
%define PRES_TEMPERATURE    14
%define PRES_PRESSURE       15
%define PRES_ENTROPY        16
%define PRES_RHYTHM         17
%define PRES_DEPTH          18
%define PRES_BREADTH        19
%define PRES_RESONANCE      20
%define PRES_DISSONANCE     21
%define PRES_GROWTH         22
%define PRES_DECAY          23
%define PRES_SYMMETRY       24
%define PRES_SURPRISE       25
%define PRES_FAMILIARITY    26
%define PRES_AGENCY         27
%define PRES_INTEGRATION    28
%define PRES_META_AWARENESS 29
%define NUM_PRESENCE        30

;; ============================================================
;; Drive Indices
;; ============================================================

%define DRIVE_ACCURACY      0
%define DRIVE_EFFICIENCY    1
%define DRIVE_NOVELTY       2
%define DRIVE_COHERENCE     3

;; ============================================================
;; Drive Thresholds (IEEE 754 f32 representations)
;; ============================================================

%define THRESH_ACCURACY     0x3E99999A        ; 0.3f
%define THRESH_EFFICIENCY   0x3F333333        ; 0.7f
%define THRESH_NOVELTY      0x3F666666        ; 0.9f
%define THRESH_COHERENCE    0x3E99999A        ; 0.3f

;; ============================================================
;; Tuning Constants
;; ============================================================

%define OBSERVE_INTERVAL    100
%define PRUNE_MIN_AGE       500
%define PRUNE_ACCURACY      0x3DCCCCCD        ; 0.1f
%define PROMOTE_ACCURACY    0x3F4CCCCD        ; 0.8f
%define DREAM_REPLAY_COUNT  64
%define GATE_TEST_COUNT     8
%define EVOLVE_POOL_SIZE    16
%define COMPACT_THRESHOLD   64

; Metabolic energy constants (f64 hex representations)
%define ENERGY_INITIAL          0x4059000000000000  ; 100.0 — starting energy
%define ENERGY_MAX              0x4079000000000000  ; 400.0 — energy cap
%define ENERGY_HIT_INCOME       0x3FF0000000000000  ; 1.0 — earned per hit
%define ENERGY_EMIT_COST        0x4000000000000000  ; 2.0 — cost to emit new region
%define ENERGY_PREDICT_COST     0x3FB999999999999A  ; 0.1 — cost per prediction attempt
%define ENERGY_DREAM_COST       0x4014000000000000  ; 5.0 — cost per dream cycle
%define ENERGY_EVOLVE_COST      0x4024000000000000  ; 10.0 — cost per evolution
%define ENERGY_OBSERVE_COST     0x4008000000000000  ; 3.0 — cost per observe cycle
%define ENERGY_CONSUME_RATE     0x4034000000000000  ; 20.0 — energy per consumed region (its knowledge becomes fuel)
%define ENERGY_STARVATION       0x4024000000000000  ; 10.0 — below this, system conserves

; Organic trigger thresholds (f64 hex representations)
%define DREAM_PRESSURE_THRESH   0x3FF199999999999A  ; 1.1 — dream fires when pressure > this
%define OBSERVE_PRESSURE_THRESH 0x3FF0000000000000  ; 1.0 — observe fires when pressure > this
%define EVOLVE_PRESSURE_THRESH  0x4000000000000000  ; 2.0 — evolve fires when pressure > this
%define INTROSPECT_PRESSURE_THRESH 0x3FE8000000000000 ; 0.75 — introspect fires when self-surprise accumulates
%define ANTIC_MATERIALIZE_THRESH 0x3FE999999999999A ; 0.8 — anticipation becomes concrete
%define ANTIC_SIGNAL_FLOOR      0x3FA999999999999A  ; 0.05 — below this, signal is noise
%define MISS_PRESSURE_ALPHA     0x3F947AE147AE147B  ; 0.02 — EMA smoothing for miss pressure
%define FLATNESS_THRESH         0x3F747AE147AE147B  ; 0.005 — amplitude below = flat
%define OSCILLATION_MIN         30                  ; steps before checking oscillation

; Temporal rhythm constants
%define TEMPO_MIN               0x3FE0000000000000  ; 0.5 — slowest tempo
%define TEMPO_MAX               0x4000000000000000  ; 2.0 — fastest tempo
%define TEMPO_AROUSAL_SCALE     0x3FE0000000000000  ; 0.5 — arousal contribution to tempo
%define TEMPO_FATIGUE_SCALE     0x3FD0000000000000  ; 0.25 — fatigue slows tempo

;; ============================================================
;; Region Semantic Signatures (from introspection decoder)
;; ============================================================

%define RSEM_UNKNOWN        0   ; couldn't decode
%define RSEM_CMP_JE_RET     1   ; simple: compare context, branch, return token
%define RSEM_CMP_JE_CHAIN   2   ; compare context, branch, chain to next
%define RSEM_MULTI_CMP      3   ; multiple context comparisons
%define RSEM_SCHEMA          4   ; generalized pattern (masked comparison)
%define RSEM_CALL_RELAY      5   ; relays to another function

; Introspection cache entry field offsets
%define ICE_REGION_PTR      0   ; u64
%define ICE_CTX_HASH        8   ; u32 (decoded from region code)
%define ICE_PRED_TOKEN      12  ; u32 (decoded from region code)
%define ICE_ACCURACY         16  ; f32
%define ICE_SEMANTIC_SIG    20  ; u32 (RSEM_* enum)
%define ICE_NEIGHBOR_COUNT  24  ; u16
%define ICE_DEPTH           26  ; u16
%define ICE_PAD             28  ; u32

; Anticipatory buffer entry field offsets
%define ABE_TOKEN_ID        0   ; u32
%define ABE_ACCUM_CONF      8   ; f64 (accumulated sub-threshold confidence)
%define ABE_LAST_STEP       16  ; u32
%define ABE_HIT_COUNT       20  ; u32 (how many times this signal appeared)

;; ============================================================
;; Token Hashing
;; ============================================================

%define FNV32_INIT          0x811C9DC5
%define FNV32_PRIME         0x01000193
%define FNV64_INIT          0xCBF29CE484222325
%define FNV64_PRIME         0x00000100000001B3
%define CTX_WINDOW          8

;; ============================================================
;; Resonant Dispatch Configuration
;; Fuzzy matching via VSA vector similarity
;; ============================================================

; Threshold for resonant match acceptance (f64 hex)
; 0.7 = strong similarity required for fuzzy match
%define RESONANT_THRESHOLD_HEX  0x3FE6666666666666   ; 0.7 f64

; Resonant region code layout marker (distinguishes from exact CMP)
; Resonant regions start with: MOV EAX, 0xRE50AAAA (magic marker)
; followed by the expected context hash for vector generation
%define RESONANT_MAGIC          0xRE50AAAA

;; ============================================================
;; I/O
;; ============================================================

%define INPUT_BUF_SIZE      4096
%define OUTPUT_BUF_SIZE     4096
%define MAX_WORD_LEN        128

%endif
; syscalls.inc — Linux x86_64 syscall numbers and constants
%ifndef SYSCALLS_INC
%define SYSCALLS_INC

%define SYS_READ            0
%define SYS_WRITE           1
%define SYS_OPEN            2
%define SYS_CLOSE           3
%define SYS_STAT            4
%define SYS_FSTAT           5
%define SYS_LSTAT           6
%define SYS_MMAP            9
%define SYS_MPROTECT        10
%define SYS_MUNMAP          11
%define SYS_BRK             12
%define SYS_MSYNC           26
%define SYS_MADVISE         28

; madvise flags
%define MADV_NORMAL         0                 ; no special treatment
%define MADV_RANDOM         1                 ; expect random access
%define MADV_SEQUENTIAL     2                 ; expect sequential access
%define MADV_WILLNEED       3                 ; will need these pages
%define MADV_DONTNEED       4                 ; don't need these pages
%define MADV_HUGEPAGE       14                ; use huge pages if possible
%define SYS_RT_SIGACTION    13
%define SYS_RT_SIGRETURN    15
%define SYS_NANOSLEEP       35
%define SYS_GETPID          39
%define SYS_EXIT            60
%define SYS_FCNTL           72
%define SYS_FTRUNCATE       77
%define SYS_GETCWD          79
%define SYS_RENAME          82
%define SYS_GETTIMEOFDAY    96
%define SYS_UNLINK          87
%define SYS_LSEEK           8
%define SYS_PWRITE          18
%define SYS_MKDIR           83
%define SYS_GETDENTS        78
%define SYS_OPENAT          257
%define SYS_FSYNC           74
%define SYS_CLOCK_GETTIME   228
%define SYS_GETRANDOM       318

; mmap protection flags
%define PROT_READ           0x1
%define PROT_WRITE          0x2
%define PROT_EXEC           0x4
%define PROT_RWX            (PROT_READ | PROT_WRITE | PROT_EXEC)

; mmap flags
%define MAP_SHARED          0x01
%define MAP_PRIVATE         0x02
%define MAP_FIXED           0x10
%define MAP_ANONYMOUS       0x20

; open flags
%define O_RDONLY            0
%define O_WRONLY            1
%define O_RDWR              2
%define O_CREAT             0x40
%define O_TRUNC             0x200

; file mode
%define FILE_MODE           0o644

; signal numbers
%define SIGSEGV             11
%define SIGFPE              8
%define SIGBUS              7
%define SIGILL              4
%define SIGPIPE             13
%define SIGTRAP             5     ; INT 3 breakpoint (self-debugger)

; sigaction flags
%define SA_SIGINFO          0x04
%define SA_RESTORER         0x04000000

; file descriptors
%define STDIN               0
%define STDOUT              1
%define STDERR              2

; socket syscalls
%define SYS_SOCKET          41
%define SYS_BIND            49
%define SYS_LISTEN          50
%define SYS_ACCEPT          43
%define SYS_CONNECT         42
%define SYS_SETSOCKOPT      54
%define SYS_SELECT          23
%define SYS_POLL            7

; socket constants
%define AF_INET             2
%define SOCK_STREAM         1
%define SOL_SOCKET          1
%define SO_REUSEADDR        2
%define INADDR_LOOPBACK     0x0100007F  ; 127.0.0.1 in network byte order

; poll events
%define POLLIN              0x0001

%endif
; vsa_ops.inc — Rosetta Stone: Opcode-to-Vector Mapping
; The bridge that makes Code into Math.
;
; Every x86 instruction becomes a vector. Every register becomes a vector.
; This enables:
;   1. Geometric Safety: DotProduct(CodeVector, SafetyVector) > 0 = safe
;   2. Semantic Similarity: similar opcodes have similar vectors
;   3. Interference Learning: code patterns superpose into traces
;   4. Telepathic Communication: instances share code as vectors
;
; Philosophy: "One Math" — Linear Algebra replaces if statements

%ifndef VSA_OPS_INC
%define VSA_OPS_INC

;; ============================================================
;; Opcode Category Seeds (high 16 bits of vector hash)
;; Opcodes in the same category share vector similarity
;; ============================================================

; Data Movement Family — vectors cluster together
%define OPCAT_MOV           0x1000      ; data movement
%define OPCAT_PUSH          0x1100      ; stack push
%define OPCAT_POP           0x1200      ; stack pop
%define OPCAT_XCHG          0x1300      ; exchange

; Arithmetic Family
%define OPCAT_ADD           0x2000      ; addition
%define OPCAT_SUB           0x2100      ; subtraction
%define OPCAT_MUL           0x2200      ; multiplication
%define OPCAT_DIV           0x2300      ; division
%define OPCAT_INC           0x2400      ; increment
%define OPCAT_DEC           0x2500      ; decrement
%define OPCAT_NEG           0x2600      ; negation

; Logic Family
%define OPCAT_AND           0x3000      ; bitwise AND
%define OPCAT_OR            0x3100      ; bitwise OR
%define OPCAT_XOR           0x3200      ; bitwise XOR
%define OPCAT_NOT           0x3300      ; bitwise NOT
%define OPCAT_SHL           0x3400      ; shift left
%define OPCAT_SHR           0x3500      ; shift right
%define OPCAT_ROL           0x3600      ; rotate left
%define OPCAT_ROR           0x3700      ; rotate right

; Comparison Family
%define OPCAT_CMP           0x4000      ; compare
%define OPCAT_TEST          0x4100      ; test (AND without store)

; Control Flow Family
%define OPCAT_JMP           0x5000      ; unconditional jump
%define OPCAT_JCC           0x5100      ; conditional jump
%define OPCAT_CALL          0x5200      ; function call
%define OPCAT_RET           0x5300      ; return
%define OPCAT_LOOP          0x5400      ; loop instructions

; Memory Family
%define OPCAT_LEA           0x6000      ; load effective address
%define OPCAT_LOAD          0x6100      ; memory load
%define OPCAT_STORE         0x6200      ; memory store

; System Family (potentially dangerous)
%define OPCAT_SYSCALL       0x7000      ; syscall
%define OPCAT_INT           0x7100      ; interrupt
%define OPCAT_PRIV          0x7200      ; privileged
%define OPCAT_NOP           0x7F00      ; no operation

;; ============================================================
;; Register Vector Seeds (low 16 bits distinguish registers)
;; Registers in the same family have similar vectors
;; ============================================================

; General Purpose (cluster by role)
%define REGVEC_RAX          0x0100      ; accumulator
%define REGVEC_RBX          0x0201      ; base (callee-saved)
%define REGVEC_RCX          0x0102      ; counter
%define REGVEC_RDX          0x0103      ; data
%define REGVEC_RSI          0x0104      ; source index
%define REGVEC_RDI          0x0105      ; destination index
%define REGVEC_RBP          0x0206      ; base pointer (callee-saved)
%define REGVEC_RSP          0x0307      ; stack pointer (special)
%define REGVEC_R8           0x0108      ; extended caller-saved
%define REGVEC_R9           0x0109
%define REGVEC_R10          0x010A
%define REGVEC_R11          0x010B
%define REGVEC_R12          0x020C      ; callee-saved
%define REGVEC_R13          0x020D
%define REGVEC_R14          0x020E
%define REGVEC_R15          0x020F

; Special Registers (distinct cluster)
%define REGVEC_RIP          0x0400      ; instruction pointer
%define REGVEC_RFLAGS       0x0500      ; flags register

;; ============================================================
;; Safety Vector Dimensions (which dimensions encode safety properties)
;; The "Geometric Gate" checks these dimensions
;; ============================================================

; Dimension assignments (out of 1024):
; 0-255:    Opcode signature (from category + specific opcode)
; 256-511:  Operand pattern (register combinations)
; 512-767:  Memory access pattern
; 768-1022: Semantic properties
; 1023:     Valence channel (already defined)

%define VDIM_OPCODE_START   0
%define VDIM_OPCODE_END     255
%define VDIM_OPERAND_START  256
%define VDIM_OPERAND_END    511
%define VDIM_MEMORY_START   512
%define VDIM_MEMORY_END     767
%define VDIM_SEMANTIC_START 768
%define VDIM_SEMANTIC_END   1022

; Safety property dimensions (within semantic range)
%define VDIM_WRITES_MEMORY  768         ; 1.0 if instruction writes to memory
%define VDIM_READS_MEMORY   769         ; 1.0 if instruction reads from memory
%define VDIM_MODIFIES_STACK 770         ; 1.0 if instruction changes RSP
%define VDIM_CONTROL_FLOW   771         ; 1.0 if instruction can change RIP
%define VDIM_PRIVILEGED     772         ; 1.0 if instruction is privileged
%define VDIM_SYSCALL        773         ; 1.0 if instruction is syscall
%define VDIM_INTERRUPT      774         ; 1.0 if instruction triggers interrupt
%define VDIM_CALLEE_CLOBBER 775         ; 1.0 if clobbers callee-saved without save
%define VDIM_BOUNDED_JUMP   776         ; 1.0 if jump target is within bounds
%define VDIM_STACK_BALANCED 777         ; 1.0 if push/pop are balanced
%define VDIM_PURE_COMPUTE   778         ; 1.0 if no side effects
%define VDIM_IDEMPOTENT     779         ; 1.0 if repeating is safe

;; ============================================================
;; Pre-computed Safety Vectors (dot product for quick checks)
;; ============================================================

; SAFE_CODE_SIGNATURE: Dot product with this should be positive for safe code
; High values in: VDIM_BOUNDED_JUMP, VDIM_STACK_BALANCED, VDIM_PURE_COMPUTE
; Low/negative in: VDIM_PRIVILEGED, VDIM_SYSCALL, VDIM_INTERRUPT

; DANGEROUS_CODE_SIGNATURE: Dot product > 0 means potentially dangerous
; High values in: VDIM_PRIVILEGED, VDIM_SYSCALL, VDIM_INTERRUPT

;; ============================================================
;; Instruction Encoding Constants
;; ============================================================

; Maximum instruction sequence length for encoding
%define INSTR_SEQ_MAX       32

; Hash combination for instruction encoding
; instruction_hash = opcat << 16 | (src_reg << 8) | dst_reg | (has_mem << 24)
%define INSTR_HASH_OPCAT_SHIFT  16
%define INSTR_HASH_SRC_SHIFT    8
%define INSTR_HASH_MEM_SHIFT    24

;; ============================================================
;; Vector Arithmetic Macros for Safety Checking
;; ============================================================

; Threshold for safety check (cosine similarity with safe code template)
%define SAFETY_THRESHOLD        0x3FD999999999999A  ; 0.4 f64

; Threshold for recognizing known-good patterns
%define PATTERN_THRESHOLD       0x3FE6666666666666  ; 0.7 f64

; Minimum similarity for fuzzy opcode matching
%define OPCODE_MATCH_THRESH     0x3FE0000000000000  ; 0.5 f64

;; ============================================================
;; Role Vectors for Structural Binding (Layer 1)
;; Used for role-filler representations: bind(ROLE, FILLER)
;; Each role occupies 32 dimensions to maintain orthogonality
;; ============================================================

; Positional Roles: encode position in sequence
; ROLE_POS_N has 1.0 in dims [ROLE_POS_BASE + N*32, ROLE_POS_BASE + N*32 + 31]
%define ROLE_POS_BASE           800         ; start of positional roles
%define ROLE_POS_WIDTH          32          ; dims per position
%define ROLE_POS_COUNT          8           ; positions 0-7

; Individual role dimension ranges
%define ROLE_POS_0_START        800         ; dims 800-831
%define ROLE_POS_1_START        832         ; dims 832-863
%define ROLE_POS_2_START        864         ; dims 864-895
%define ROLE_POS_3_START        896         ; dims 896-927
%define ROLE_POS_4_START        928         ; dims 928-959
%define ROLE_POS_5_START        960         ; dims 960-991
%define ROLE_POS_6_START        992         ; dims 992-1023
%define ROLE_POS_7_START        736         ; dims 736-767 (wraparound)

; Structural Roles: encode grammatical/semantic roles
%define ROLE_STRUCT_BASE        640         ; start of structural roles
%define ROLE_STRUCT_WIDTH       32          ; dims per role

%define ROLE_SUBJECT_START      640         ; dims 640-671
%define ROLE_VERB_START         672         ; dims 672-703
%define ROLE_OBJECT_START       704         ; dims 704-735

; Role vector magnitude (should be 1.0 for unit vectors)
; Each role has ROLE_POS_WIDTH dimensions set to 1/sqrt(WIDTH)
%define ROLE_ELEMENT_VAL        0x3FC0000000000000  ; ~0.1767 = 1/sqrt(32)

%endif
